# P55：【2025版】55. 噪声映射网络.zh_en - 小土堆Pytorch教程 - BV1YeknYbENz

现在您将学习噪音映射网络，这是风格GAN独特的组成部分之一，用于将噪音向量作为输入。

![](img/71ca6b6768abd85a73a41c9bf768d980_1.png)

这将有助于后期控制风格，首先，您将查看噪音映射网络的结构，然后了解它存在的原因，最后，了解其输出——中间向量的实际去向。



![](img/71ca6b6768abd85a73a41c9bf768d980_3.png)

噪音映射网络实际上将您的噪音向量z映射为中间噪音向量w。

![](img/71ca6b6768abd85a73a41c9bf768d980_5.png)

![](img/71ca6b6768abd85a73a41c9bf768d980_6.png)

这个噪音映射网络由八个全连接层组成，之间有激活函数。

![](img/71ca6b6768abd85a73a41c9bf768d980_8.png)

也称为多层感知机或MLP。

![](img/71ca6b6768abd85a73a41c9bf768d980_10.png)

所以它是一个相当简单的神经网络，接受您的z噪音向量。

![](img/71ca6b6768abd85a73a41c9bf768d980_12.png)

这是大小512，并将其映射到你的中间噪声向量上，这仍然是大小512，所以它只是改变了值，所以你仍然用z做同样的事情，你仍然从512个正常分布的值中采样z。



![](img/71ca6b6768abd85a73a41c9bf768d980_14.png)

然后你现在通过此网络获取此中间w噪声向量。

![](img/71ca6b6768abd85a73a41c9bf768d980_16.png)

这样做的动机是。

![](img/71ca6b6768abd85a73a41c9bf768d980_18.png)

将你的噪声向量映射到实际会得到更解耦的表现，作为快速提醒。

![](img/71ca6b6768abd85a73a41c9bf768d980_20.png)

在z空间中的纠缠是你噪声向量并不真正映射到输出特征，一对一的方式，当你改变这些z向量值时，你可以实际改变输出中许多不同的特征，但这是不好的，因为这不允许你有很多精细的控制成分。

或者你想要在你最终图像中的特征级别的控制，因为你可能试图改变某人的眼睛，然后你突然改变了他们的胡子。

![](img/71ca6b6768abd85a73a41c9bf768d980_22.png)

或者他们图像中是否有胡子，而噪声向量来自的空间z通常被纠缠。

![](img/71ca6b6768abd85a73a41c9bf768d980_24.png)

这是因为你所知道的真实数据具有一定的概率密度，这意味着某一张图片的样本存在一定的概率，戴着眼镜，或不戴眼镜，有胡须，有特定的发色，眼睛或与之相关的年龄，实际特征周围存在这种概率密度。

但由于z具有正态先验，你从正态分布中抽取所有值，这使得它很难映射这个正态分布。

![](img/71ca6b6768abd85a73a41c9bf768d980_26.png)

到你所有输出特征的正确密度分布。

![](img/71ca6b6768abd85a73a41c9bf768d980_28.png)

因为你期望随机噪声向量，基本上能够建模这个眼镜空间。

![](img/71ca6b6768abd85a73a41c9bf768d980_30.png)

有胡须，什么颜色，头发，眼睛像所有类型的图像，所有与那些图像相关的特征，如果你期望z空间的噪声向量这样做，这对它来说实际上是相当具有挑战性的，它会尝试找到一种方式扭曲自己，以尝试将这些期望的特征映射。



![](img/71ca6b6768abd85a73a41c9bf768d980_32.png)

它经常以一种对我们来说可能不太有意义的方式扭曲自己。

![](img/71ca6b6768abd85a73a41c9bf768d980_34.png)

所以让它完全解缠，完成一一对映射，这种假设并不理想。

![](img/71ca6b6768abd85a73a41c9bf768d980_36.png)

所以实现这一点是完全不理想的，所以它很可能会学习一套复杂的纠缠映射来实现这一点。

![](img/71ca6b6768abd85a73a41c9bf768d980_38.png)

以便能够将这些输出特征映射。

![](img/71ca6b6768abd85a73a41c9bf768d980_40.png)

我们希望它能够映射并生成。

![](img/71ca6b6768abd85a73a41c9bf768d980_42.png)

到并生成，然而，这个中间映射可以为噪声向量提供一些空间，它可以允许这个空间，现在称为w空间，以匹配真实数据的密度。



![](img/71ca6b6768abd85a73a41c9bf768d980_44.png)

因此噪声向量不需要完全固定在训练数据的统计中。

![](img/71ca6b6768abd85a73a41c9bf768d980_46.png)

但它可以学习这些现在线性且易于生成的变异因素。

![](img/71ca6b6768abd85a73a41c9bf768d980_48.png)

这将减少样式之间的紧密相关性。

![](img/71ca6b6768abd85a73a41c9bf768d980_50.png)

这最终有助于控制和映射特征，我不认为w空间是完美的。

![](img/71ca6b6768abd85a73a41c9bf768d980_52.png)

正如这张图所示，这只是一个图形。

![](img/71ca6b6768abd85a73a41c9bf768d980_54.png)

这只是比z空间更少纠缠，作为一个快速说明，这些向量在这里是7个，实际上这里有512个，那么这种噪声映射网络在这个样式架构中的作用是什么。



![](img/71ca6b6768abd85a73a41c9bf768d980_56.png)

你将学习渐进增长的知识。

![](img/71ca6b6768abd85a73a41c9bf768d980_58.png)

输出会每隔一段时间翻倍，这就是生成器架构看起来的样子，噪声映射网络实际上在这里的所有块中作为输入。

![](img/71ca6b6768abd85a73a41c9bf768d980_60.png)

你可能会注意到这里z的位置。

![](img/71ca6b6768abd85a73a41c9bf768d980_62.png)

这里不再适用，而是通过这个映射网络，w实际上在网络中的多个地方输入。

![](img/71ca6b6768abd85a73a41c9bf768d980_64.png)

在下一个视频中你会看到它如何被添加到所有这些地方。

![](img/71ca6b6768abd85a73a41c9bf768d980_66.png)

以及如何在不同的地方w的影响不同。

![](img/71ca6b6768abd85a73a41c9bf768d980_68.png)

它是在哪里输入的，它在早期还是晚期的影响不同，我知道w实际上不在网络的开始部分输入。

![](img/71ca6b6768abd85a73a41c9bf768d980_70.png)

这与z在原始gan设置中的做法不同，这是因为style again的作者们发现不加入w并没有显著的区别。



![](img/71ca6b6768abd85a73a41c9bf768d980_72.png)

所以将w放在那里或不放基本上是一样的，所以而不是在网络的一开始就输入w，模型实际上开始的是一个常量值，网络实际上开始的是一个固定值。



![](img/71ca6b6768abd85a73a41c9bf768d980_74.png)

这个值对于任何生成的图像都不会改变。

![](img/71ca6b6768abd85a73a41c9bf768d980_76.png)

实际上不是一个固定值，这是一个4x4x5的固定值。

![](img/71ca6b6768abd85a73a41c9bf768d980_78.png)

12个。

![](img/71ca6b6768abd85a73a41c9bf768d980_80.png)

它输入时，当它输入时，然后从4x4开始生长，宽度，然后512个通道，再次，这是对每个生成的图像相同的值，所以对任何生成的图像进行任何更改都会发生在噪声向量被引入的地方，这无处不在，这是全部这些块。

实际上在每个中间块这里。

![](img/71ca6b6768abd85a73a41c9bf768d980_82.png)

实际上在每个这些块中多次插入，这相当酷，你将在下一个视频中了解噪声向量如何精确地加入到这些块中。

![](img/71ca6b6768abd85a73a41c9bf768d980_84.png)

你刚刚了解了噪声映射网络，这是一个多层感知机或前馈神经网络，具有完全连接的层和层之间的激活，它将你的z噪声向量映射到一个中间噪声向量w，并且w被用作生成器中的多个输入。



![](img/71ca6b6768abd85a73a41c9bf768d980_86.png)