- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分类：未分类
- en: 'date: 2024-09-08 18:49:12'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-09-08 18:49:12
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'RepairAgent: An Autonomous, LLM-Based Agent for Program Repair'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RepairAgent：一种基于LLM的自主程序修复智能体
- en: 来源：[https://ar5iv.labs.arxiv.org/html/2403.17134](https://ar5iv.labs.arxiv.org/html/2403.17134)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://ar5iv.labs.arxiv.org/html/2403.17134](https://ar5iv.labs.arxiv.org/html/2403.17134)
- en: \useunder
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: \useunder
- en: \ul
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: \ul
- en: Islem Bouzenia
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Islem Bouzenia
- en: University of Stuttgart
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 斯图加特大学
- en: Germany
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 德国
- en: fi_bouzenia@esi.dz    Premkumar Devanbu
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: fi_bouzenia@esi.dz    Premkumar Devanbu
- en: UC Davis
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 加州大学戴维斯分校
- en: USA
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 美国
- en: ptdevanbu@ucdavis.edu    Michael Pradel
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ptdevanbu@ucdavis.edu    Michael Pradel
- en: University of Stuttgart
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 斯图加特大学
- en: Germany
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 德国
- en: michael@binaervarianz.de
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: michael@binaervarianz.de
- en: Abstract
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 摘要
- en: Automated program repair has emerged as a powerful technique to mitigate the
    impact of software bugs on system reliability and user experience. This paper
    introduces RepairAgent, the first work to address the program repair challenge
    through an autonomous agent based on a large language model (LLM). Unlike existing
    deep learning-based approaches, which prompt a model with a fixed prompt or in
    a fixed feedback loop, our work treats the LLM as an agent capable of autonomously
    planning and executing actions to fix bugs by invoking suitable tools. RepairAgent
    freely interleaves gathering information about the bug, gathering repair ingredients,
    and validating fixes, while deciding which tools to invoke based on the gathered
    information and feedback from previous fix attempts. Key contributions that enable
    RepairAgent include a set of tools that are useful for program repair, a dynamically
    updated prompt format that allows the LLM to interact with these tools, and a
    finite state machine that guides the agent in invoking the tools. Our evaluation
    on the popular Defects4J dataset demonstrates RepairAgent’s effectiveness in autonomously
    repairing 164 bugs, including 39 bugs not fixed by prior techniques. Interacting
    with the LLM imposes an average cost of 270,000 tokens per bug, which, under the
    current pricing of OpenAI’s GPT-3.5 model, translates to 14 cents per bug. To
    the best of our knowledge, this work is the first to present an autonomous, LLM-based
    agent for program repair, paving the way for future agent-based techniques in
    software engineering.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化程序修复已成为一种强大的技术，用于缓解软件缺陷对系统可靠性和用户体验的影响。本文介绍了RepairAgent，这是第一个通过基于大语言模型（LLM）的自主智能体来解决程序修复挑战的工作。与现有的深度学习方法不同，我们的工作将LLM视为一个能够自主规划和执行修复操作的智能体，利用适当的工具来修复缺陷。RepairAgent自由地交替进行收集缺陷信息、收集修复材料和验证修复的过程，同时根据收集到的信息和先前修复尝试的反馈决定调用哪些工具。使RepairAgent得以实现的关键贡献包括一组对程序修复有用的工具、一个动态更新的提示格式使LLM能够与这些工具交互，以及一个有限状态机来指导智能体调用这些工具。我们在流行的Defects4J数据集上的评估表明，RepairAgent在自主修复164个缺陷方面的有效性，其中包括39个先前技术未修复的缺陷。与LLM的交互对每个缺陷的平均成本为270,000个标记，根据OpenAI的GPT-3.5模型的当前定价，转化为每个缺陷14美分。据我们所知，这项工作是首次提出基于LLM的自主程序修复智能体，为未来的软件工程中的智能体技术铺平了道路。
- en: I Introduction
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I 介绍
- en: Software bugs lead to system failures, security vulnerabilities, and compromised
    user experience. Fixing bugs is a critical task in software development, but if
    done manually, demands considerable time and effort. Automated program repair
    (APR) promises to dramatically reduce this effort by addressing the critical need
    for effective and efficient bug resolution in an automated manner. Researchers
    and practitioners have explored various approaches to address the challenge of
    automatically fixing bugs [[1](#bib.bib1)], including techniques based on manually
    designed [[2](#bib.bib2), [3](#bib.bib3)] and (semi-)automatically extracted [[4](#bib.bib4),
    [5](#bib.bib5), [6](#bib.bib6)] fix patterns, based on symbolic constraints [[7](#bib.bib7),
    [8](#bib.bib8), [9](#bib.bib9)], and various machine learning-based approaches [[10](#bib.bib10),
    [11](#bib.bib11), [12](#bib.bib12), [13](#bib.bib13), [14](#bib.bib14), [15](#bib.bib15),
    [16](#bib.bib16)].
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 软件缺陷导致系统故障、安全漏洞和用户体验受损。修复缺陷是软件开发中的关键任务，但如果手动完成，则需要大量时间和精力。自动化程序修复（APR）有望通过以自动化的方式解决有效和高效的缺陷解决的关键需求，从而显著减少这一工作量。研究人员和实践者已经探索了多种方法来应对自动修复缺陷的挑战[[1](#bib.bib1)]，包括基于手动设计[[2](#bib.bib2),
    [3](#bib.bib3)]和（半）自动提取[[4](#bib.bib4), [5](#bib.bib5), [6](#bib.bib6)]的修复模式、基于符号约束[[7](#bib.bib7),
    [8](#bib.bib8), [9](#bib.bib9)]，以及各种基于机器学习的方法[[10](#bib.bib10), [11](#bib.bib11),
    [12](#bib.bib12), [13](#bib.bib13), [14](#bib.bib14), [15](#bib.bib15), [16](#bib.bib16)]。
- en: The current state-of-the-art in APR predominantly revolves around large language
    models (LLMs). The first generation of LLM-based repair techniques involve a one-time
    interaction with the model, where the model receives a prompt containing the buggy
    code and produces a fixed version [[17](#bib.bib17), [18](#bib.bib18)]. The second
    and current generation of LLM-based repair techniques introduces iterative approaches,
    which query the LLM repeatedly based on feedback obtained from previous fix attempts [[19](#bib.bib19),
    [20](#bib.bib20), [21](#bib.bib21)].
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的 APR 前沿技术主要围绕大型语言模型（LLMs）。第一代基于 LLM 的修复技术涉及与模型的一次性交互，其中模型接收包含错误代码的提示并生成修复版本[[17](#bib.bib17)、[18](#bib.bib18)]。第二代及当前的基于
    LLM 的修复技术引入了迭代方法，根据从之前修复尝试中获得的反馈反复查询 LLM[[19](#bib.bib19)、[20](#bib.bib20)、[21](#bib.bib21)]。
- en: A key limitation of current iterative, LLM-based repair techniques is that their
    hard-coded feedback loops do not allow the model to gather information about the
    bug or existing code that may provide ingredients to fix the bug. Instead, these
    approaches fix the context information provided in the prompt, typically to the
    buggy code [[19](#bib.bib19), [21](#bib.bib21)], and sometimes also details about
    the test cases that fail [[20](#bib.bib20)]. The feedback loop then executes the
    tests on different variants of the buggy code and adds any compilation errors,
    test failures, or other output, to the prompt of the next iteration. However,
    this approach fundamentally differs from the way human developers fix bugs, which
    typically involves a temporal interleaving of gathering information to understand
    the bug, searching code that may be helpful for fixing the bug, and experimenting
    with candidate fixes [[22](#bib.bib22), [23](#bib.bib23)].
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 目前基于迭代的 LLM 修复技术的一个关键限制是其硬编码的反馈循环无法让模型收集有关错误或现有代码的信息，这些信息可能提供修复错误的材料。相反，这些方法修复了提示中提供的上下文信息，通常是错误的代码[[19](#bib.bib19)、[21](#bib.bib21)]，有时还包括失败的测试用例的细节[[20](#bib.bib20)]。反馈循环随后在不同变体的错误代码上执行测试，并将任何编译错误、测试失败或其他输出添加到下一次迭代的提示中。然而，这种方法与人类开发人员修复错误的方式根本不同，人类开发人员通常涉及收集信息以理解错误、搜索可能有助于修复错误的代码，以及尝试候选修复[[22](#bib.bib22)、[23](#bib.bib23)]。
- en: This paper presents RepairAgent, the first autonomous, LLM-based agent for automated
    program repair. Our approach treats the LLM as an autonomous agent capable of
    planning and executing actions to achieve the goal of fixing a bug. To this end,
    we equip the LLM with a set of bug repair-specific tools that the models can invoke
    to interact with the code base in a way similar to a human developer. For example,
    RepairAgent has tools to extract information about the bug by reading specific
    lines of code, to gather repair ingredients by searching the code base, and to
    propose and validate fixes by applying a patch and executing test cases. Importantly,
    we do not hard-code how and when to use these tools, but instead let the LLM autonomously
    decide which tool to invoke next, based on previously gathered information and
    feedback from previous fix attempts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本文介绍了 RepairAgent，这是第一个基于 LLM 的自动化程序修复代理。我们的方法将 LLM 视为一个能够规划和执行操作以实现修复错误目标的自主代理。为此，我们为
    LLM 配备了一组特定于修复错误的工具，模型可以调用这些工具以类似于人类开发人员的方式与代码库进行交互。例如，RepairAgent 拥有通过阅读特定代码行提取有关错误的信息、通过搜索代码库收集修复所需材料，以及通过应用补丁和执行测试用例来提出和验证修复的工具。重要的是，我们并没有硬编码如何以及何时使用这些工具，而是让
    LLM 自主决定接下来调用哪个工具，基于之前收集的信息和之前修复尝试的反馈。
- en: Our approach is enabled by three key components. First, a general-purpose LLM,
    such as GPT-3.5, which we query repeatedly with a dynamically updated prompt.
    We contribute a novel prompt format that guides the LLM through the bug repair
    process, and that gets updated based on the commands invoked by the LLM and the
    results of the previous command executions. Second, a set of tools that the LLM
    can invoke to interact with the code base. We present a set of 14 tools designed
    to cover different steps a human developer would take when fixing a bug, such
    as reading specific lines of code, searching the code base, and applying a patch.
    Third, a middleware that orchestrates the communication between the LLM and the
    tools. We present novel techniques for guiding tool invocations through a finite
    state machine and for heuristically interpreting possibly incorrect LLM outputs.
    The iterative loop of RepairAgent continues until the agent declares to have found
    a suitable fix, or until exhausting a budget of iterations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法由三个关键组件构成。首先，是一个通用的LLM，例如GPT-3.5，我们通过动态更新的提示进行反复查询。我们贡献了一个新颖的提示格式，引导LLM完成错误修复过程，并根据LLM调用的命令和前一个命令执行的结果进行更新。其次，是一组工具，LLM可以调用这些工具与代码库进行交互。我们展示了一套14个工具，旨在覆盖人类开发者在修复错误时采取的不同步骤，例如读取特定代码行、搜索代码库和应用补丁。第三，是一个中间件，用于协调LLM与工具之间的通信。我们展示了通过有限状态机引导工具调用和启发式解释可能不正确的LLM输出的新技术。RepairAgent的迭代循环持续进行，直到代理声明找到合适的修复，或直到耗尽迭代预算。
- en: To evaluate the effectiveness of our approach, we apply it to all 835 bugs in
    the Defects4J [[24](#bib.bib24)] dataset, a widely used benchmark for evaluating
    program repair techniques. RepairAgent successfully fixes 164 bugs, including
    74 and 90 bugs of Defects4J v1.2 and v2.0, respectively. The correctly fixed bugs
    include 49 bugs that require fixing more than one line, showing that RepairAgent
    is capable of fixing complex bugs. Compared to state-of-the-art techniques [[19](#bib.bib19),
    [21](#bib.bib21)], RepairAgent successfully fixes 39 bugs not fixed by prior work.
    Measuring the costs imposed by interacting with the LLM, we find that RepairAgent
    imposes an average cost of 270,000 tokens per bug, which, under the current pricing
    of OpenAI’s GPT-3.5 model, translates to 14 cents per bug. Overall, our results
    show that our agent-based approach establishes a new state of the art in program
    repair.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估我们方法的有效性，我们将其应用于Defects4J [[24](#bib.bib24)] 数据集中的所有835个错误，这是一个广泛使用的程序修复技术评估基准。RepairAgent成功修复了164个错误，包括Defects4J
    v1.2和v2.0的74个和90个错误。正确修复的错误包括49个需要修复多于一行的错误，显示RepairAgent能够修复复杂错误。与最先进技术 [[19](#bib.bib19),
    [21](#bib.bib21)] 相比，RepairAgent成功修复了39个先前未修复的错误。通过测量与LLM交互所产生的成本，我们发现RepairAgent每个错误平均消耗270,000个tokens，这在当前OpenAI
    GPT-3.5模型的定价下，相当于每个错误14美分。总体而言，我们的结果显示，我们的基于代理的方法在程序修复中确立了新的技术水平。
- en: 'In summary, this paper contributes the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本文做出了以下贡献：
- en: •
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: An autonomous, LLM-based agent for program repair.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个基于LLM的程序修复自主代理。
- en: •
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: A dynamically updated prompt format that guides the LLM through the bug repair
    process.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个动态更新的提示格式，引导LLM完成错误修复过程。
- en: •
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: A set of tools that enable a LLM to to perform steps a human developer would
    take when fixing a bug.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一组工具，使LLM能够执行修复错误时人类开发者所采取的步骤。
- en: •
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: A middleware that orchestrates the communication between the LLM and the tools.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个协调LLM与工具之间通信的中间件。
- en: •
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Empirical evidence that RepairAgent establishes a new state of the art by successfully
    fixing 164 bugs, including 39 bugs not fixed by prior work.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实证证据表明，RepairAgent通过成功修复164个错误，包括39个先前未修复的错误，确立了新的技术水平。
- en: •
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: We will release the implementation of RepairAgent as open-source to foster future
    work.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将以开源形式发布RepairAgent的实现，以促进未来的工作。
- en: To the best of our knowledge, there currently is no published work on an autonomous,
    LLM-based agent for any code-generation task. We envision RepairAgent to pave
    the way for future agent-based techniques in software engineering.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 据我们所知，目前尚未有关于任何代码生成任务的自主LLM基础代理的公开研究。我们期望RepairAgent能够为未来基于代理的软件工程技术铺平道路。
- en: II Background on LLM-Based, Autonomous Agents
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: II 关于基于LLM的自主代理的背景
- en: By virtue of being trained on vast amounts of web knowledge, including natural
    language and source code, LLMs have demonstrated remarkable abilities in achieving
    human-level performance for various tasks [[25](#bib.bib25)]. A promising way
    of using these abilities are LLM-based agents that autonomously plan and execute
    actions to achieve a goal. The basic idea is to query the LLM with a prompt that
    contains the current state of the world, the goal to be achieved, and a set of
    actions that could be performed next. The model than decides which action to perform,
    and the feedback from performing the action is integrated into the next prompt.
    One way to represent “actions” is through tools that the model can invoke to interact
    with the world [[26](#bib.bib26), [27](#bib.bib27)]. Recent surveys provide a
    comprehensive overview of LLM-based, autonomous agents [[28](#bib.bib28)] and
    of LLM agents equipped with tools invoked via APIs [[29](#bib.bib29)]. The potential
    of such agents for software engineering currently is not well explored, which
    this paper aims to address for the challenging task of automated program repair.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在大量的网络知识，包括自然语言和源代码上进行训练，LLMs 在实现各种任务的人类水平表现方面展现了显著的能力 [[25](#bib.bib25)]。一种有前景的使用这些能力的方法是基于LLM的智能体，它们可以自主规划和执行动作以实现目标。基本思想是用一个包含世界当前状态、要实现的目标以及下一步可以执行的动作集的提示来查询LLM。然后，模型决定执行哪个动作，并将执行动作的反馈集成到下一个提示中。表示“动作”的一种方式是通过模型可以调用的工具来与世界互动
    [[26](#bib.bib26), [27](#bib.bib27)]。最近的调查提供了关于基于LLM的自主智能体 [[28](#bib.bib28)]
    以及通过API调用工具的LLM智能体 [[29](#bib.bib29)] 的全面概述。这些智能体在软件工程中的潜力目前尚未得到充分探索，本文旨在解决自动化程序修复这一具有挑战性的任务。
- en: III Approach
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: III 方法
- en: III-A Overview
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: III-A 概述
- en: '![Refer to caption](img/01470337f6802b2b9bfba00691c49dd8.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![参考说明](img/01470337f6802b2b9bfba00691c49dd8.png)'
- en: 'Figure 1: Overview of RepairAgent.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '图 1: RepairAgent 概述。'
- en: 'Figure [1](#S3.F1 "Figure 1 ‣ III-A Overview ‣ III Approach ‣ RepairAgent:
    An Autonomous, LLM-Based Agent for Program Repair") gives an overview of the RepairAgent
    approach, which consists of three components: an LLM agent, a set of tools, and
    a middleware that orchestrates the communication between the two. Given a bug
    to fix, the middleware initializes the LLM agent with a prompt that contains task
    information and instructions on how to perform it by using the provided tools.
    The LLM responds by suggesting a call to one of the available tools, which the
    middleware parses and then executes. The output of the tool is then integrated
    into the prompt for the next invocation of the LLM, and the process continues
    iteratively until the bug is fixed or a predefined budget is exhausted.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '图 [1](#S3.F1 "图 1 ‣ III-A 概述 ‣ III 方法 ‣ RepairAgent: 基于LLM的自主智能体用于程序修复") 给出了
    RepairAgent 方法的概述，包括三个组件：LLM智能体、一组工具和一个协调两者之间通信的中间件。在给定一个需要修复的 bug 时，中间件用包含任务信息和如何使用提供工具的说明的提示来初始化LLM智能体。LLM
    通过建议调用一个可用的工具来响应，中间件解析并执行该调用。工具的输出被集成到下一个LLM调用的提示中，并且这一过程迭代进行，直到 bug 被修复或预定义预算耗尽。'
- en: III-B Terminology
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: III-B 术语
- en: 'RepairAgent proceeds in multiple iterations, which we call cycles:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: RepairAgent 通过多个迭代进行操作，我们称之为周期：
- en: Definition 1  (Cycle).
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 定义 1（周期）。
- en: 'A *cycle* represents one round of interaction with the LLM agent, which consists
    of the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*周期* 表示与LLM智能体的一个交互回合，包括以下步骤：'
- en: '1.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Query the agent
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询智能体
- en: '2.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Post-process the response
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后处理响应
- en: '3.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Execute the command suggested by the agent
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行智能体建议的命令
- en: '4.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Update the dynamic prompt based on the command’s output
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据命令的输出更新动态提示
- en: 'In each cycle, the approach queries the LLM once. The input to the model is
    updated based on commands (calls to tools) invoked by the LLM, and their results,
    in previous cycles. We call the model input a dynamic prompt:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个周期中，该方法查询LLM一次。模型的输入基于LLM在先前周期中调用的命令（工具调用）及其结果进行更新。我们称模型输入为动态提示：
- en: Definition 2  (Dynamic prompt).
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 定义 2（动态提示）。
- en: 'The *dynamic prompt* is a sequence of text sections $P=[s_{0},s_{1},...,s_{n}]$):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态提示* 是一个文本段落的序列 $P=[s_{0},s_{1},...,s_{n}]$：'
- en: •
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: A *static section*, which remains the same across all cycles, i.e., $s_{i}(c)=s_{i}(c^{\prime})$.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*静态部分*，在所有周期中保持不变，即 $s_{i}(c)=s_{i}(c^{\prime})$。'
- en: •
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: A *dynamic section*, which may differ across cycles, i.e., there may exist $c,c^{\prime}$.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*动态部分*，可能在周期之间有所不同，即可能存在 $c,c^{\prime}$。'
- en: III-C Dynamic Prompting of the Repair Agent
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: III-C Repair Agent 的动态提示
- en: 'TABLE I: Sections of the dynamically updated prompt.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表 I：动态更新提示的部分。
- en: '|         Prompt section |         Nature |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|         提示部分 |         性质 |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|         Role |         Static |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|         角色 |         静态 |'
- en: '|         Goals |         Static |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|         目标 |         静态 |'
- en: '|         Guidelines |         Static |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|         指南 |         静态 |'
- en: '|         State description |         Dynamic |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|         状态描述 |         动态 |'
- en: '|         Available tools |         Dynamic |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|         可用工具 |         动态 |'
- en: '|         Gathered information |         Dynamic |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|         收集到的信息 |         动态 |'
- en: '|         Specification of output format |         Static |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|         输出格式规范 |         静态 |'
- en: '|         Last executed command and result |         Dynamic |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|         最后执行的命令和结果 |         动态 |'
- en: 'The repair agent is an LLM trained on natural language and source code, such
    as GPT-3.5. RepairAgent queries the LLM with a dynamic prompt that consists of
    a sequence of static and dynamic sections, as listed in Table [I](#S3.T1 "TABLE
    I ‣ III-C Dynamic Prompting of the Repair Agent ‣ III Approach ‣ RepairAgent:
    An Autonomous, LLM-Based Agent for Program Repair"). We describe each section
    in detail in the following.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '修复代理是一个训练有素的 LLM，像 GPT-3.5 这样的自然语言和源代码。RepairAgent 使用一个动态提示对 LLM 进行查询，该提示由一系列静态和动态部分组成，如表 [I](#S3.T1
    "TABLE I ‣ III-C Dynamic Prompting of the Repair Agent ‣ III Approach ‣ RepairAgent:
    An Autonomous, LLM-Based Agent for Program Repair") 中所列。我们在以下部分详细描述了每个部分。'
- en: III-C1 Role
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-C1 角色
- en: 'This section of the prompt defines the agent’s area of expertise, which is
    to resolve bugs in Java code, and outlines the agent’s primary objective: understanding
    and fixing bugs. The prompt emphasizes that the agent’s decision-making process
    is autonomous and should not rely on user assistance.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分定义了代理的专业领域，即解决 Java 代码中的错误，并概述了代理的主要目标：理解和修复错误。提示强调代理的决策过程是自主的，不应依赖用户的协助。
- en: III-C2 Goals
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-C2 目标
- en: 'We define five goals for the agent to pursue, which remain the same across
    all cycles:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了五个目标供代理执行，这些目标在所有周期中保持不变：
- en: •
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Locate the bug:* Execute tests and use fault localization techniques to pinpoint
    the bug’s location. Skip this goal when fault localization information is already
    provided in the prompt.'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*定位错误：* 执行测试并使用故障定位技术确定错误的位置。如果提示中已经提供了故障定位信息，则跳过此目标。'
- en: •
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Gather information about the bug:* Analyze the lines of code associated with
    the bug to understand the bug.'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*收集有关错误的信息：* 分析与错误相关的代码行，以了解错误。'
- en: •
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Suggest simple fixes to the bug:* Start by suggesting simple fixes.'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*建议简单的错误修复方案：* 首先建议简单的修复方案。'
- en: •
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Suggest complex fixes:* If simple fixes prove ineffective, explore and propose
    more complex ones.'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*建议复杂的修复方案：* 如果简单的修复无效，请探索并提出更复杂的方案。'
- en: •
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Iterate over the previous goals:* Continue to gather information and to suggest
    fixes until finding a fix.'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*迭代之前的目标：* 继续收集信息并建议修复，直到找到一个修复方案。'
- en: III-C3 Guidelines
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-C3 指南
- en: We provide a set of guidelines. First, we inform the model that there are diverse
    kinds of bugs, ranging from single-line issues to multi-line bugs that may entail
    changing, removing, or adding lines. Based on the observation that many bugs can
    be fixed by relatively simple, recurring fix patterns [[30](#bib.bib30)], we provide
    a list of recurring fix patterns. The list is based on the patterns described
    in prior work on single-statement bugs in Java [[30](#bib.bib30)]. For each pattern,
    we provide a short natural language description and an example of buggy and fixed
    code. Second, we instruct the model to insert comments above the modified code,
    which serves two purposes. On the one hand, the comments allow the model to explain
    its reasoning, which has been shown to enhance the reasoning abilities of LLMs [[31](#bib.bib31)].
    On the other hand, commenting will ultimately help human developers in understanding
    the nature of the edits. Third, we instruct the model to conclude its reasoning
    with a clearly defined next step that can be translated into a call to a tool.
    Finally, we describe that there is a limited budget of tool invocations, highlighting
    the importance of efficiency in selecting the next steps. Specifically, we specify
    a maximum number of cycles (40 by default).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一套指南。首先，我们告知模型存在多种类型的 bug，从单行问题到可能涉及更改、删除或添加行的多行 bug。基于观察到许多 bug 可以通过相对简单的、重复出现的修复模式来修复
    [[30](#bib.bib30)]，我们提供了一份重复出现的修复模式列表。该列表基于先前关于 Java 中单语句 bug 的模式描述 [[30](#bib.bib30)]。对于每种模式，我们提供了简短的自然语言描述和一个
    bug 代码及其修复后的示例。其次，我们指示模型在修改后的代码上方插入注释，这有两个目的。一方面，这些注释允许模型解释其推理过程，这已被证明能增强 LLM
    的推理能力 [[31](#bib.bib31)]。另一方面，注释最终将帮助人类开发者理解编辑的性质。第三，我们指示模型以明确的下一步结论结束其推理，这可以转换为对工具的调用。最后，我们描述了工具调用的有限预算，强调了选择下一步的效率的重要性。具体来说，我们指定了最大循环次数（默认
    40 次）。
- en: III-C4 State Description
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-C4 状态描述
- en: '![Refer to caption](img/b8fa1899969d17c1a1712c19f478de94.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/b8fa1899969d17c1a1712c19f478de94.png)'
- en: 'Figure 2: State machine to guide selection of tools.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：用于指导工具选择的状态机。
- en: 'To guide the LLM agent toward using the available tools in an effective and
    meaningful way, we define a finite state machine that constrains which tools are
    available at a given point in time. The motivation is that we observed the LLM
    agent to frequently get lost in aimless exploration in earlier experiments without
    such guidance. Figure [2](#S3.F2 "Figure 2 ‣ III-C4 State Description ‣ III-C
    Dynamic Prompting of the Repair Agent ‣ III Approach ‣ RepairAgent: An Autonomous,
    LLM-Based Agent for Program Repair") shows the finite state machine, which we
    design to mimic the states a human developer would go through when fixing a bug.
    Each state is associated with a set of tools available to the agent, which are
    described in Section [III-D](#S3.SS4 "III-D Tools for the Agent to Use ‣ III Approach
    ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair"). Importantly,
    the agent is free to transition between states at any point in time by using tools.
    That is, despite providing guidance, the state machine does not enforce a strict
    order of tool invocations.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引导 LLM 代理有效且有意义地使用可用工具，我们定义了一个有限状态机，该状态机限制了在给定时间点可用的工具。我们的动机是观察到 LLM 代理在没有这种指导的早期实验中经常迷失在无目的的探索中。图
    [2](#S3.F2 "图 2 ‣ III-C4 状态描述 ‣ III-C 动态提示修复代理 ‣ III 方法 ‣ RepairAgent：一个基于 LLM
    的自动化程序修复代理") 显示了有限状态机，我们设计它来模拟人类开发者在修复 bug 时所经历的状态。每个状态都与一组可供代理使用的工具相关联，这些工具在
    [III-D](#S3.SS4 "III-D 供代理使用的工具 ‣ III 方法 ‣ RepairAgent：一个基于 LLM 的自动化程序修复代理") 部分中进行了描述。重要的是，代理可以在任何时间点通过使用工具在状态之间自由转换。也就是说，尽管提供了指导，状态机并不强制执行工具调用的严格顺序。
- en: 'The state description section of the prompt informs the agent about its current
    state:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 提示中的状态描述部分告知代理其当前状态：
- en: •
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Understand the bug*: The agent starts in this state, where it can collect
    information related to the failing test cases and the bug’s location. Once the
    agent has an understanding of the bug, it formulates a hypothesis to describe
    the nature of the bug and the reason behind it. Throughout the repair process,
    the agent may refute earlier hypotheses and express new ones. After expressing
    a hypothesis, the agent will automatically switch to the next state.'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*了解错误*：代理在此状态下开始，可以收集与失败测试用例和错误位置相关的信息。一旦代理对错误有了理解，它会形成一个假设来描述错误的性质及其原因。在修复过程中，代理可能会驳斥早期的假设并提出新的假设。在表达假设后，代理将自动切换到下一个状态。'
- en: •
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Collect information to fix the bug*: In this state the agent collects information
    that help suggest a fix for the bug expressed by the hypothesis, e.g., by searching
    for specific repair ingredients or by reading possibly relevant code. Once the
    agent has gathered enough information to attempt a fix, it can transition to the
    next state.'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*收集修复错误的信息*：在此状态下，代理收集帮助建议修复假设所表达错误的信息，例如，通过搜索特定的修复材料或阅读可能相关的代码。一旦代理收集到足够的信息以尝试修复，它可以过渡到下一个状态。'
- en: •
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Try to fix the bug*: In this state, the agent tries to fix the bug based on
    its current hypothesis and the collected information. Each fix attempt modifies
    the code base and is validated by executing the test cases. If necessarily, the
    agent can go back to one of the previous states to establish a new hypothesis
    or to gather additional information.'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*尝试修复错误*：在此状态下，代理基于当前假设和收集的信息尝试修复错误。每次修复尝试都会修改代码库，并通过执行测试用例进行验证。如有必要，代理可以回到之前的某个状态以建立新的假设或收集更多信息。'
- en: In addition to the three above states, RepairAgent has a final state, *“Done”*,
    which the agent can reach by calling a specific command that indicates the success
    of repair.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述三种状态外，RepairAgent 还有一个最终状态，*“Done”*，代理可以通过调用一个特定的命令来达到该状态，这个命令表示修复成功。
- en: III-C5 Available Tools
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-C5 可用工具
- en: 'This section of the prompt describes a set of tools that the agent can call
    at the current state. Each tool has a name, a description, and a set of typed
    arguments (Section [III-D](#S3.SS4 "III-D Tools for the Agent to Use ‣ III Approach
    ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair")).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '该提示部分描述了代理在当前状态下可以调用的一组工具。每个工具都有一个名称、描述和一组类型化的参数（第 [III-D](#S3.SS4 "III-D Tools
    for the Agent to Use ‣ III Approach ‣ RepairAgent: An Autonomous, LLM-Based Agent
    for Program Repair") 节）。'
- en: III-C6 Gathered Information
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-C6 收集的信息
- en: A key ability of the repair agent is to gather information about the bug and
    the code base, which serves as the basis for deciding which commands to invoke
    next. To make this information available to the agent, we maintain a prompt section
    that lists the information gathered by the different tool invocations. Intuitively,
    this section of the prompt serves as a memory for the agent, allowing it to recall
    information from previous cycles. The gathered information is structured into
    different subsections, where each subsection contains the outputs produced by
    a specific tool.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 修复代理的一个关键能力是收集有关错误和代码库的信息，这些信息作为决定下一步调用哪些命令的基础。为了使这些信息对代理可用，我们维护一个提示部分，列出了由不同工具调用收集的信息。直观地说，这部分提示作为代理的记忆，使其能够回忆之前周期中的信息。收集到的信息被结构化为不同的子部分，每个子部分包含由特定工具生成的输出。
- en: III-C7 Specification of Output Format
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-C7 输出格式规范
- en: 'interface  Response  {thoughts:  string;command:  {name:  string;args:  Record;};}'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'interface  Response  {thoughts:  string;command:  {name:  string;args:  Record;};}'
- en: 'Figure 3: JSON format of the response of the model.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3：模型响应的 JSON 格式。
- en: 'Given the dynamic prompt, the LLM agent provides one response per cycle. To
    enable the middleware to parse the response, we specify the expected output format
    (Figure [3](#S3.F3 "Figure 3 ‣ III-C7 Specification of Output Format ‣ III-C Dynamic
    Prompting of the Repair Agent ‣ III Approach ‣ RepairAgent: An Autonomous, LLM-Based
    Agent for Program Repair")). The “thoughts” field provides a textual description
    of the agent’s reasoning when deciding about the next command. Asking the agent
    to express its thoughts increases the transparency and interpretability of the
    approach, provides a way to debug potential issues in the agent’s decision-making
    process, and helps improve the reasoning abilities of LLMs [[31](#bib.bib31)].
    The “command” field specifies the next command to be executed, consisting of the
    name of the tool to invoke and the set of arguments.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '根据动态提示，LLM代理每次周期提供一个响应。为了使中间件能够解析响应，我们指定了预期的输出格式（图 [3](#S3.F3 "Figure 3 ‣ III-C7
    Specification of Output Format ‣ III-C Dynamic Prompting of the Repair Agent ‣
    III Approach ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair")）。“thoughts”字段提供了代理在决定下一个命令时的推理文本描述。要求代理表达其思维过程可以增加方法的透明度和可解释性，提供调试代理决策过程中潜在问题的方法，并有助于提高LLM的推理能力 [[31](#bib.bib31)]。“command”字段指定要执行的下一个命令，包括要调用的工具名称和一组参数。'
- en: '{"thoughts":  "With  the  hypothesis  in  mind,it’s  time  to  gather  more  information  toformulate  potential  fixes  for  the  bug.  Ishould  focus  on  understanding  the  contextaround  the  condition’if  (x  <  0  &&  prev  ==  ’-’)’to  come  up  with  effective  solutions.","command":  {"name":  "search_code_base","args":  {"key_words":[  "addNumber","CodeConsumer","if  (x  <  0  &&  prev  ==  ’-’)"  ]}}}'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '{"thoughts":  "考虑到假设，现在是收集更多信息以制定潜在修复方案的时候了。我应该专注于理解条件 ‘if (x < 0 && prev ==
    ’-’)’ 的上下文，以提出有效的解决方案。","command":  {"name":  "search_code_base","args":  {"key_words":[  "addNumber","CodeConsumer","if  (x  <  0  &&  prev  ==  ’-’)"  ]}}}'
- en: 'Figure 4: Example of a response of the repair agent.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4: 修复代理的响应示例。'
- en: 'For example, Figure [4](#S3.F4 "Figure 4 ‣ III-C7 Specification of Output Format
    ‣ III-C Dynamic Prompting of the Repair Agent ‣ III Approach ‣ RepairAgent: An
    Autonomous, LLM-Based Agent for Program Repair") shows a response of the LLM agent.
    The model expresses the need to collect more information to understand the bug.
    It then suggests a command that searches the code base with a list of keywords.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，图 [4](#S3.F4 "Figure 4 ‣ III-C7 Specification of Output Format ‣ III-C Dynamic
    Prompting of the Repair Agent ‣ III Approach ‣ RepairAgent: An Autonomous, LLM-Based
    Agent for Program Repair") 显示了LLM代理的一个响应。模型表达了需要收集更多信息以理解错误。然后，它建议一个命令，用关键字列表在代码库中进行搜索。'
- en: III-C8 Last Executed Command and Result
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-C8 上次执行的命令和结果
- en: This section of the prompt contains the last command (tool name and arguments)
    that was executed (if any) and the output it produced. The rationale is to remind
    the agent of the last step it took, and to make it aware of any problems that
    occurred during the execution of the command. Furthermore, we remind the agent
    how many cycles have already been executed, and how many cycles are left
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 提示的这一部分包含了上一个执行的命令（工具名称和参数）及其产生的输出。这样做的理由是提醒代理它上一步的操作，并让它了解在执行命令过程中发生的任何问题。此外，我们还提醒代理已经执行了多少个周期，还有多少个周期剩余。
- en: III-D Tools for the Agent to Use
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: III-D 代理使用的工具
- en: 'A key novelty in our approach is to let an LLM agent autonomously decide which
    tools to invoke to fix a bug. The tools we provide to the agent (Table [II](#S3.T2
    "TABLE II ‣ III-D Tools for the Agent to Use ‣ III Approach ‣ RepairAgent: An
    Autonomous, LLM-Based Agent for Program Repair")) are inspired by the tools that
    developers use in their IDEs.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '我们方法的一个关键创新是让LLM代理自主决定调用哪些工具来修复错误。我们提供给代理的工具（表 [II](#S3.T2 "TABLE II ‣ III-D
    Tools for the Agent to Use ‣ III Approach ‣ RepairAgent: An Autonomous, LLM-Based
    Agent for Program Repair")）受到开发人员在其IDE中使用的工具的启发。'
- en: 'TABLE II: Repair-related tools invoked by RepairAgent.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '表 II: RepairAgent 调用的修复相关工具。'
- en: '| Tool | Description |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 描述 |'
- en: '| --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Read and extract code: |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 阅读并提取代码: |'
- en: '| *read_range* | Read a range of lines in a file. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| *read_range* | 读取文件中的一段行。 |'
- en: '| *get_classes_and_methods* | Get the names of all classes and methods in a
    file. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| *get_classes_and_methods* | 获取文件中所有类和方法的名称。 |'
- en: '| *extract_method* | Given a method name, extract method implementations from
    a file. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| *extract_method* | 给定一个方法名称，从文件中提取方法实现。 |'
- en: '| *extract_tests* | Given the failure report from JUnit or ANT, extract the
    code of failing test cases. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| *extract_tests* | 给定来自JUnit或ANT的失败报告，提取失败测试用例的代码。 |'
- en: '| Search and generate code: |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 搜索和生成代码： |'
- en: '| *search_code_base* | Scans all Java files within a project for a list of
    keywords. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| *搜索代码库* | 扫描项目中的所有 Java 文件以查找关键字列表。 |'
- en: '| *find_similar_api _calls* | Given a code snippet that calls an API, search
    for similar API calls in the project. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| *查找相似的 API 调用* | 给定一个调用 API 的代码片段，在项目中搜索类似的 API 调用。 |'
- en: '| *generate_method_body* | Ask an LLM (GPT3.5 by default) to generate the body
    of a method based on code proceeding the method. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| *生成方法体* | 请求一个 LLM（默认使用 GPT3.5）根据方法前面的代码生成方法体。 |'
- en: '| Testing and patching: |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 测试和修补： |'
- en: '| *run_tests* | Run the test suite of a project. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| *运行测试* | 运行项目的测试套件。 |'
- en: '| *run_fault_localization* | Retrieve pre-existing localization information
    or run a fault localization tool. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| *运行故障定位* | 检索预先存在的定位信息或运行故障定位工具。 |'
- en: '| *write_fix* | Apply a patch to the code base and execute the test suite of
    the project. Changes are reverted automatically if tests fail. Moves the agent
    into the ’Try to fix the bug’ state. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| *编写修复* | 将补丁应用于代码库，并执行项目的测试套件。如果测试失败，修改将自动撤销。将代理移动到‘尝试修复错误’状态。 |'
- en: '| Control: |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 控制： |'
- en: '| *express_hypothesis* | Express a hypothesis about the bug. Moves the agent
    into the ’Collect information to fix the bug’ state. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| *表达假设* | 表达关于错误的假设。将代理移动到‘收集信息以修复错误’状态。 |'
- en: '| *collect_more_information* | Move the agent back to the ’Collect information
    to fix the bug’ state. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| *收集更多信息* | 将代理返回到‘收集信息以修复错误’状态。 |'
- en: '| *discard_hypothesis* | Discard the current hypothesis about the bug and move
    back to the ’Understand the bug’ state. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| *丢弃假设* | 丢弃当前关于错误的假设，并返回到‘理解错误’状态。 |'
- en: '| *goal_accomplished* | Declare that the goal has been accomplished and exiting
    the repair process. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| *目标已达成* | 宣布目标已经完成并退出修复过程。 |'
- en: III-D1 Reading and Extracting Code
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-D1 读取和提取代码
- en: A prerequisite for fixing a bug is to read and understand relevant parts of
    the code base. Instead of hard-coding the context provided to the LLM [[19](#bib.bib19),
    [20](#bib.bib20), [21](#bib.bib21)], we let the agent decide which parts of the
    code to read, based on four tools. The *read_range* tool allows the agent to extract
    a range of lines from a specific file, which is useful to obtain a focused view
    of a particular section of code. To obtain an overview of the code structure,
    the *get_classes_and_methods* tool retrieves all class and method names within
    a given file. By invoking the *extract_method* tool, the agent can retrieve the
    implementation(s) of methods that match a given method name within a given file.
    Finally, we offer the *extract_tests* tool, which extracts the code of test cases
    that resulted in failure. The tool is crucial to understand details of failing
    tests, such as input values and the expected output.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 修复错误的先决条件是阅读和理解代码库的相关部分。我们不将上下文硬编码到 LLM 中[[19](#bib.bib19), [20](#bib.bib20),
    [21](#bib.bib21)]，而是让代理根据四个工具决定阅读代码的哪些部分。*读取范围*工具允许代理从特定文件中提取一系列行，这对于获取特定代码段的聚焦视图非常有用。为了获取代码结构的概述，*获取类和方法*工具检索给定文件中的所有类和方法名称。通过调用*提取方法*工具，代理可以检索与给定方法名称匹配的给定文件中的方法实现。最后，我们提供*提取测试*工具，提取导致失败的测试用例的代码。该工具对于了解失败测试的细节（如输入值和预期输出）至关重要。
- en: III-D2 Search and generate code
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-D2 搜索和生成代码
- en: Motivated by the fact that human developers commonly search for code [[32](#bib.bib32)],
    we present tools that allow the agent to search for specific code snippets. These
    tools are useful for the agent to better understand the context of a bug and to
    gather repair ingredients, i.e., code fragments that could become part of a fix.
    The *search_code_base* tool enables the agent to locate instances of particular
    keywords within the entire code base. For example, the agent can use this tool
    to find occurrences of variables, methods, and classes. Given a set of keywords,
    the tool performs an approximate matching against all source code files in the
    project. Specifically, the tool splits each keyword into subtokens based on camel
    case, underscores, and periods, and then searches for each subtoken in the code.
    For example, searching for quickSortArray yields matches for sortArray, quickSort,
    arrayQuickSort, and other related variations. The output of the tool is a nested
    dictionary, organized by file names, classes, and method names, that provides
    the keywords that match a method’s content. Another search tool, *find_similar_api_calls*,
    allows the agent to identify and extract usages of a method, which is useful to
    fix incorrect method calls. Without such a tool, LLMs tend to hallucinate method
    calls that do not exist in the code base [[33](#bib.bib33)]. Given a code snippet
    that contains a method call, the tool extracts the name of the called method,
    and then searches for calls to methods with the same name. The agent can restrict
    the search to a specific file or search the entire code base.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 受人类开发者常常搜索代码的启发[[32](#bib.bib32)]，我们提供了一些工具，使代理能够搜索特定的代码片段。这些工具对于代理更好地理解错误的上下文以及收集修复所需的元素（即可能成为修复部分的代码片段）非常有用。*search_code_base*
    工具使代理能够在整个代码库中定位特定关键字的实例。例如，代理可以使用此工具查找变量、方法和类的出现情况。给定一组关键字，该工具会在项目中的所有源代码文件中执行近似匹配。具体来说，该工具根据驼峰命名法、下划线和句点将每个关键字拆分成子令牌，然后在代码中搜索每个子令牌。例如，搜索
    quickSortArray 会匹配到 sortArray、quickSort、arrayQuickSort 和其他相关变体。该工具的输出是一个嵌套字典，按文件名、类和方法名组织，提供与方法内容匹配的关键字。另一个搜索工具
    *find_similar_api_calls* 允许代理识别并提取方法的使用情况，这对于修复不正确的方法调用非常有用。如果没有这样的工具，LLM 往往会幻想出在代码库中不存在的方法调用[[33](#bib.bib33)]。给定包含方法调用的代码片段，该工具提取被调用方法的名称，然后搜索同名方法的调用。代理可以将搜索限制在特定文件中，或在整个代码库中进行搜索。
- en: In addition to searching for existing code, RepairAgent offers a tool that generates
    new code by invoking another LLM. The tool is inspired by the success of LLM-based
    code completion tools, such as Copilot [[34](#bib.bib34)], which human developers
    increasingly use when fixing bugs. Given the code preceding a method and the signature
    of the method, the *generate_method_body* tool asks an LLM to generate the body
    of the method. The query to the code-generating LLM is independent of the dynamic
    prompt used by the overall RepairAgent approach, and may use a different model.
    In our evaluation, we use the same LLM for both the repair agent and as the code-generating
    LLM of this tool. The tool limits the given code context to 12k tokens and sets
    a limit of 4k tokens for the generated code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了搜索现有代码外，RepairAgent 提供了一种通过调用另一个 LLM 生成新代码的工具。该工具受到了 LLM 基础代码补全工具（如 Copilot）成功的启发[[34](#bib.bib34)]，这些工具在人类开发者修复错误时被越来越多地使用。给定方法前的代码和方法的签名，*generate_method_body*
    工具要求一个 LLM 生成该方法的主体。对生成代码的 LLM 的查询独立于 RepairAgent 方法中使用的动态提示，并且可能使用不同的模型。在我们的评估中，我们为修复代理和此工具的代码生成
    LLM 使用了相同的 LLM。该工具将给定的代码上下文限制为 12k 个令牌，并将生成的代码限制为 4k 个令牌。
- en: III-D3 Testing and Patching
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-D3 测试和修补
- en: 'The next category of tools is related to running tests and applying patches.
    The *run_tests* tool allows the agent to execute the test suite of the project.
    It produces a report that indicates whether the tests passed or failed. In case
    of test failures, the tool cleans the output of the test runner, e.g., by removing
    entries of the stack trace that are outside of the current project. The rationale
    is that LLMs have a limited prompt size and that irrelevant information may confuse
    the model. The *run_fault_localization* tool retrieves fault localization information,
    which is useful to understand which parts of the code are likely to contain the
    bug. RepairAgent offers two variants of this tool: Either, it provides perfect
    fault localization information, i.e., the file(s) and line(s) that need to be
    edited to fix the bug, or it invokes an existing fault localization tool, such
    as GZoltar [[35](#bib.bib35)], to calculate fault localization scores. As common
    in the field of program repair, we assume perfect fault localization as the default.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类别的工具与运行测试和应用补丁有关。*run_tests* 工具允许代理执行项目的测试套件。它生成一份报告，指示测试是否通过。如果测试失败，该工具会清理测试运行器的输出，例如，移除当前项目之外的堆栈跟踪条目。其理由是
    LLM 具有有限的提示大小，相关信息可能会使模型混淆。*run_fault_localization* 工具检索故障定位信息，这对理解代码中可能包含错误的部分很有帮助。RepairAgent
    提供了该工具的两种变体：一种是提供完美的故障定位信息，即需要编辑的文件和行，另一种是调用现有的故障定位工具，如 GZoltar [[35](#bib.bib35)]，以计算故障定位分数。像在程序修复领域常见的那样，我们假设完美的故障定位作为默认值。
- en: '[{"file_path":  "jfree/data/time/Week.java","insertions":  [{"line_number":  175,"new_lines":  ["//  ...new  lines  to  insert...\n","//  ...more  new  lines...\n"]}],"deletions":  [179,  183],"modifications":  [{"line_number":  179,"modified_line":  "  if  (dataset  ==  null)  {\n"}]},{"file_path":  "org/jfree/data/time/Day.java","insertions":  [],"deletions":  [307],"modifications":  []}'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[{"file_path":  "jfree/data/time/Week.java","insertions":  [{"line_number":  175,"new_lines":  ["//  ...待插入的新行...\n","//  ...更多待插入的新行...\n"]}],"deletions":  [179,  183],"modifications":  [{"line_number":  179,"modified_line":  "  if  (dataset  ==  null)  {\n"}]},{"file_path":  "org/jfree/data/time/Day.java","insertions":  [],"deletions":  [307],"modifications":  []}'
- en: 'Figure 5: Example of patch given to the *write_fix* tool.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5：给 *write_fix* 工具的补丁示例。
- en: 'Once the agent has gathered sufficient information to fix the bug, it can apply
    a patch to the code base using the *write_fix* tool. RepairAgent aims at repairing
    arbitrarily complex bugs, including multi-line and even multi-file bugs. The *write_fix*
    tool expects a patch in a specific JSON format, which indicates the insertions,
    deletions, and modifications to be made in each file. Figure [5](#S3.F5 "Figure
    5 ‣ III-D3 Testing and Patching ‣ III-D Tools for the Agent to Use ‣ III Approach
    ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair") shows an example
    of a patch in this format. Given a patch, the tool applies the changes to the
    code base and runs the test suite. If the tests fail, the *write_fix* reverts
    the changes, giving the agent a clean code base to try another fix. Motivated
    by the observation that some fix attempts are almost correct, the *write_fix*
    tool requests the LLM to sample multiple variants of the suggested fix. By default,
    RepairAgent samples 30 variants at max. Given the generated variants, the approach
    removes duplicates and launch tests for every variant.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦代理收集到足够的信息以修复错误，它可以使用 *write_fix* 工具将补丁应用到代码库中。RepairAgent 旨在修复任意复杂的错误，包括多行甚至多文件的错误。*write_fix*
    工具期望补丁采用特定的 JSON 格式，这种格式指示了每个文件中需要进行的插入、删除和修改。图 [5](#S3.F5 "Figure 5 ‣ III-D3
    Testing and Patching ‣ III-D Tools for the Agent to Use ‣ III Approach ‣ RepairAgent:
    An Autonomous, LLM-Based Agent for Program Repair") 显示了这种格式的补丁示例。给定补丁后，工具将更改应用到代码库中并运行测试套件。如果测试失败，*write_fix*
    会还原更改，为代理提供一个干净的代码库以尝试其他修复。由于观察到一些修复尝试几乎正确，*write_fix* 工具会请求 LLM 生成多个建议修复的变体。默认情况下，RepairAgent
    最多生成 30 个变体。根据生成的变体，该方法会去除重复项并对每个变体进行测试。'
- en: III-D4 Control
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-D4 控制
- en: 'The final set of tools do not directly correspond to a tool a human developer
    may use, but rather allow the agent to move between states (Figure [2](#S3.F2
    "Figure 2 ‣ III-C4 State Description ‣ III-C Dynamic Prompting of the Repair Agent
    ‣ III Approach ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair")).
    The *express_hypothesis* tool empowers the agent to articulate a hypothesis regarding
    the nature of the bug and to transition to the ’Collect information to fix the
    bug’ state. Inversely, the *discard_hypothesis* tool allows the agent to discard
    a hypothesis that is no longer viable, which leads back to the ’Understand the
    bug’ state. Together, the two commands enforce a structured approach to hypothesis
    formulation, aligning with work on scientific debugging [[36](#bib.bib36), [20](#bib.bib20)].
    In case the agent has tried multiple fixes without success, the *collect_more_information*
    tool allows the agent to revert to the ’Collect information to fix the bug’ state.
    Finally, once the agent has found at least one fix that passes all tests, it can
    invoke the *goal_accomplished* tool, which terminates RepairAgent.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '最终的一组工具并不直接对应人类开发者可能使用的工具，而是允许智能体在状态之间移动（图[2](#S3.F2 "Figure 2 ‣ III-C4 State
    Description ‣ III-C Dynamic Prompting of the Repair Agent ‣ III Approach ‣ RepairAgent:
    An Autonomous, LLM-Based Agent for Program Repair")）。*express_hypothesis* 工具使智能体能够阐述关于错误性质的假设，并转到“收集信息以修复错误”状态。相反，*discard_hypothesis*
    工具允许智能体丢弃不再可行的假设，从而返回到“理解错误”状态。这两个命令共同推动了假设制定的结构化方法，与科学调试的研究相一致[[36](#bib.bib36),
    [20](#bib.bib20)]。如果智能体尝试了多次修复都未成功，*collect_more_information* 工具允许智能体回到“收集信息以修复错误”状态。最后，一旦智能体找到至少一个通过所有测试的修复，它可以调用*goal_accomplished*
    工具，终止 RepairAgent。'
- en: III-E Middleware
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: III-E 中间件
- en: 'The middleware component plays a crucial role in RepairAgent, orchestrating
    the communication between the LLM agent and the tools. It performs the steps in
    Definition [1](#Thmdefinition1 "Definition 1 (Cycle). ‣ III-B Terminology ‣ III
    Approach ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair") as
    described in the following.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '中间件组件在 RepairAgent 中发挥着至关重要的作用，协调 LLM 智能体和工具之间的通信。它按照下述步骤执行定义[1](#Thmdefinition1
    "Definition 1 (Cycle). ‣ III-B Terminology ‣ III Approach ‣ RepairAgent: An Autonomous,
    LLM-Based Agent for Program Repair")中的步骤。'
- en: III-E1 Parsing and Refining LLM Output
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-E1 解析和完善 LLM 输出
- en: 'At the beginning of each cycle, the middleware queries the LLM with the current
    prompt. Ideally, the response adheres perfectly to the expected format (Figure [3](#S3.F3
    "Figure 3 ‣ III-C7 Specification of Output Format ‣ III-C Dynamic Prompting of
    the Repair Agent ‣ III Approach ‣ RepairAgent: An Autonomous, LLM-Based Agent
    for Program Repair")). In practice, however, the LLM may produce responses that
    deviate from the expected format, e.g., due to hallucinations or syntactic errors.
    For example, the LLM may provide a “path” argument while the tool expects a “file_path”
    argument.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '在每个周期开始时，中间件用当前提示查询 LLM。理想情况下，响应完全符合预期格式（图[3](#S3.F3 "Figure 3 ‣ III-C7 Specification
    of Output Format ‣ III-C Dynamic Prompting of the Repair Agent ‣ III Approach
    ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair")）。然而，实际上，LLM
    可能会产生偏离预期格式的响应，例如，由于幻觉或语法错误。例如，LLM 可能提供“path”参数，而工具期望的是“file_path”参数。'
- en: RepairAgent tries to heuristically rectify such issues by mapping the output
    to the expected format in three steps. First, it tries to map the tool mentioned
    in the response to one of the available tools. Specifically, the approach checks
    if the predicted tool name $n_{\mathit{predicted}}$ is below a threshold (0.1
    by default). Second, the approach tries to map the argument names provided in
    the response to the expected arguments of the tool, following the same logic as
    above. Third, the approach handles invalid argument values by heuristically mapping
    or replacing them, e.g., by replacing a predicted file path with a valid one.
    If the heuristic mapping fails or produces multiple possible tool invocations,
    the middleware informs the LLM about the issue via the “Last executed command
    and result” prompt section and enters a new cycle.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: RepairAgent 尝试通过三个步骤以启发式方式修正这些问题，将输出映射到预期格式。首先，它尝试将响应中提到的工具映射到可用工具之一。具体来说，该方法检查预测的工具名称
    $n_{\mathit{predicted}}$ 是否低于阈值（默认值为 0.1）。其次，该方法尝试将响应中提供的参数名称映射到工具的预期参数，遵循上述相同的逻辑。第三，该方法通过启发式映射或替换处理无效的参数值，例如，将预测的文件路径替换为有效路径。如果启发式映射失败或产生多个可能的工具调用，中间件通过“最后执行的命令和结果”提示部分通知
    LLM 该问题，并进入新的周期。
- en: In addition to rectifying minor mistakes in the response, the middleware also
    checks for repeated invocations of the same tool with the same arguments. If the
    agent suggests the exact same command as in a previous cycle, which would yield
    the same results, the middleware informs the agent about the repetition and enters
    a new cycle.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了纠正响应中的小错误外，中间件还检查是否有重复调用相同工具且使用相同参数的情况。如果代理建议的命令与之前周期中的命令完全相同，并且将产生相同的结果，中间件会通知代理重复情况，并进入新周期。
- en: III-E2 Calling the Tool
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-E2 调用工具
- en: Once the middleware has received a valid command from the LLM, it calls the
    corresponding tool. To prevent tool executions to interfere with the host environment
    or RepairAgent itself, the middleware executes the command in an isolated environment
    that contains a cloned version of the buggy repository.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦中间件收到来自 LLM 的有效命令，它就调用相应的工具。为了防止工具执行干扰主机环境或 RepairAgent 本身，中间件在包含修复仓库的克隆版本的隔离环境中执行命令。
- en: III-E3 Updating the Prompt
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-E3 更新提示
- en: Given the output of the tool, the middleware updates all dynamic sections of
    the prompt for the next cycle. In particular, the middleware updates the state
    description and the available tools, appends the tool’s output to the gathered
    information, and replaces the section that shows the last executed command.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 根据工具的输出，中间件会更新提示的所有动态部分以进行下一周期。特别是，中间件更新状态描述和可用工具，将工具的输出附加到收集的信息中，并替换显示最后执行命令的部分。
- en: IV Implementation
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IV 实施
- en: We use Python 3.10 as our primary programming language. Docker is used to containerize
    and isolate command executions for enhanced reliability and reproducibility. RepairAgent
    is built on top of the AutoGPT framework and GPT-3.5-0125 from OpenAI. To parse
    and interact with Java code, we use ANTLR.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Python 3.10 作为主要编程语言。Docker 用于容器化和隔离命令执行，以提高可靠性和可重复性。RepairAgent 构建在 AutoGPT
    框架和 OpenAI 的 GPT-3.5-0125 之上。为了解析和处理 Java 代码，我们使用 ANTLR。
- en: V Evaluation
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: V 评估
- en: 'To evaluate our approach we aim to answer the following research questions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估我们的方法，我们旨在回答以下研究问题：
- en: RQ1
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RQ1
- en: How effective is RepairAgent at fixing real-world bugs?
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RepairAgent 在修复实际问题上的效果如何？
- en: RQ2
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RQ2
- en: What are the costs of the approach?
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法的成本是多少？
- en: RQ3
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RQ3
- en: How does the LLM agent use the available tools?
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LLM 代理如何使用现有工具？
- en: V-A Experimental Setup
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: V-A 实验设置
- en: Dataset
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据集
- en: We apply RepairAgent to bugs in the Defects4J dataset [[24](#bib.bib24)]. We
    use the entire Defects4J dataset, which consists of 835 real-world bugs from 17
    Java projects, including 395 bugs from 6 projects in Defects4Jv1.2, as well as
    another 440 bugs and 11 projects added in Defects4Jv2. Evaluating on the entire
    dataset allows us to assess the generalization capabilities of RepairAgent to
    different projects and bugs, without restricting the evaluation, e.g., based on
    the number of lines, hunks, or files that need to be fixed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 RepairAgent 应用于 Defects4J 数据集中的缺陷[[24](#bib.bib24)]。我们使用整个 Defects4J 数据集，该数据集包含来自
    17 个 Java 项目的 835 个实际缺陷，其中包括 Defects4Jv1.2 中 6 个项目的 395 个缺陷，以及 Defects4Jv2 中添加的另
    440 个缺陷和 11 个项目。在整个数据集上进行评估使我们能够评估 RepairAgent 在不同项目和缺陷中的泛化能力，而不限制评估，例如，基于需要修复的行数、补丁块或文件数。
- en: Baselines
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基线
- en: 'We compare with three existing repair techniques: ChatRepair [[19](#bib.bib19)],
    ITER [[21](#bib.bib21)], and SelfAPR [[37](#bib.bib37)]. ChatRepair and ITER are
    two very recent approaches and have been shown to be the current state of the
    art. All three baseline approaches follow an iterative approach that incorporates
    feedback from previous patch attempts. Unlike RepairAgent, the baselines do not
    use an autonomous, LLM-based agent. We compare against the baselines based on
    patches provided by the authors of the respective approaches.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与三种现有的修复技术进行比较：ChatRepair [[19](#bib.bib19)]、ITER [[21](#bib.bib21)] 和 SelfAPR
    [[37](#bib.bib37)]。ChatRepair 和 ITER 是两种非常新的方法，已经被证明是当前的最先进技术。所有这三种基线方法都遵循一种迭代方法，结合了先前补丁尝试的反馈。与
    RepairAgent 不同，这些基线方法没有使用自主的、基于 LLM 的代理。我们根据各自方法的作者提供的补丁与基线进行比较。
- en: Metrics of success
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 成功的指标
- en: Similar to past work, we report both the number of plausible and correct patches.
    A fix is *plausible* if it passes all test cases, but is not necessarily correct.
    To determine whether a fix is correct, we automatically check whether it syntactically
    matches the developer-created fix. If this is not the case, we manually determine
    whether the RepairAgent-generated fix is semantically consistent with the developer-created
    fix. If and only if either of the two checks succeeds, we consider the fix to
    be *correct*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于过去的工作，我们报告了合理和正确修复的数量。如果一个修复通过了所有测试用例，则它是*合理的*，但不一定是正确的。为了确定修复是否正确，我们自动检查它是否在语法上与开发人员创建的修复匹配。如果不是这种情况，我们会手动确定
    RepairAgent 生成的修复是否在语义上与开发人员创建的修复一致。只有当这两个检查中的任意一个成功时，我们才认为修复是*正确的*。
- en: 'V-B RQ1: Effectiveness'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'V-B RQ1: 效果'
- en: V-B1 Overall Results
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: V-B1 总体结果
- en: 'TABLE III: Results on Defects4J.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 表 III：Defects4J 的结果。
- en: '| Project | Bugs | Plausible | Correct | ChatRepair | ITER | SelfAPR |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 项目 | Bugs | 合理的 | 正确的 | ChatRepair | ITER | SelfAPR |'
- en: '| Chart | 26 | 14 | 11 | 15 | 10 | 7 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 图表 | 26 | 14 | 11 | 15 | 10 | 7 |'
- en: '| Cli | 39 | 9 | 8 | 5 | 6 | 8 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| Cli | 39 | 9 | 8 | 5 | 6 | 8 |'
- en: '| Closure | 174 | 27 | 27 | 37 | 18 | 20 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| Closure | 174 | 27 | 27 | 37 | 18 | 20 |'
- en: '| Codec | 18 | 10 | 9 | 8 | 3 | 8 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| Codec | 18 | 10 | 9 | 8 | 3 | 8 |'
- en: '| Collections | 4 | 1 | 1 | 0 | 0 | 1 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| Collections | 4 | 1 | 1 | 0 | 0 | 1 |'
- en: '| Compress | 47 | 10 | 10 | 2 | 4 | 7 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| Compress | 47 | 10 | 10 | 2 | 4 | 7 |'
- en: '| Csv | 16 | 6 | 6 | 3 | 2 | 1 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| Csv | 16 | 6 | 6 | 3 | 2 | 1 |'
- en: '| Gson | 18 | 3 | 3 | 3 | 0 | 1 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| Gson | 18 | 3 | 3 | 3 | 0 | 1 |'
- en: '| JacksonCore | 26 | 5 | 5 | 3 | 3 | 3 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| JacksonCore | 26 | 5 | 5 | 3 | 3 | 3 |'
- en: '| Jacksondatabind | 112 | 18 | 11 | 9 | 0 | 8 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| Jacksondatabind | 112 | 18 | 11 | 9 | 0 | 8 |'
- en: '| JacksonXml | 6 | 1 | 1 | 1 | 0 | 1 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| JacksonXml | 6 | 1 | 1 | 1 | 0 | 1 |'
- en: '| Jsoup | 93 | 18 | 18 | 14 | 0 | 6 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| Jsoup | 93 | 18 | 18 | 14 | 0 | 6 |'
- en: '| JxPath | 22 | 0 | 0 | 0 | 0 | 1 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| JxPath | 22 | 0 | 0 | 0 | 0 | 1 |'
- en: '| Lang | 63 | 17 | 17 | 21 | 0 | 10 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| Lang | 63 | 17 | 17 | 21 | 0 | 10 |'
- en: '| Math | 106 | 29 | 29 | 32 | 0 | 22 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 数学 | 106 | 29 | 29 | 32 | 0 | 22 |'
- en: '| Mockito | 38 | 6 | 6 | 6 | 0 | 3 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| Mockito | 38 | 6 | 6 | 6 | 0 | 3 |'
- en: '| Time | 26 | 3 | 2 | 3 | 2 | 3 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 时间 | 26 | 3 | 2 | 3 | 2 | 3 |'
- en: '| Defects4Jv1.2 | 395 | 96 | 74 | 114 | 57 | 64 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| Defects4Jv1.2 | 395 | 96 | 74 | 114 | 57 | 64 |'
- en: '| Defects4Jv2 | 440 | 90 | 90 | 48 | — | 46 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| Defects4Jv2 | 440 | 90 | 90 | 48 | — | 46 |'
- en: '| Total | 835 | 186 | 164 | 162 | 57 | 110 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 总计 | 835 | 186 | 164 | 162 | 57 | 110 |'
- en: 'TABLE IV: Distribution of fixes by location type'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 表 IV：按位置类型分布的修复
- en: '| Bug type | RepairAgent | ChatRepair | ITER | SelfAPR |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| Bug 类型 | RepairAgent | ChatRepair | ITER | SelfAPR |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Single-line | 115 | 133 | 36 | 83 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 单行 | 115 | 133 | 36 | 83 |'
- en: '| Multi-line* | 46 | 29 | 14 | 24 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 多行* | 46 | 29 | 14 | 24 |'
- en: '| Multi-file | 3 | 0 | 4 | 3 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 多文件 | 3 | 0 | 4 | 3 |'
- en: 'Table [III](#S5.T3 "TABLE III ‣ V-B1 Overall Results ‣ V-B RQ1: Effectiveness
    ‣ V Evaluation ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair")
    summarizes the effectiveness of RepairAgent in fixing the 835 bugs in Defects4J.
    The approach generates plausible fixes for 186 bugs. While not necessarily correct,
    plausible fixes pass all test cases and may still provide developers a hint about
    what should be changed. RepairAgent generates correct fixes for 164 bugs, which
    are semantically consistent with the developer-provided patches. Being able to
    fix bugs from different projects shows that the approach can generalize to code
    bases of multiple domains. Furthermore, RepairAgent creates fixes for bugs of
    different levels of complexity. Specifically, as shown in Table [IV](#S5.T4 "TABLE
    IV ‣ V-B1 Overall Results ‣ V-B RQ1: Effectiveness ‣ V Evaluation ‣ RepairAgent:
    An Autonomous, LLM-Based Agent for Program Repair"), the approach fixes 115 single-line
    bugs, 46 multi-line (single-file) bugs, and 3 multi-file bugs.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '表 [III](#S5.T3 "TABLE III ‣ V-B1 Overall Results ‣ V-B RQ1: Effectiveness ‣
    V Evaluation ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair")
    总结了 RepairAgent 在修复 Defects4J 中的 835 个 bug 的效果。该方法为 186 个 bug 生成了合理的修复方案。虽然不一定正确，但合理的修复方案通过了所有测试用例，仍然可以为开发人员提供一些关于需要修改内容的提示。RepairAgent
    为 164 个 bug 生成了正确的修复方案，这些修复在语义上与开发人员提供的补丁一致。能够修复来自不同项目的 bug 表明该方法可以推广到多个领域的代码库。此外，RepairAgent
    为不同复杂度的 bug 创建了修复方案。具体而言，如表 [IV](#S5.T4 "TABLE IV ‣ V-B1 Overall Results ‣ V-B
    RQ1: Effectiveness ‣ V Evaluation ‣ RepairAgent: An Autonomous, LLM-Based Agent
    for Program Repair") 所示，该方法修复了 115 个单行 bug，46 个多行（单文件）bug 和 3 个多文件 bug。'
- en: V-B2 Comparison with Prior Work
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: V-B2 与先前工作的比较
- en: '![Refer to caption](img/0001e517270f48dafb6713b7842331f4.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/0001e517270f48dafb6713b7842331f4.png)'
- en: 'Figure 6: Intersection of the set fixes with related work.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：修复集与相关工作的交集。
- en: 'The right-hand side of Table [III](#S5.T3 "TABLE III ‣ V-B1 Overall Results
    ‣ V-B RQ1: Effectiveness ‣ V Evaluation ‣ RepairAgent: An Autonomous, LLM-Based
    Agent for Program Repair") compares RepairAgent with the baseline approaches ChatRepair,
    ITER, and SelfAPR. Previous to this work, ChatRepair had established a new state
    of the art in APR by fixing 162 bugs in Defects4J. RepairAgent achieves a comparable
    record by fixing a total of 164 bugs. Our work particularly excels in Defects4Jv2,
    where RepairAgent fixes 90 bugs, while ChatRepair only fixes 48 bugs. To further
    compare the sets of fixed bugs, Figure [6](#S5.F6 "Figure 6 ‣ V-B2 Comparison
    with Prior Work ‣ V-B RQ1: Effectiveness ‣ V Evaluation ‣ RepairAgent: An Autonomous,
    LLM-Based Agent for Program Repair") shows the overlaps between different approaches.
    As often observed in the field of APR, different approaches complement each other
    to some extent. In particular, RepairAgent fixes 39 bugs that were not fixed by
    any of the three baselines. Comparing the complexity of the bug fixes, as shown
    on the right-hand side of Table [IV](#S5.T4 "TABLE IV ‣ V-B1 Overall Results ‣
    V-B RQ1: Effectiveness ‣ V Evaluation ‣ RepairAgent: An Autonomous, LLM-Based
    Agent for Program Repair"), RepairAgent is particularly more effective, compared
    to other tools, for bugs that require more than a single-line fix. We attribute
    this result to the RepairAgent’s ability to autonomously retrieve suitable repair
    ingredients and the fact that the agent can perform edits to an arbitrary number
    of lines and files.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '表[III](#S5.T3 "TABLE III ‣ V-B1 Overall Results ‣ V-B RQ1: Effectiveness ‣
    V Evaluation ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair")右侧比较了RepairAgent与基准方法ChatRepair、ITER和SelfAPR。在这项工作之前，ChatRepair通过修复Defects4J中的162个漏洞，建立了APR的新技术水平。RepairAgent通过修复总共164个漏洞达到了类似的记录。我们的工作在Defects4Jv2中表现尤为突出，其中RepairAgent修复了90个漏洞，而ChatRepair仅修复了48个漏洞。为了进一步比较修复的漏洞集合，图[6](#S5.F6
    "Figure 6 ‣ V-B2 Comparison with Prior Work ‣ V-B RQ1: Effectiveness ‣ V Evaluation
    ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair")展示了不同方法之间的重叠情况。正如在APR领域常见的那样，不同的方法在某种程度上相互补充。特别是，RepairAgent修复了三种基准方法都未修复的39个漏洞。比较漏洞修复的复杂性，如表[IV](#S5.T4
    "TABLE IV ‣ V-B1 Overall Results ‣ V-B RQ1: Effectiveness ‣ V Evaluation ‣ RepairAgent:
    An Autonomous, LLM-Based Agent for Program Repair")右侧所示，RepairAgent在处理需要多行修复的漏洞时，相较于其他工具特别有效。我们将这一结果归因于RepairAgent能够自主检索适当的修复材料，并且该代理可以对任意数量的行和文件进行编辑。'
- en: V-B3 Examples
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: V-B3 示例
- en: 'if  (cfa  !=  null)  {for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {-  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);+  cfa.createEdge(fromNode,  Branch.ON_EX,  finallyNode);}}'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'if  (cfa  !=  null)  {for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {-  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);+  cfa.createEdge(fromNode,  Branch.ON_EX,  finallyNode);}}'
- en: 'Figure 7: Closure-14, bug fixed by RepairAgent.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：Closure-14，RepairAgent修复的漏洞。
- en: Separator  sep  =  (Separator)  elementPairs.get(0);+  if  (sep.iAfterParser  ==  null  &&  sep.iAfterPrinter  ==  null)  {PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);sep  =  sep.finish(f.getPrinter(),  f.getParser());return  new  PeriodFormatter(sep,  sep);+  }
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Separator  sep  =  (Separator)  elementPairs.get(0);+  if  (sep.iAfterParser  ==  null  &&  sep.iAfterPrinter  ==  null)  {PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);sep  =  sep.finish(f.getPrinter(),  f.getParser());return  new  PeriodFormatter(sep,  sep);+  }
- en: 'Figure 8: Time-27, bug fixed by RepairAgent.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：Time-27，RepairAgent修复的漏洞。
- en: 'Figures [7](#S5.F7 "Figure 7 ‣ V-B3 Examples ‣ V-B RQ1: Effectiveness ‣ V Evaluation
    ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair") and [8](#S5.F8
    "Figure 8 ‣ V-B3 Examples ‣ V-B RQ1: Effectiveness ‣ V Evaluation ‣ RepairAgent:
    An Autonomous, LLM-Based Agent for Program Repair") showcase interesting bugs
    fixed exclusively by RepairAgent. In the example of Figure [7](#S5.F7 "Figure
    7 ‣ V-B3 Examples ‣ V-B RQ1: Effectiveness ‣ V Evaluation ‣ RepairAgent: An Autonomous,
    LLM-Based Agent for Program Repair"), the agent used the tool $find\_similar\_api\_calls$
    to search for calls similar to cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
    which returns a similar call that is found in another file but passes Branch.ON_EX
    to the method call instead of Branch.UNCOND. The latter was used as the repair
    ingredient by the agent.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '图 [7](#S5.F7 "Figure 7 ‣ V-B3 Examples ‣ V-B RQ1: Effectiveness ‣ V Evaluation
    ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair") 和 [8](#S5.F8
    "Figure 8 ‣ V-B3 Examples ‣ V-B RQ1: Effectiveness ‣ V Evaluation ‣ RepairAgent:
    An Autonomous, LLM-Based Agent for Program Repair") 展示了 RepairAgent 独立修复的有趣 bug。在图
    [7](#S5.F7 "Figure 7 ‣ V-B3 Examples ‣ V-B RQ1: Effectiveness ‣ V Evaluation ‣
    RepairAgent: An Autonomous, LLM-Based Agent for Program Repair") 的示例中，代理使用工具 $find\_similar\_api\_calls$
    搜索类似于 cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); 的调用，结果返回一个在另一个文件中找到的类似调用，但将
    Branch.ON_EX 传递给方法调用而不是 Branch.UNCOND。后者被代理作为修复成分使用。'
- en: In the second example, RepairAgent benefeted from the tool $generate\_method\_body$
    to generate the missing if-statement which led to suggesting a correct fix afterwards.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，RepairAgent 利用了工具 $generate\_method\_body$ 来生成缺失的 if 语句，这导致随后建议了正确的修复方案。
- en: From one side, these examples illustrate the clever and proper usage of available
    tools by the repair agent. From the other side, it shows how useful these tools
    at finding repair ingredients that traditional approaches and previous work failed
    to find.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从一方面看，这些示例展示了修复代理巧妙且适当使用现有工具的方式。另一方面，它也显示了这些工具在发现传统方法和以往工作未能找到的修复成分方面的有效性。
- en: 'V-C RQ2: Costs of the Approach'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'V-C RQ2: 方法的成本'
- en: '![Refer to caption](img/085940f2b03047d2c8a78a2bea33875b.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![参见说明](img/085940f2b03047d2c8a78a2bea33875b.png)'
- en: (a) Time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 时间。
- en: '![Refer to caption](img/d0a2d5e0a47db4d3f818d2ad359daf4c.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![参见说明](img/d0a2d5e0a47db4d3f818d2ad359daf4c.png)'
- en: (b) Tokens/money consumption.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 令牌/金钱消耗。
- en: 'Figure 9: Distribution of cost metrics per bug (time, number of token, and
    monetary costs).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9：每个 bug 的成本指标分布（时间、令牌数量和货币成本）。
- en: 'We measure three kinds of costs imposed by RepairAgent: (i) Time taken to fix
    a bug. (ii) The number of tokens consumed by queries to the LLM, which is relevant
    both for commercial models, such as the GPT-3.5 used here, and for self-hosted
    models, where the number of tokens determines the computational costs. (iii) The
    monetary costs associated with the token consumption, based on OpenAI’s pricing
    as of March 2024.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们衡量了 RepairAgent 带来的三种成本：（i）修复一个 bug 所花费的时间。（ii）LLM 查询消耗的令牌数量，这与商业模型（如这里使用的
    GPT-3.5）以及自托管模型（令牌数量决定了计算成本）相关。（iii）基于 2024 年 3 月 OpenAI 定价的令牌消耗的货币成本。
- en: 'Our findings are summarized in Figure [9](#S5.F9 "Figure 9 ‣ V-C RQ2: Costs
    of the Approach ‣ V Evaluation ‣ RepairAgent: An Autonomous, LLM-Based Agent for
    Program Repair"). The median time taken to address a bug is 920 seconds, with
    minimal variation between fixed (870 seconds) and unfixed bugs. Surprisingly,
    fixed bugs do not consistently exhibit lower repair times. This is due to RepairAgent’s
    autonomous nature, where the repair process continues until the *goal_accomplished*
    command is invoked or the cycles budget is exhausted. The figure shows several
    outliers where bug fixing attempt takes multiple hours. RepairAgent spends 99%
    of the total time in tool executions, mostly running tests. This cost could be
    reduced in the future by executing selected test cases only.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的发现总结在图 [9](#S5.F9 "Figure 9 ‣ V-C RQ2: Costs of the Approach ‣ V Evaluation
    ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair") 中。处理一个 bug
    的中位时间为 920 秒，修复的（870 秒）和未修复的 bug 之间差异很小。令人惊讶的是，修复的 bug 并不总是表现出较低的修复时间。这是因为 RepairAgent
    的自主特性，修复过程会持续进行，直到调用 *goal_accomplished* 命令或耗尽循环预算。图中显示了几个异常值，其中 bug 修复尝试耗时数小时。RepairAgent
    在工具执行中花费了 99% 的总时间，大多用于运行测试。未来可以通过仅执行选定的测试用例来减少这项成本。'
- en: Analyzing the costs imposed by the LLM, we find a median consumption of approximately
    270,000 tokens, equating to around 14 cents (US dollars). The number of tokens
    consumed by fixed bugs (21,000) is clearly lower than by unfixed bugs (315,000).
    This difference is because the agent continues to extract additional information
    for not yet fixed bugs, saturating the prompt with operations, such as reading
    more lines of code or performing extensive searches.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 分析LLM所产生的成本，我们发现中位数消耗约为270,000个tokens，相当于约14美分。修复bug消耗的tokens（21,000）明显低于未修复bug（315,000）。这种差异是因为代理继续为尚未修复的bug提取额外信息，将提示填充更多操作，如读取更多代码行或进行广泛搜索。
- en: 'V-D RQ3: Usage of Tools by the Agent'
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'V-D RQ3: 代理使用工具'
- en: To better understand the approach, we evaluate how the agent uses the available
    tools.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解方法，我们评估了代理如何使用可用工具。
- en: V-D1 Adherence to Output Format
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: V-D1 输出格式遵循
- en: 'A notable challenge in designing an LLM-based agent is the inherent informality
    and natural language noise present in the model’s output. We categorize the output
    of the model as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 设计基于LLM的代理时，一个显著挑战是模型输出中的固有非正式性和自然语言噪音。我们将模型的输出分类如下：
- en: •
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Fully parsable output:* Responses that adhere to the JSON format without requiring
    further refinement (87.7%).'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*完全可解析的输出：* 遵循JSON格式且无需进一步优化的响应（87.7%）。'
- en: •
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Unparsable output:* Responses that do not conform to the JSON format (2.3%
    of the responses).'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*无法解析的输出：* 不符合JSON格式的响应（2.3%的响应）。'
- en: •
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Partially parsable output:* Responses in JSON format but with missing or misnamed
    fields requiring refinement by the middleware (9.9%).'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分可解析的输出：* JSON格式的响应，但有缺失或错误命名的字段，需要中间件优化（9.9%）。'
- en: 'A parsed output does not guarantee a correctly specified command, which the
    middleware tries to rectify. At this phase, the output may fall into the following
    categories:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 解析的输出并不保证命令的正确指定，中间件会尝试修正。在此阶段，输出可能属于以下类别：
- en: •
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Correct command name:* The name of the command is correct (97.9%).'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*正确的命令名称：* 命令名称正确（97.9%）。'
- en: •
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Non-existent command:* The command could not be found or mapped to an existing
    one (1.4%).'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*不存在的命令：* 找不到或无法映射到现有命令的命令（1.4%）。'
- en: •
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Mapped command:* The command does not exist but can be mapped to an existing
    command by the middleware (0.7%).'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*映射命令：* 命令不存在，但可以由中间件映射到现有命令（0.7%）。'
- en: •
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Correct arguments:* The arguments are correct (90.1%).'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*正确的参数：* 参数正确（90.1%）。'
- en: •
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Unrefinable arguments list:* The command exists or was mapped, but the list
    of arguments is incomplete or has incorrect names (1.9%).'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*无法优化的参数列表：* 命令存在或已映射，但参数列表不完整或名称不正确（1.9%）。'
- en: •
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '*Refinable arguments list:* The middleware successfully maps the list of arguments
    into a correct one (8.0%).'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*可优化的参数列表：* 中间件成功将参数列表映射为正确的列表（8.0%）。'
- en: Overall, these results show that our heuristic refinement of LLM outputs contributes
    to the effectiveness and robustness of RepairAgent.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这些结果表明我们对LLM输出的启发式优化有助于RepairAgent的有效性和鲁棒性。
- en: V-D2 Frequency of Tools Invocation
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: V-D2 工具调用频率
- en: '![Refer to caption](img/cf586852e5c0e931e46e51ec585ab8eb.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![参见说明](img/cf586852e5c0e931e46e51ec585ab8eb.png)'
- en: 'Figure 10: Frequency of tool invocations (average per bug).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：工具调用频率（每个bug的平均次数）。
- en: 'On average, RepairAgent makes 35 calls per bug, which also corresponds to the
    number of cycles. Figure [10](#S5.F10 "Figure 10 ‣ V-D2 Frequency of Tools Invocation
    ‣ V-D RQ3: Usage of Tools by the Agent ‣ V Evaluation ‣ RepairAgent: An Autonomous,
    LLM-Based Agent for Program Repair") shows the frequency of tool invocations,
    where we distinguish between fixed (i.e., “correct”) and unfixed (i.e., “plausible”
    only or completely unfixed) bugs. The LLM agent uses the full range of tools,
    with the most frequently called tool being *write_fix* (average of 6 calls for
    fixed bugs and 17 calls for unfixed bugs. Around 7% of *write_fix* invocations
    in unfixed bugs produce plausible patches, compared to 44% in fixed bugs.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '平均而言，RepairAgent每个bug调用35次，这也对应于周期数。图 [10](#S5.F10 "Figure 10 ‣ V-D2 Frequency
    of Tools Invocation ‣ V-D RQ3: Usage of Tools by the Agent ‣ V Evaluation ‣ RepairAgent:
    An Autonomous, LLM-Based Agent for Program Repair") 显示了工具调用的频率，其中区分了已修复（即“正确”）和未修复（即“仅合理”或完全未修复）bug。LLM代理使用了全范围的工具，其中调用频率最高的工具是
    *write_fix*（已修复bug的平均调用次数为6次，未修复bug的平均调用次数为17次）。在未修复的bug中，约7%的 *write_fix* 调用产生了合理的修复补丁，而已修复的bug中为44%。'
- en: VI Threats to Validity and Limitations
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VI 有效性威胁和局限性
- en: 'While RepairAgent shows promising results when repairing Defects4J bugs, we
    acknowledge several potential threats to validity and inherent limitations: *(i)
    Data leakage:* As we evaluate on GPT-3.5 and its training data is not publicly
    known, the LLM may have seen parts of the Java projects during training. While
    we acknowledge this risk, our approach does not solely depend on knowing about
    a bug, but rather the ability to collect information to fix the bug. We also note
    that the closest competitor, ChatRepair, also uses GPT-3.5, and thus faces the
    same risk. *(ii) Missing test cases:* Defects4J has at least one failing test
    case for each bug, which may not be the case for real-world usage scenarios. It
    will be interesting to evaluate RepairAgent on bugs with no a-priori available
    error-revealing test cases in future work. *(iii) Fault localization:* Inaccurate
    or imprecise fault localization could lead to suboptimal repair suggestions or
    incorrect diagnoses. *(iv) Non-deterministic output of LLMs:* The inherently non-deterministic
    nature of LLMs may result in different outcomes between two consecutive runs of
    RepairAgent. The large number of bugs we evaluate on mitigates this risk. Moreover,
    we make logs of all interactions with the LLM available to ensure reproducibility.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然RepairAgent在修复Defects4J缺陷时显示了有希望的结果，但我们承认存在几个潜在的有效性威胁和固有的局限性：*(i) 数据泄漏：* 由于我们在GPT-3.5上进行评估，而其训练数据并未公开，因此LLM可能在训练过程中见过Java项目的部分内容。尽管我们承认这一风险，但我们的方法不仅仅依赖于了解一个缺陷，而是依赖于收集信息以修复缺陷。我们还注意到，最接近的竞争者ChatRepair也使用GPT-3.5，因此面临相同的风险。*(ii)
    测试用例缺失：* Defects4J对每个缺陷都有至少一个失败的测试用例，而在实际使用场景中可能不是如此。未来的工作中评估RepairAgent在没有先验错误揭示测试用例的缺陷上的表现将是有趣的。*(iii)
    故障定位：* 不准确或不精确的故障定位可能导致次优的修复建议或错误的诊断。*(iv) LLM的非确定性输出：* LLM的固有非确定性可能导致RepairAgent的两次连续运行之间结果不同。我们评估的大量缺陷减轻了这一风险。此外，我们记录了与LLM的所有互动日志，以确保可重复性。
- en: VII Related Work
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VII 相关工作
- en: Automated program repair
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自动化程序修复
- en: Automated program repair [[1](#bib.bib1)] has received significant attention.
    Some approaches address it as a search problem based on manually designed code
    mutation rules and fix patterns [[2](#bib.bib2), [38](#bib.bib38), [3](#bib.bib3)].
    Alternatively, transformation rules can be derived (semi-)automatically from human-written
    patches [[4](#bib.bib4), [5](#bib.bib5), [6](#bib.bib6)]. Other approaches use
    symbolic constraints to derive fixes [[7](#bib.bib7), [39](#bib.bib39), [8](#bib.bib8),
    [9](#bib.bib9)], integrate repair into a static analysis that identifies bugs [[40](#bib.bib40),
    [41](#bib.bib41), [42](#bib.bib42)], or replace buggy code with similar code from
    the same project [[43](#bib.bib43)]. APR has been successfully deployed in industrial
    contexts [[5](#bib.bib5), [44](#bib.bib44)]. Beyond functional bugs, several techniques
    target other kinds of problems, such as syntax errors [[45](#bib.bib45), [46](#bib.bib46),
    [47](#bib.bib47)], performance bugs [[48](#bib.bib48)], vulnerabilities [[49](#bib.bib49)],
    type errors [[50](#bib.bib50)], common issues in deep learning code [[51](#bib.bib51)],
    and build errors [[52](#bib.bib52)].
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化程序修复[[1](#bib.bib1)]已受到广泛关注。一些方法将其视为基于手动设计的代码变异规则和修复模式的搜索问题[[2](#bib.bib2),
    [38](#bib.bib38), [3](#bib.bib3)]。另外，可以从人工编写的补丁中（半）自动生成变换规则[[4](#bib.bib4), [5](#bib.bib5),
    [6](#bib.bib6)]。其他方法使用符号约束来推导修复[[7](#bib.bib7), [39](#bib.bib39), [8](#bib.bib8),
    [9](#bib.bib9)]，将修复集成到识别错误的静态分析中[[40](#bib.bib40), [41](#bib.bib41), [42](#bib.bib42)]，或用来自同一项目的相似代码替换有缺陷的代码[[43](#bib.bib43)]。APR已在工业环境中成功应用[[5](#bib.bib5),
    [44](#bib.bib44)]。除了功能性错误外，一些技术还针对其他类型的问题，如语法错误[[45](#bib.bib45), [46](#bib.bib46),
    [47](#bib.bib47)]，性能缺陷[[48](#bib.bib48)]，漏洞[[49](#bib.bib49)]，类型错误[[50](#bib.bib50)]，深度学习代码中的常见问题[[51](#bib.bib51)]，以及构建错误[[52](#bib.bib52)]。
- en: Learning-based program repair
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于学习的程序修复
- en: While early work uses machine learning to rank and select candidate fixes [[10](#bib.bib10)],
    more recent work uses machine learning to generate fixes. Approaches include neural
    machine translation models that map buggy code into fixed code [[11](#bib.bib11),
    [12](#bib.bib12), [13](#bib.bib13), [14](#bib.bib14)], models that predict tree
    transformations [[15](#bib.bib15), [16](#bib.bib16)], neural architectures for
    specific kinds of bugs [[53](#bib.bib53)], and repair-specific training regimes [[54](#bib.bib54),
    [37](#bib.bib37)]. We refer to a recent survey for a more comprehensive discussion [[55](#bib.bib55)].
    Unlike the above work, RepairAgent and the work discussed below use a general-purpose
    LLM, instead of training a task-specific model.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 早期工作使用机器学习来排名和选择候选修复方案 [[10](#bib.bib10)]，而最近的工作使用机器学习来生成修复方案。这些方法包括将有缺陷的代码映射到修复代码的神经机器翻译模型 [[11](#bib.bib11),
    [12](#bib.bib12), [13](#bib.bib13), [14](#bib.bib14)]，预测树转换的模型 [[15](#bib.bib15),
    [16](#bib.bib16)]，用于特定类型错误的神经架构 [[53](#bib.bib53)]，以及修复特定的训练方案 [[54](#bib.bib54),
    [37](#bib.bib37)]。我们参阅了最近的综述以获取更全面的讨论 [[55](#bib.bib55)]。与上述工作不同，RepairAgent和下面讨论的工作使用通用LLM，而不是训练特定任务的模型。
- en: LLM-based program repair
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于LLM的程序修复
- en: 'LLMs have motivated researchers to apply them to program repair, e.g., in studies
    that explore prompts [[18](#bib.bib18), [17](#bib.bib17)] and in a technique that
    prompts the model with error messages [[56](#bib.bib56)]. These approaches perform
    a one-time interaction with the model, where the model receives a prompt with
    code and produces a fix. The most recent repair techniques introduce iterative
    approaches, which query the LLM repeatedly based on feedback obtained from previous
    fix attempts [[19](#bib.bib19), [20](#bib.bib20), [21](#bib.bib21)]. RepairAgent
    also queries the model multiple times, but fundamentally differs by pursuing an
    agent-based approach. Section [V](#S5 "V Evaluation ‣ RepairAgent: An Autonomous,
    LLM-Based Agent for Program Repair") empirically compares RepairAgent to the most
    closely related iterative approaches [[19](#bib.bib19), [21](#bib.bib21)].'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'LLM激发了研究人员将其应用于程序修复，例如，在探索提示的研究中 [[18](#bib.bib18), [17](#bib.bib17)]，以及一种用错误信息提示模型的技术 [[56](#bib.bib56)]。这些方法与模型进行一次性互动，模型接收带有代码的提示并生成修复。最新的修复技术引入了迭代方法，根据从以前的修复尝试中获得的反馈反复查询LLM [[19](#bib.bib19),
    [20](#bib.bib20), [21](#bib.bib21)]。RepairAgent也会多次查询模型，但根本上不同的是，它采用基于代理的方法。第[V](#S5
    "V Evaluation ‣ RepairAgent: An Autonomous, LLM-Based Agent for Program Repair)节实证地将RepairAgent与最相关的迭代方法进行比较 [[19](#bib.bib19),
    [21](#bib.bib21)]。'
- en: LLMs for code generation and code editing
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: LLM在代码生成和代码编辑中的应用
- en: Beyond program repair, LLMs have been applied to a variety of other code generation
    and code editing tasks, including code completion [[34](#bib.bib34), [57](#bib.bib57)],
    fuzzing [[58](#bib.bib58)], generating and improving unit tests [[59](#bib.bib59),
    [60](#bib.bib60), [61](#bib.bib61), [62](#bib.bib62), [63](#bib.bib63), [64](#bib.bib64)],
    multi-step code editing [[65](#bib.bib65)]. Unlike our work, none of these approaches
    uses an agent-based approach.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 除了程序修复，LLM还被应用于各种其他代码生成和代码编辑任务，包括代码补全 [[34](#bib.bib34), [57](#bib.bib57)]，模糊测试 [[58](#bib.bib58)]，生成和改进单元测试 [[59](#bib.bib59),
    [60](#bib.bib60), [61](#bib.bib61), [62](#bib.bib62), [63](#bib.bib63), [64](#bib.bib64)]，多步骤代码编辑 [[65](#bib.bib65)]。与我们的工作不同，这些方法没有使用基于代理的方法。
- en: LLM-based agents
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于LLM的代理
- en: The idea to let LLM agents autonomously plan and perform complex tasks is relatively
    new and has been applied to tasks outside of software engineering [[28](#bib.bib28)].
    To the best of our knowledge, our work is the first to apply an LLM-based agent
    to program repair or any other code generation problem in software engineering.
    RepairAgent is inspired by prior work [[29](#bib.bib29)] on augmenting LLMs with
    tools invoked via APIs [[26](#bib.bib26), [27](#bib.bib27)] and with the ability
    to generate and execute code [[66](#bib.bib66)]. Our key contribution in applying
    these ideas to a software engineering task is to define tools that are useful
    for program repair and a prompt format that allows the LLM to interact with these
    tools.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让LLM代理自主规划和执行复杂任务的想法相对较新，并且已经应用于软件工程以外的任务 [[28](#bib.bib28)]。据我们所知，我们的工作是首次将基于LLM的代理应用于程序修复或任何其他软件工程中的代码生成问题。RepairAgent的灵感来源于之前的工作 [[29](#bib.bib29)]，这些工作通过API调用工具来增强LLM [[26](#bib.bib26),
    [27](#bib.bib27)]，并具有生成和执行代码的能力 [[66](#bib.bib66)]。我们将这些理念应用于软件工程任务的关键贡献在于定义了对程序修复有用的工具，以及一种允许LLM与这些工具互动的提示格式。
- en: VIII Conclusion
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VIII 结论
- en: This paper presents a pioneering technique for bug repair based on an autonomous
    agent powered by Large Language Models (LLMs). Through extensive experimentation,
    we validate the effectiveness and potential of our approach. Further exploration
    and refinement of autonomous agent-based techniques will help generalize to more
    difficult and diverse types of bugs if equipped with the right tools.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本文提出了一种基于大型语言模型（LLMs）驱动的自主代理的开创性错误修复技术。通过广泛的实验，我们验证了我们方法的有效性和潜力。进一步探索和完善基于自主代理的技术将有助于推广到更难和更复杂的错误类型，只要配备了合适的工具。
- en: References
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[1] C. Le Goues, M. Pradel, and A. Roychoudhury, “Automated program repair,”
    *Commun. ACM*, vol. 62, no. 12, pp. 56–65, 2019\. [Online]. Available: https://doi.org/10.1145/3318162'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1] C. Le Goues, M. Pradel, 和 A. Roychoudhury, “自动化程序修复，” *Commun. ACM*, vol.
    62, no. 12, pp. 56–65, 2019\. [在线]. 可用: https://doi.org/10.1145/3318162'
- en: '[2] C. Le Goues, T. Nguyen, S. Forrest, and W. Weimer, “Genprog: A generic
    method for automatic software repair,” *IEEE Trans. Software Eng.*, vol. 38, no. 1,
    pp. 54–72, 2012.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2] C. Le Goues, T. Nguyen, S. Forrest, 和 W. Weimer, “Genprog: 一种通用的自动软件修复方法，”
    *IEEE 软件工程学报*, vol. 38, no. 1, pp. 54–72, 2012。'
- en: '[3] K. Liu, A. Koyuncu, D. Kim, and T. F. Bissyandé, “Tbar: revisiting template-based
    automated program repair,” in *Proceedings of the 28th ACM SIGSOFT International
    Symposium on Software Testing and Analysis, ISSTA 2019, Beijing, China, July 15-19,
    2019*, D. Zhang and A. Møller, Eds.   ACM, 2019, pp. 31–42. [Online]. Available:
    https://doi.org/10.1145/3293882.3330577'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3] K. Liu, A. Koyuncu, D. Kim, 和 T. F. Bissyandé, “Tbar: 重新审视基于模板的自动化程序修复，”
    在 *第28届 ACM SIGSOFT 国际软件测试与分析研讨会（ISSTA 2019），北京，中国，2019年7月15日-19日*, D. Zhang 和
    A. Møller, 编辑. ACM, 2019, pp. 31–42. [在线]. 可用: https://doi.org/10.1145/3293882.3330577'
- en: '[4] D. Kim, J. Nam, J. Song, and S. Kim, “Automatic patch generation learned
    from human-written patches.” in *International Conference on Software Engineering
    (ICSE)*, 2013, pp. 802–811.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4] D. Kim, J. Nam, J. Song, 和 S. Kim, “从人类编写的补丁中学习自动补丁生成。” 在 *国际软件工程会议（ICSE）*,
    2013, pp. 802–811。'
- en: '[5] J. Bader, A. Scott, M. Pradel, and S. Chandra, “Getafix: Learning to fix
    bugs automatically,” *Proc. ACM Program. Lang.*, vol. 3, no. OOPSLA, pp. 159:1–159:27,
    2019\. [Online]. Available: https://doi.org/10.1145/3360585'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5] J. Bader, A. Scott, M. Pradel, 和 S. Chandra, “Getafix: 学习自动修复错误，” *Proc.
    ACM Program. Lang.*, vol. 3, no. OOPSLA, pp. 159:1–159:27, 2019\. [在线]. 可用: https://doi.org/10.1145/3360585'
- en: '[6] R. Bavishi, H. Yoshida, and M. R. Prasad, “Phoenix: automated data-driven
    synthesis of repairs for static analysis violations,” in *ESEC/SIGSOFT FSE 2019,
    Tallinn, Estonia, August 26-30, 2019*, M. Dumas, D. Pfahl, S. Apel, and A. Russo,
    Eds.   ACM, 2019, pp. 613–624\. [Online]. Available: https://doi.org/10.1145/3338906.3338952'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6] R. Bavishi, H. Yoshida, 和 M. R. Prasad, “Phoenix: 基于数据驱动的静态分析违规修复自动合成，”
    在 *ESEC/SIGSOFT FSE 2019, 塔林，爱沙尼亚，2019年8月26日-30日*, M. Dumas, D. Pfahl, S. Apel,
    和 A. Russo, 编辑. ACM, 2019, pp. 613–624\. [在线]. 可用: https://doi.org/10.1145/3338906.3338952'
- en: '[7] H. D. T. Nguyen, D. Qi, A. Roychoudhury, and S. Chandra, “Semfix: program
    repair via semantic analysis,” in *35th International Conference on Software Engineering,
    ICSE ’13, San Francisco, CA, USA, May 18-26, 2013*, 2013, pp. 772–781.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7] H. D. T. Nguyen, D. Qi, A. Roychoudhury, 和 S. Chandra, “Semfix: 通过语义分析进行程序修复，”
    在 *第35届国际软件工程会议（ICSE ’13），旧金山，加州，美国，2013年5月18日-26日*, 2013, pp. 772–781。'
- en: '[8] J. Xuan, M. Martinez, F. Demarco, M. Clement, S. L. Marcote, T. Durieux,
    D. Le Berre, and M. Monperrus, “Nopol: Automatic repair of conditional statement
    bugs in java programs,” *IEEE Transactions on Software Engineering*, vol. 43,
    no. 1, pp. 34–55, 2016.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8] J. Xuan, M. Martinez, F. Demarco, M. Clement, S. L. Marcote, T. Durieux,
    D. Le Berre, 和 M. Monperrus, “Nopol: 自动修复 Java 程序中的条件语句错误，” *IEEE 软件工程学报*, vol.
    43, no. 1, pp. 34–55, 2016。'
- en: '[9] S. Mechtaev, J. Yi, and A. Roychoudhury, “Angelix: Scalable multiline program
    patch synthesis via symbolic analysis,” in *Proceedings of the 38th international
    conference on software engineering*, 2016, pp. 691–701.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9] S. Mechtaev, J. Yi, 和 A. Roychoudhury, “Angelix: 通过符号分析进行可扩展的多行程序补丁合成，”
    在 *第38届国际软件工程会议论文集*, 2016, pp. 691–701。'
- en: '[10] F. Long and M. Rinard, “Automatic patch generation by learning correct
    code,” in *Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles
    of Programming Languages, POPL 2016, St. Petersburg, FL, USA, January 20 - 22,
    2016*, 2016, pp. 298–312.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10] F. Long 和 M. Rinard, “通过学习正确代码进行自动补丁生成，” 在 *第43届 ACM SIGPLAN-SIGACT 编程语言原则研讨会（POPL
    2016），圣彼得堡，FL，美国，2016年1月20日 - 22日*, 2016, pp. 298–312。'
- en: '[11] R. Gupta, S. Pal, A. Kanade, and S. K. Shevade, “Deepfix: Fixing common
    C language errors by deep learning,” in *Proceedings of the Thirty-First AAAI
    Conference on Artificial Intelligence*, 2017, pp. 1345–1351. [Online]. Available:
    http://aaai.org/ocs/index.php/AAAI/AAAI17/paper/view/14603'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11] R. Gupta, S. Pal, A. Kanade, 和 S. K. Shevade，"Deepfix: 通过深度学习修复常见C语言错误"，收录于
    *第三十一届AAAI人工智能会议论文集*，2017，第1345–1351页。 [在线]. 可用: http://aaai.org/ocs/index.php/AAAI/AAAI17/paper/view/14603'
- en: '[12] M. Tufano, J. Pantiuchina, C. Watson, G. Bavota, and D. Poshyvanyk, “On
    learning meaningful code changes via neural machine translation,” in *Proceedings
    of the 41st International Conference on Software Engineering, ICSE 2019, Montreal,
    QC, Canada, May 25-31, 2019*, 2019, pp. 25–36\. [Online]. Available: https://dl.acm.org/citation.cfm?id=3339509'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12] M. Tufano, J. Pantiuchina, C. Watson, G. Bavota, 和 D. Poshyvanyk，"通过神经机器翻译学习有意义的代码更改"，收录于
    *第41届国际软件工程会议论文集，ICSE 2019，蒙特利尔，QC，加拿大，2019年5月25-31日*，2019，第25–36页\. [在线]. 可用:
    https://dl.acm.org/citation.cfm?id=3339509'
- en: '[13] T. Lutellier, H. V. Pham, L. Pang, Y. Li, M. Wei, and L. Tan, “Coconut:
    combining context-aware neural translation models using ensemble for program repair,”
    in *ISSTA ’20: 29th ACM SIGSOFT Virtual Event, USA, July 18-22, 2020*, S. Khurshid
    and C. S. Pasareanu, Eds.   ACM, 2020, pp. 101–114\. [Online]. Available: https://doi.org/10.1145/3395363.3397369'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13] T. Lutellier, H. V. Pham, L. Pang, Y. Li, M. Wei, 和 L. Tan，"Coconut: 结合上下文感知神经翻译模型的集成用于程序修复"，收录于
    *ISSTA ’20: 第29届ACM SIGSOFT虚拟会议，美国，2020年7月18-22日*，S. Khurshid 和 C. S. Pasareanu
    编辑。 ACM，2020，第101–114页\. [在线]. 可用: https://doi.org/10.1145/3395363.3397369'
- en: '[14] Z. Chen, S. Kommrusch, M. Tufano, L. Pouchet, D. Poshyvanyk, and M. Monperrus,
    “SequenceR: Sequence-to-sequence learning for end-to-end program repair,” *IEEE
    Trans. Software Eng.*, vol. 47, no. 9, pp. 1943–1959, 2021. [Online]. Available:
    https://doi.org/10.1109/TSE.2019.2940179'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14] Z. Chen, S. Kommrusch, M. Tufano, L. Pouchet, D. Poshyvanyk, 和 M. Monperrus，"SequenceR:
    序列到序列学习用于端到端程序修复"，*IEEE软件工程学报*，第47卷，第9期，第1943–1959页，2021。 [在线]. 可用: https://doi.org/10.1109/TSE.2019.2940179'
- en: '[15] Y. Li, S. Wang, and T. N. Nguyen, “Dlfix: Context-based code transformation
    learning for automated program repair,” in *ICSE*, 2020.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[15] Y. Li, S. Wang, 和 T. N. Nguyen，"Dlfix: 基于上下文的代码转换学习用于自动化程序修复"，收录于 *ICSE*，2020。'
- en: '[16] Q. Zhu, Z. Sun, Y. Xiao, W. Zhang, K. Yuan, Y. Xiong, and L. Zhang, “A
    syntax-guided edit decoder for neural program repair,” in *ESEC/FSE ’21 Athens,
    Greece, August 23-28, 2021*, D. Spinellis, G. Gousios, M. Chechik, and M. D. Penta,
    Eds.   ACM, 2021, pp. 341–353\. [Online]. Available: https://doi.org/10.1145/3468264.3468544'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16] Q. Zhu, Z. Sun, Y. Xiao, W. Zhang, K. Yuan, Y. Xiong, 和 L. Zhang，"一种基于语法指导的编辑解码器用于神经程序修复"，收录于
    *ESEC/FSE ’21 雅典，希腊，2021年8月23-28日*，D. Spinellis, G. Gousios, M. Chechik, 和 M.
    D. Penta 编辑。 ACM，2021，第341–353页\. [在线]. 可用: https://doi.org/10.1145/3468264.3468544'
- en: '[17] C. S. Xia, Y. Wei, and L. Zhang, “Automated program repair in the era
    of large pre-trained language models,” in *2023 IEEE/ACM 45th International Conference
    on Software Engineering (ICSE)*, 2023, pp. 1482–1494.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[17] C. S. Xia, Y. Wei, 和 L. Zhang，"大规模预训练语言模型时代的自动化程序修复"，收录于 *2023 IEEE/ACM
    第45届国际软件工程会议（ICSE）*，2023，第1482–1494页。'
- en: '[18] N. Jiang, K. Liu, T. Lutellier, and L. Tan, “Impact of code language models
    on automated program repair,” in *45th IEEE/ACM International Conference on Software
    Engineering, ICSE*.   IEEE, 2023, pp. 1430–1442\. [Online]. Available: https://doi.org/10.1109/ICSE48619.2023.00125'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[18] N. Jiang, K. Liu, T. Lutellier, 和 L. Tan，"代码语言模型对自动化程序修复的影响"，收录于 *第45届IEEE/ACM国际软件工程会议，ICSE*。
    IEEE，2023，第1430–1442页\. [在线]. 可用: https://doi.org/10.1109/ICSE48619.2023.00125'
- en: '[19] C. S. Xia and L. Zhang, “Keep the conversation going: Fixing 162 out of
    337 bugs for $0.42 each using ChatGPT,” 2023.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[19] C. S. Xia 和 L. Zhang，"保持对话进行中：使用 ChatGPT 修复337个漏洞中的162个，每个修复费用 $0.42"，2023。'
- en: '[20] S. Kang, B. Chen, S. Yoo, and J. Lou, “Explainable automated debugging
    via large language model-driven scientific debugging,” *CoRR*, vol. abs/2304.02195,
    2023\. [Online]. Available: https://doi.org/10.48550/arXiv.2304.02195'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[20] S. Kang, B. Chen, S. Yoo, 和 J. Lou，"通过大语言模型驱动的科学调试进行可解释的自动化调试"，*CoRR*，第
    abs/2304.02195 卷，2023\. [在线]. 可用: https://doi.org/10.48550/arXiv.2304.02195'
- en: '[21] H. Ye and M. Monperrus, “Iter: Iterative neural repair for multi-location
    patches,” in *ICSE*, 2024.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[21] H. Ye 和 M. Monperrus，"Iter: 多位置补丁的迭代神经修复"，收录于 *ICSE*，2024。'
- en: '[22] A. J. Ko, B. A. Myers, M. J. Coblenz, and H. H. Aung, “An exploratory
    study of how developers seek, relate, and collect relevant information during
    software maintenance tasks,” *IEEE Transactions on software engineering*, vol. 32,
    no. 12, pp. 971–987, 2006.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[22] A. J. Ko, B. A. Myers, M. J. Coblenz, 和 H. H. Aung，"开发人员在软件维护任务中如何寻求、关联和收集相关信息的探索性研究"，*IEEE软件工程学报*，第32卷，第12期，第971–987页，2006。'
- en: '[23] M. Böhme, E. O. Soremekun, S. Chattopadhyay, E. Ugherughe, and A. Zeller,
    “Where is the bug and how is it fixed? an experiment with practitioners,” in *Proceedings
    of the 2017 11th joint meeting on foundations of software engineering*, 2017,
    pp. 117–128.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[23] M. Böhme, E. O. Soremekun, S. Chattopadhyay, E. Ugherughe, 和 A. Zeller，“错误在哪里，如何修复？与从业人员的实验”，在*2017年第11届软件工程基础联合会议论文集*，2017年，第117–128页。'
- en: '[24] R. Just, D. Jalali, and M. D. Ernst, “Defects4j: a database of existing
    faults to enable controlled testing studies for java programs,” in *International
    Symposium on Software Testing and Analysis, ISSTA ’14, San Jose, CA, USA - July
    21 - 26, 2014*, 2014, pp. 437–440.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[24] R. Just, D. Jalali, 和 M. D. Ernst，“Defects4j：一个用于启用控制测试研究的现有故障数据库”，在*国际软件测试与分析研讨会，ISSTA
    ’14，加州圣荷西，美国 - 2014年7月21日 - 26日*，2014年，第437–440页。'
- en: '[25] S. Bubeck, V. Chandrasekaran, R. Eldan, J. Gehrke, E. Horvitz, E. Kamar,
    P. Lee, Y. T. Lee, Y. Li, S. M. Lundberg, H. Nori, H. Palangi, M. T. Ribeiro,
    and Y. Zhang, “Sparks of artificial general intelligence: Early experiments with
    GPT-4,” *CoRR*, vol. abs/2303.12712, 2023\. [Online]. Available: https://doi.org/10.48550/arXiv.2303.12712'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[25] S. Bubeck, V. Chandrasekaran, R. Eldan, J. Gehrke, E. Horvitz, E. Kamar,
    P. Lee, Y. T. Lee, Y. Li, S. M. Lundberg, H. Nori, H. Palangi, M. T. Ribeiro,
    和 Y. Zhang，“人工通用智能的火花：与GPT-4的早期实验”，*计算机研究与技术*，第abs/2303.12712卷，2023年\. [在线]. 可用：
    https://doi.org/10.48550/arXiv.2303.12712'
- en: '[26] T. Schick, J. Dwivedi-Yu, R. Dessì, R. Raileanu, M. Lomeli, L. Zettlemoyer,
    N. Cancedda, and T. Scialom, “Toolformer: Language models can teach themselves
    to use tools,” *CoRR*, vol. abs/2302.04761, 2023. [Online]. Available: https://doi.org/10.48550/arXiv.2302.04761'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[26] T. Schick, J. Dwivedi-Yu, R. Dessì, R. Raileanu, M. Lomeli, L. Zettlemoyer,
    N. Cancedda, 和 T. Scialom，“工具前置器：语言模型可以自我学习使用工具”，*计算机研究与技术*，第abs/2302.04761卷，2023年。
    [在线]. 可用： https://doi.org/10.48550/arXiv.2302.04761'
- en: '[27] S. G. Patil, T. Zhang, X. Wang, and J. E. Gonzalez, “Gorilla: Large language
    model connected with massive apis,” *CoRR*, vol. abs/2305.15334, 2023. [Online].
    Available: https://doi.org/10.48550/arXiv.2305.15334'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[27] S. G. Patil, T. Zhang, X. Wang, 和 J. E. Gonzalez，“大猩猩：连接大量API的大型语言模型”，*计算机研究与技术*，第abs/2305.15334卷，2023年。
    [在线]. 可用： https://doi.org/10.48550/arXiv.2305.15334'
- en: '[28] L. Wang, C. Ma, X. Feng, Z. Zhang, H. Yang, J. Zhang, Z. Chen, J. Tang,
    X. Chen, Y. Lin, W. X. Zhao, Z. Wei, and J.-R. Wen, “A survey on large language
    model based autonomous agents,” 2023.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[28] L. Wang, C. Ma, X. Feng, Z. Zhang, H. Yang, J. Zhang, Z. Chen, J. Tang,
    X. Chen, Y. Lin, W. X. Zhao, Z. Wei, 和 J.-R. Wen，“基于大型语言模型的自主代理综述”，2023年。'
- en: '[29] G. Mialon, R. Dessì, M. Lomeli, C. Nalmpantis, R. Pasunuru, R. Raileanu,
    B. Rozière, T. Schick, J. Dwivedi-Yu, A. Celikyilmaz, E. Grave, Y. LeCun, and
    T. Scialom, “Augmented language models: a survey,” *CoRR*, vol. abs/2302.07842,
    2023\. [Online]. Available: https://doi.org/10.48550/arXiv.2302.07842'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[29] G. Mialon, R. Dessì, M. Lomeli, C. Nalmpantis, R. Pasunuru, R. Raileanu,
    B. Rozière, T. Schick, J. Dwivedi-Yu, A. Celikyilmaz, E. Grave, Y. LeCun, 和 T.
    Scialom，“增强语言模型：综述”，*计算机研究与技术*，第abs/2302.07842卷，2023年\. [在线]. 可用： https://doi.org/10.48550/arXiv.2302.07842'
- en: '[30] R.-M. Karampatsis and C. Sutton, “How often do single-statement bugs occur?”
    Jun. 2020\. [Online]. Available: http://dx.doi.org/10.1145/3379597.3387491'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[30] R.-M. Karampatsis 和 C. Sutton，“单语句错误的发生频率？” 2020年6月\. [在线]. 可用： http://dx.doi.org/10.1145/3379597.3387491'
- en: '[31] J. Wei, X. Wang, D. Schuurmans, M. Bosma, F. Xia, E. Chi, Q. V. Le, D. Zhou
    *et al.*, “Chain-of-thought prompting elicits reasoning in large language models,”
    *Advances in neural information processing systems*, vol. 35, pp. 24 824–24 837,
    2022.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[31] J. Wei, X. Wang, D. Schuurmans, M. Bosma, F. Xia, E. Chi, Q. V. Le, D.
    Zhou *等人*，“链式思维提示在大型语言模型中引发推理”，*神经信息处理系统进展*，第35卷，第24 824–24 837页，2022年。'
- en: '[32] L. D. Grazia and M. Pradel, “Code search: A survey of techniques for finding
    code,” *ACM Comput. Surv.*, vol. 55, no. 11, pp. 220:1–220:31, 2023. [Online].
    Available: https://doi.org/10.1145/3565971'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[32] L. D. Grazia 和 M. Pradel，“代码搜索：寻找代码的技术综述”，*ACM计算机调查*，第55卷，第11期，第220:1–220:31页，2023年。
    [在线]. 可用： https://doi.org/10.1145/3565971'
- en: '[33] A. Eghbali and M. Pradel, “De-hallucinator: Iterative grounding for llm-based
    code completion,” *CoRR*, vol. abs/2401.01701, 2024\. [Online]. Available: https://doi.org/10.48550/arXiv.2401.01701'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[33] A. Eghbali 和 M. Pradel，“去幻觉器：基于LLM的代码补全的迭代基础”，*计算机研究与技术*，第abs/2401.01701卷，2024年\.
    [在线]. 可用： https://doi.org/10.48550/arXiv.2401.01701'
- en: '[34] J. T. Mark Chen, “Evaluating large language models trained on code,” *CoRR*,
    vol. abs/2107.03374, 2021\. [Online]. Available: https://arxiv.org/abs/2107.03374'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[34] J. T. Mark Chen，“评估基于代码训练的大型语言模型”，*计算机研究与技术*，第abs/2107.03374卷，2021年\.
    [在线]. 可用： https://arxiv.org/abs/2107.03374'
- en: '[35] J. Campos, A. Riboira, A. Perez, and R. Abreu, “Gzoltar: an eclipse plug-in
    for testing and debugging,” in *Proceedings of the 27th IEEE/ACM international
    conference on automated software engineering*, 2012, pp. 378–381.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[35] J. Campos, A. Riboira, A. Perez, 和 R. Abreu，“Gzoltar: 一个用于测试和调试的Eclipse插件”，发表于*第27届IEEE/ACM国际自动化软件工程会议*，2012年，第378-381页。'
- en: '[36] A. Zeller, *Why programs fail: a guide to systematic debugging*.   Elsevier,
    2009.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[36] A. Zeller，*程序为何失败：系统化调试指南*。Elsevier，2009年。'
- en: '[37] H. Ye, M. Martinez, X. Luo, T. Zhang, and M. Monperrus, “Selfapr: Self-supervised
    program repair with test execution diagnostics,” in *ASE 2022, Rochester, MI,
    USA, October 10-14, 2022*.   ACM, 2022, pp. 92:1–92:13\. [Online]. Available:
    https://doi.org/10.1145/3551349.3556926'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[37] H. Ye, M. Martinez, X. Luo, T. Zhang, 和 M. Monperrus，“Selfapr: 基于测试执行诊断的自监督程序修复”，发表于*ASE
    2022，美国密歇根州罗切斯特，2022年10月10-14日*。ACM，2022年，第92:1-92:13页。[在线]. 可用链接: https://doi.org/10.1145/3551349.3556926'
- en: '[38] X. D. Le, D. Lo, and C. Le Goues, “History driven program repair,” in
    *IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering,
    SANER 2016, Suita, Osaka, Japan, March 14-18, 2016 - Volume 1*, 2016, pp. 213–224\.
    [Online]. Available: https://doi.org/10.1109/SANER.2016.76'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[38] X. D. Le, D. Lo, 和 C. Le Goues，“历史驱动的程序修复”，发表于*IEEE第23届国际软件分析、演化与再工程会议，SANER
    2016，日本大阪，2016年3月14-18日，第1卷*，2016年，第213-224页。[在线]. 可用链接: https://doi.org/10.1109/SANER.2016.76'
- en: '[39] Y. Ke, K. T. Stolee, C. Le Goues, and Y. Brun, “Repairing programs with
    semantic code search (t),” in *2015 30th IEEE/ACM International Conference on
    Automated Software Engineering (ASE)*.   IEEE, 2015, pp. 295–306.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[39] Y. Ke, K. T. Stolee, C. Le Goues, 和 Y. Brun，“使用语义代码搜索修复程序(t)”，发表于*2015年第30届IEEE/ACM国际自动化软件工程会议（ASE）*。IEEE，2015年，第295-306页。'
- en: '[40] R. van Tonder and C. L. Goues, “Static automated program repair for heap
    properties,” in *ICSE 2018, Gothenburg, Sweden, May 27 - June 03, 2018*, M. Chaudron,
    I. Crnkovic, M. Chechik, and M. Harman, Eds.   ACM, 2018, pp. 151–162\. [Online].
    Available: https://doi.org/10.1145/3180155.3180250'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[40] R. van Tonder 和 C. L. Goues，“堆属性的静态自动程序修复”，发表于*ICSE 2018，瑞典哥德堡，2018年5月27日-6月3日*，由
    M. Chaudron, I. Crnkovic, M. Chechik, 和 M. Harman 编辑。ACM，2018年，第151-162页。[在线].
    可用链接: https://doi.org/10.1145/3180155.3180250'
- en: '[41] Y. Liu, S. Mechtaev, P. Subotić, and A. Roychoudhury, “Program repair
    guided by datalog-defined static analysis,” in *Proceedings of the 31st ACM Joint
    European Software Engineering Conference and Symposium on the Foundations of Software
    Engineering*, 2023, pp. 1216–1228.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[41] Y. Liu, S. Mechtaev, P. Subotić, 和 A. Roychoudhury，“由datalog定义的静态分析指导的程序修复”，发表于*第31届ACM联合欧洲软件工程会议暨软件工程基础研讨会*，2023年，第1216-1228页。'
- en: '[42] N. Jain, S. Gandhi, A. Sonwane, A. Kanade, N. Natarajan, S. Parthasarathy,
    S. Rajamani, and R. Sharma, “Staticfixer: From static analysis to static repair,”
    2023.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[42] N. Jain, S. Gandhi, A. Sonwane, A. Kanade, N. Natarajan, S. Parthasarathy,
    S. Rajamani, 和 R. Sharma，“Staticfixer: 从静态分析到静态修复”，2023年。'
- en: '[43] D. Yang, X. Mao, L. Chen, X. Xu, Y. Lei, D. Lo, and J. He, “Transplantfix:
    Graph differencing-based code transplantation for automated program repair,” in
    *ASE 2022, Rochester, MI, USA, October 10-14, 2022*.   ACM, 2022, pp. 107:1–107:13\.
    [Online]. Available: https://doi.org/10.1145/3551349.3556893'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[43] D. Yang, X. Mao, L. Chen, X. Xu, Y. Lei, D. Lo, 和 J. He，“Transplantfix:
    基于图差异的代码移植用于自动程序修复”，发表于*ASE 2022，美国密歇根州罗切斯特，2022年10月10-14日*。ACM，2022年，第107:1-107:13页。[在线].
    可用链接: https://doi.org/10.1145/3551349.3556893'
- en: '[44] A. Marginean, J. Bader, S. Chandra, M. Harman, Y. Jia, K. Mao, A. Mols,
    and A. Scott, “Sapfix: Automated end-to-end repair at scale,” in *ICSE-SEIP*,
    2019.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[44] A. Marginean, J. Bader, S. Chandra, M. Harman, Y. Jia, K. Mao, A. Mols,
    和 A. Scott，“Sapfix: 大规模自动化端到端修复”，发表于*ICSE-SEIP*，2019年。'
- en: '[45] K. Wang, R. Singh, and Z. Su, “Search, align, and repair: data-driven
    feedback generation for introductory programming exercises,” in *Proceedings of
    the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation,
    PLDI 2018, Philadelphia, PA, USA, June 18-22, 2018*, 2018, pp. 481–495.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[45] K. Wang, R. Singh, 和 Z. Su，“搜索、对齐和修复：用于入门编程练习的数据驱动反馈生成”，发表于*第39届ACM SIGPLAN编程语言设计与实现会议，PLDI
    2018，美国宾夕法尼亚州费城，2018年6月18-22日*，2018年，第481-495页。'
- en: '[46] R. Gupta, A. Kanade, and S. K. Shevade, “Deep reinforcement learning for
    syntactic error repair in student programs,” in *The Thirty-Third AAAI Conference
    on Artificial Intelligence, AAAI 2019, Honolulu, Hawaii, USA, January 27 - February
    1, 2019*.   AAAI Press, 2019, pp. 930–937\. [Online]. Available: https://doi.org/10.1609/aaai.v33i01.3301930'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[46] R. Gupta, A. Kanade, 和 S. K. Shevade，“用于学生程序的语法错误修复的深度强化学习”，发表于*第三十三届AAAI人工智能会议，AAAI
    2019，美国夏威夷檀香山，2019年1月27日-2月1日*。AAAI出版社，2019年，第930-937页。[在线]. 可用链接: https://doi.org/10.1609/aaai.v33i01.3301930'
- en: '[47] G. Sakkas, M. Endres, P. J. Guo, W. Weimer, and R. Jhala, “Seq2parse:
    neurosymbolic parse error repair,” *Proc. ACM Program. Lang.*, vol. 6, no. OOPSLA2,
    pp. 1180–1206, 2022\. [Online]. Available: https://doi.org/10.1145/3563330'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[47] G. Sakkas, M. Endres, P. J. Guo, W. Weimer, 和 R. Jhala, “Seq2parse: 神经符号解析错误修复，”
    *ACM 程序语言学报*，第6卷，第OOPSLA2期，第1180–1206页，2022年。[在线]。可用链接: https://doi.org/10.1145/3563330'
- en: '[48] T. Yu and M. Pradel, “Pinpointing and repairing performance bottlenecks
    in concurrent programs,” *Empirical Software Engineering (EMSE)*, pp. 1–38, 2017.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[48] T. Yu 和 M. Pradel, “定位和修复并发程序中的性能瓶颈，” *经验软件工程 (EMSE)*，第1–38页，2017年。'
- en: '[49] J. Harer, O. Ozdemir, T. Lazovich, C. P. Reale, R. L. Russell, L. Y. Kim,
    and S. P. Chin, “Learning to repair software vulnerabilities with generative adversarial
    networks,” in *NeurIPS 2018, 3-8 December 2018, Montréal, Canada.*, 2018, pp.
    7944–7954.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[49] J. Harer, O. Ozdemir, T. Lazovich, C. P. Reale, R. L. Russell, L. Y. Kim,
    和 S. P. Chin, “使用生成对抗网络学习修复软件漏洞，” 在 *NeurIPS 2018，2018年12月3-8日，加拿大蒙特利尔*，2018年，第7944–7954页。'
- en: '[50] Y. W. Chow, L. D. Grazia, and M. Pradel, “Pyty: Repairing static type
    errors in python,” in *International Conference on Software Engineering (ICSE)*,
    2024.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[50] Y. W. Chow, L. D. Grazia, 和 M. Pradel, “Pyty: 修复 Python 中的静态类型错误，” 在 *国际软件工程大会
    (ICSE)*，2024年。'
- en: '[51] X. Zhang, J. Zhai, S. Ma, and C. Shen, “AUTOTRAINER: an automatic DNN
    training problem detection and repair system,” in *43rd IEEE/ACM International
    Conference on Software Engineering, ICSE 2021, Madrid, Spain, 22-30 May 2021*.   IEEE,
    2021, pp. 359–371\. [Online]. Available: https://doi.org/10.1109/ICSE43902.2021.00043'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[51] X. Zhang, J. Zhai, S. Ma, 和 C. Shen, “AUTOTRAINER: 一个自动 DNN 训练问题检测和修复系统，”
    在 *第43届 IEEE/ACM 国际软件工程大会，ICSE 2021，西班牙马德里，2021年5月22-30日*。IEEE，2021年，第359–371页。[在线]。可用链接:
    https://doi.org/10.1109/ICSE43902.2021.00043'
- en: '[52] D. Tarlow, S. Moitra, A. Rice, Z. Chen, P. Manzagol, C. Sutton, and E. Aftandilian,
    “Learning to fix build errors with graph2diff neural networks,” in *ICSE ’20 Workshops,
    Seoul, Republic of Korea, 27 June - 19 July, 2020*.   ACM, 2020, pp. 19–20\. [Online].
    Available: https://doi.org/10.1145/3387940.3392181'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[52] D. Tarlow, S. Moitra, A. Rice, Z. Chen, P. Manzagol, C. Sutton, 和 E. Aftandilian,
    “通过 graph2diff 神经网络学习修复构建错误，” 在 *ICSE ’20 研讨会，韩国首尔，2020年6月27日 - 7月19日*。ACM，2020年，第19–20页。[在线]。可用链接:
    https://doi.org/10.1145/3387940.3392181'
- en: '[53] M. Vasic, A. Kanade, P. Maniatis, D. Bieber, and R. Singh, “Neural program
    repair by jointly learning to localize and repair,” in *ICLR*, 2019.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[53] M. Vasic, A. Kanade, P. Maniatis, D. Bieber, 和 R. Singh, “通过联合学习定位和修复的神经程序修复，”
    在 *ICLR*，2019年。'
- en: '[54] H. Ye, M. Martinez, and M. Monperrus, “Neural program repair with execution-based
    backpropagation,” in *ICSE*, 2022.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[54] H. Ye, M. Martinez, 和 M. Monperrus, “通过基于执行的反向传播进行神经程序修复，” 在 *ICSE*，2022年。'
- en: '[55] Q. Zhang, C. Fang, Y. Ma, W. Sun, and Z. Chen, “A survey of learning-based
    automated program repair,” *ACM Transactions on Software Engineering and Methodology*,
    vol. 33, no. 2, pp. 1–69, 2023.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[55] Q. Zhang, C. Fang, Y. Ma, W. Sun, 和 Z. Chen, “基于学习的自动程序修复调查，” *ACM 软件工程与方法学交易*，第33卷，第2期，第1–69页，2023年。'
- en: '[56] H. Joshi, J. P. C. Sánchez, S. Gulwani, V. Le, G. Verbruggen, and I. Radicek,
    “Repair is nearly generation: Multilingual program repair with llms,” in *Thirty-Seventh
    AAAI Conference on Artificial Intelligence, AAAI 2023, Washington, DC, USA, February
    7-14, 2023*, B. Williams, Y. Chen, and J. Neville, Eds.   AAAI Press, 2023, pp.
    5131–5140\. [Online]. Available: https://doi.org/10.1609/aaai.v37i4.25642'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[56] H. Joshi, J. P. C. Sánchez, S. Gulwani, V. Le, G. Verbruggen, 和 I. Radicek,
    “修复几乎是生成: 使用 llms 的多语言程序修复，” 在 *第37届 AAAI 人工智能会议，AAAI 2023，美国华盛顿特区，2023年2月7-14日*，B.
    Williams, Y. Chen 和 J. Neville 主编。AAAI Press，2023年，第5131–5140页。[在线]。可用链接: https://doi.org/10.1609/aaai.v37i4.25642'
- en: '[57] D. Shrivastava, H. Larochelle, and D. Tarlow, “Repository-level prompt
    generation for large language models of code,” in *International Conference on
    Machine Learning*.   PMLR, 2023, pp. 31 693–31 715.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[57] D. Shrivastava, H. Larochelle, 和 D. Tarlow, “代码的大语言模型的库级提示生成，” 在 *国际机器学习大会*。PMLR，2023年，第31,693–31,715页。'
- en: '[58] C. S. Xia, M. Paltenghi, J. L. Tian, M. Pradel, and L. Zhang, “Fuzz4all:
    Universal fuzzing with large language models,” in *ICSE*, 2024.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[58] C. S. Xia, M. Paltenghi, J. L. Tian, M. Pradel, 和 L. Zhang, “Fuzz4all:
    使用大语言模型的通用模糊测试，” 在 *ICSE*，2024年。'
- en: '[59] C. Lemieux, J. P. Inala, S. K. Lahiri, and S. Sen, “Codamosa: Escaping
    coverage plateaus in test generation with pre-trained large language models,”
    in *45th International Conference on Software Engineering, ser. ICSE*, 2023.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[59] C. Lemieux, J. P. Inala, S. K. Lahiri, 和 S. Sen, “Codamosa: 使用预训练的大语言模型突破测试生成中的覆盖率瓶颈，”
    在 *第45届国际软件工程大会，系列 ICSE*，2023年。'
- en: '[60] M. Schäfer, S. Nadi, A. Eghbali, and F. Tip, “An empirical evaluation
    of using large language models for automated unit test generation,” *IEEE Trans.
    Software Eng.*, vol. 50, no. 1, pp. 85–105, 2024. [Online]. Available: https://doi.org/10.1109/TSE.2023.3334955'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[60] M. Schäfer, S. Nadi, A. Eghbali, 和 F. Tip，“使用大型语言模型进行自动化单元测试生成的实证评估”，*IEEE
    Trans. Software Eng.*，卷 50，第 1 期，第 85–105 页，2024年。[在线]. 可用: https://doi.org/10.1109/TSE.2023.3334955'
- en: '[61] G. Ryan, S. Jain, M. Shang, S. Wang, X. Ma, M. K. Ramanathan, and B. Ray,
    “Code-aware prompting: A study of coverage guided test generation in regression
    setting using llm,” in *FSE*, 2024.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[61] G. Ryan, S. Jain, M. Shang, S. Wang, X. Ma, M. K. Ramanathan, 和 B. Ray，“代码感知提示：使用
    llm 在回归设置中进行覆盖指导测试生成的研究”，发表于 *FSE*，2024年。'
- en: '[62] N. Alshahwan, J. Chheda, A. Finegenova, B. Gokkaya, M. Harman, I. Harper,
    A. Marginean, S. Sengupta, and E. Wang, “Automated unit test improvement using
    large language models at meta,” in *FSE*, vol. abs/2402.09171, 2024\. [Online].
    Available: https://doi.org/10.48550/arXiv.2402.09171'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[62] N. Alshahwan, J. Chheda, A. Finegenova, B. Gokkaya, M. Harman, I. Harper,
    A. Marginean, S. Sengupta, 和 E. Wang，“利用大型语言模型在 Meta 上自动化单元测试改进”，发表于 *FSE*，卷 abs/2402.09171，2024年。[在线].
    可用: https://doi.org/10.48550/arXiv.2402.09171'
- en: '[63] S. Kang, J. Yoon, and S. Yoo, “Large language models are few-shot testers:
    Exploring llm-based general bug reproduction,” in *45th IEEE/ACM International
    Conference on Software Engineering, ICSE*, 2023, pp. 2312–2323\. [Online]. Available:
    https://doi.org/10.1109/ICSE48619.2023.00194'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[63] S. Kang, J. Yoon, 和 S. Yoo，“大型语言模型是少量样本测试者：探索基于 llm 的通用错误重现”，发表于 *第45届
    IEEE/ACM 软件工程国际会议（ICSE）*，2023年，第 2312–2323 页。[在线]. 可用: https://doi.org/10.1109/ICSE48619.2023.00194'
- en: '[64] S. Feng and C. Chen, “Prompting is all your need: Automated android bug
    replay with large language models,” in *ICSE*, 2024.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[64] S. Feng 和 C. Chen，“Prompting 是你所需的一切：使用大型语言模型进行自动化 Android 错误重现”，发表于 *ICSE*，2024年。'
- en: '[65] R. Bairi, A. Sonwane, A. Kanade, V. D. C, A. Iyer, S. Parthasarathy, S. Rajamani,
    B. Ashok, and S. Shet, “Codeplan: Repository-level coding using llms and planning,”
    2023.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[65] R. Bairi, A. Sonwane, A. Kanade, V. D. C, A. Iyer, S. Parthasarathy, S.
    Rajamani, B. Ashok, 和 S. Shet，“Codeplan: 使用 llms 和规划进行仓库级编码”，2023年。'
- en: '[66] L. Gao, A. Madaan, S. Zhou, U. Alon, P. Liu, Y. Yang, J. Callan, and G. Neubig,
    “PAL: program-aided language models,” *CoRR*, vol. abs/2211.10435, 2022\. [Online].
    Available: https://doi.org/10.48550/arXiv.2211.10435'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[66] L. Gao, A. Madaan, S. Zhou, U. Alon, P. Liu, Y. Yang, J. Callan, 和 G.
    Neubig，“PAL：程序辅助语言模型”，*CoRR*，卷 abs/2211.10435，2022年。[在线]. 可用: https://doi.org/10.48550/arXiv.2211.10435'
