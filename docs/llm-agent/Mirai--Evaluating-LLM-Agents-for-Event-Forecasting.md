<!--yml
category: 未分类
date: 2025-01-11 12:28:37
-->

# Mirai: Evaluating LLM Agents for Event Forecasting

> 来源：[https://arxiv.org/html/2407.01231/](https://arxiv.org/html/2407.01231/)

\UseTblrLibrary

booktabs ⁰⁰footnotetext: ^∗ Equal Contribution.

Chenchen Ye^(∗1), Ziniu Hu^(∗2), Yihe Deng^(∗1), Zijie Huang¹,
Mingyu Derek Ma¹, Yanqiao Zhu¹, Wei Wang¹
¹University of California, Los Angeles
²California Institute of Technology
[https://mirai-llm.github.io/](https://mirai-llm.github.io/)

###### Abstract

Recent advancements in Large Language Models (LLMs) have empowered LLM agents to autonomously collect world information, over which to conduct reasoning to solve complex problems. Given this capability, increasing interests have been put into employing LLM agents for predicting international events, which can influence decision-making and shape policy development on an international scale. Despite such a growing interest, there is a lack of a rigorous benchmark of LLM agents’ forecasting capability and reliability. To address this gap, we introduce Mirai, a novel benchmark designed to systematically evaluate LLM agents as temporal forecasters in the context of international events. Our benchmark features an agentic environment with tools for accessing an extensive database of historical, structured events and textual news articles. We refine the GDELT¹¹1GDELT: [https://www.gdeltproject.org/](https://www.gdeltproject.org/) event database with careful cleaning and parsing to curate a series of relational prediction tasks with varying forecasting horizons, assessing LLM agents’ abilities from short-term to long-term forecasting. We further implement APIs to enable LLM agents to utilize different tools via a code-based interface. In summary, Mirai comprehensively evaluates the agents’ capabilities in three dimensions: 1) autonomously source and integrate critical information from large global databases; 2) write codes using domain-specific APIs and libraries for tool-use; and 3) jointly reason over historical knowledge from diverse formats and time to accurately predict future events. Through comprehensive benchmarking, we aim to establish a reliable framework for assessing the capabilities of LLM agents in forecasting international events, thereby contributing to the development of more accurate and trustworthy models for international relation analysis.²²2Our dataset is available on [Google Drive](https://drive.google.com/file/d/1xmSEHZ_wqtBu1AwLpJ8wCDYmT-jRpfrN/view?usp=sharing), the code can be found on [GitHub](https://github.com/yecchen/MIRAI), and an interactive demo is provided through a [Google Colab notebook](https://colab.research.google.com/drive/1QyqT35n6NbtPaNtqQ6A7ILG_GMeRgdnO?usp=sharing).

## 1 Introduction

Accurate forecasting of international events is crucial [[1](https://arxiv.org/html/2407.01231v1#bib.bib1)], as understanding the evolution of geopolitical developments enables stakeholders to make informed decisions, mitigate risks, and seize opportunities in the interconnected world. Traditionally, researchers in international relations rely on domain expertise [[2](https://arxiv.org/html/2407.01231v1#bib.bib2), [3](https://arxiv.org/html/2407.01231v1#bib.bib3)]. They conduct detailed analyses of the complex interplay among nations, considering alliances, trade agreements, ideological affinities, and historical rivalries to forecast events such as conflicts, collaborations, or alliance shifts [[4](https://arxiv.org/html/2407.01231v1#bib.bib4)]. With the rapid development of deep learning techniques, forecasting through data-driven neural networks becomes an attractive alternative. Despite their success, current methods rely on single types of information—either structured knowledge graphs [[5](https://arxiv.org/html/2407.01231v1#bib.bib5), [6](https://arxiv.org/html/2407.01231v1#bib.bib6), [7](https://arxiv.org/html/2407.01231v1#bib.bib7)] or textual datasets [[8](https://arxiv.org/html/2407.01231v1#bib.bib8), [9](https://arxiv.org/html/2407.01231v1#bib.bib9)]. Knowledge graphs, although organized, can suffer from incompleteness [[10](https://arxiv.org/html/2407.01231v1#bib.bib10)] or bias [[11](https://arxiv.org/html/2407.01231v1#bib.bib11)], while textual analyses may lack the necessary factual grounding for precise predictions. Moreover, these models are unable to ground their reasoning to historical evidence, which compromises the interpretability and validation of their forecasts. These limitations raise concerns about AI forecasters’ reliability, particularly for high-stake scenarios [[12](https://arxiv.org/html/2407.01231v1#bib.bib12)].

Large Language Model (LLM) agents present a promising path for overcoming these challenges [[13](https://arxiv.org/html/2407.01231v1#bib.bib13), [14](https://arxiv.org/html/2407.01231v1#bib.bib14), [15](https://arxiv.org/html/2407.01231v1#bib.bib15), [16](https://arxiv.org/html/2407.01231v1#bib.bib16), [17](https://arxiv.org/html/2407.01231v1#bib.bib17)]. These advanced AI systems exhibit the potential to mimic human experts by utilizing a diverse array of tools to automatically gather and process information from various sources, including text, knowledge graphs, and numerical data [[18](https://arxiv.org/html/2407.01231v1#bib.bib18), [19](https://arxiv.org/html/2407.01231v1#bib.bib19), [20](https://arxiv.org/html/2407.01231v1#bib.bib20), [21](https://arxiv.org/html/2407.01231v1#bib.bib21)]. Trained on extensive textual data, LLMs [[22](https://arxiv.org/html/2407.01231v1#bib.bib22), [23](https://arxiv.org/html/2407.01231v1#bib.bib23), [24](https://arxiv.org/html/2407.01231v1#bib.bib24), [25](https://arxiv.org/html/2407.01231v1#bib.bib25)] are capable of grasping the subtleties of international relations, reasoning through complex relationships with linguistic explanations, and planning their tool usage effectively [[26](https://arxiv.org/html/2407.01231v1#bib.bib26), [27](https://arxiv.org/html/2407.01231v1#bib.bib27), [28](https://arxiv.org/html/2407.01231v1#bib.bib28), [29](https://arxiv.org/html/2407.01231v1#bib.bib29)]. Such capability opens up new possibilities for developing transparent and interpretable forecasting models that can be further scrutinized and refined.

Despite the immense potential of LLM agents for event forecasting, there is a lack of standardized benchmarks to assess their forecasting abilities in the realm of intricate international events. To address this gap, we introduce Mirai (Multi-Information FoRecasting Agent Interface), a novel benchmarking environment designed to rigorously assess and advance the capabilities of LLM agents for international event forecasting over time. Mirai adapts real-world international event data derived from the Global Database of Events, Language, and Tone (GDELT) [[30](https://arxiv.org/html/2407.01231v1#bib.bib30)] to an event-forecasting task format across different horizons, providing a robust assessment of LLM performance. The framework’s agentic environment enables LLMs to interact with both relational and textual databases through Application Programming Interfaces (APIs), facilitating autonomous information gathering, processing, and application in a contextually relevant manner.

We evaluate both open and closed sourced LLMs on Mirai with ReAct-Style [[31](https://arxiv.org/html/2407.01231v1#bib.bib31)] Agents and “Single Function” and “Code Block” action types. Our extensive experiments revealed: 1) Temporal forecasting tasks are challenging for LLM agents, with the highest-performing GPT-4o agent using full suite of APIs achieves a 29.6 F1 score in second-level relation prediction tasks; while tasks involving long-term and fine-grained event forecasting are even more challenging; 2) The “Code Block” tool-use strategy, which allows more flexible interactions, demands robust code generation capabilities. Notably, GPT-4o is the only model that effectively utilizes and benefits from this strategy. These findings emphasize the need for ongoing research into temporal reasoning and the effective use of tools by LLM agents. We expect that Mirai could serve as a standard benchmark for evaluating LLMs in event forecasting. This would support the development of more precise and reliable models for political analysis, enhancing our understanding of global dynamics.

## 2 The Mirai Benchmark

In this section, we introduce Mirai benchmark from: the specifics of the data and tasks (Sec. [2.1](https://arxiv.org/html/2407.01231v1#S2.SS1 "2.1 Data and Tasks ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")), the implemented agents and environments (Sec. [2.2](https://arxiv.org/html/2407.01231v1#S2.SS2 "2.2 Agents and Environments ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")), and the database construction details (Sec. [2.3](https://arxiv.org/html/2407.01231v1#S2.SS3 "2.3 Database Construction ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")).

### 2.1 Data and Tasks

![Refer to caption](img/6152ffbfdf1e1e863209eaa4ee792833.png)

Figure 1: An example of forecasting the relations between Australia and China on Nov.18.2023\. The database contains query-related historical relations and news articles, while the agent fails to predict the change of relation and makes a wrong forecast.

![Refer to caption](img/9fc5136050d992e768f73cacfa9ea93f.png)

Figure 2: Mirai comprehensively covers global event data. (a) The circular chart shows the relation hierarchy and distribution in Mirai. (b) The heatmap visualizes the intensity of these events globally, distinguishing between areas of conflict (red) and mediation (blue). (c) The heatmap illustrates the frequency of these events, highlighting regions with the most occurrences.

We introduce Mirai, a benchmark crafted for evaluating LLM agents for temporal forecasting in the realm of international events, with tool-use and complex reasoning. We consider forecasting as the process of collecting essential historical data and performing temporal reasoning to anticipate the outcomes of future events.

Formally, we represent an event as ${e}^{t}=(t,s,r,o)$, where $t$ is the timestamp³³3Each timestamp uniquely represents a day, formatted in ”YYYY-MM-DD”. , $s,o\in{\mathcal{C}}$ are respectively the subject and object countries⁴⁴4In this paper, the term ”country” includes all countries, dependent territories, special geographic areas, and their subdivisions. We use the standardized ISO-3166 Alpha-3 codes for country names, such as ”AUS” for Australia and ”CHN” for China, to maintain global consistency. from the country pool ${\mathcal{C}}$, and $r\in{\mathcal{R}}$ denotes the relation type defined by the Conflict and Mediation Event Observations (CAMEO) ontology [[32](https://arxiv.org/html/2407.01231v1#bib.bib32)]⁵⁵5CAMEO is a well-established ontology for categorizing international political events, meticulously developed by experts to enable detailed analysis across multiple levels of granularity.. As shown in Figure [2](https://arxiv.org/html/2407.01231v1#S2.F2 "Figure 2 ‣ 2.1 Data and Tasks ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")a, we incorporate two hierarchical levels from the CAMEO ontology to facilitate a detailed and comprehensive analysis of geopolitical dynamics. The first level includes 20 broad categories, represented by a two-digit code (e.g., “01: Public Statement” or “04: Consult”), which are subdivided into second-level categories identified by a three-digit code that corresponds to its parent category. For example, “03: Express intent to cooperate” is a first-level category that includes 10 different second-level relations such as “036: Express intent to meet or negotiate”. Subsequently, the quadruple “(2023-11-03, AUS, 036, CHN)” denotes that on 3 November 2023, the Australian leader announces a planned visit to China. These relations are also organized along two dimensions, from Verbal to Material and from Conflict to Cooperation, to form a quadratic categorization in the inner circle of Figure [2](https://arxiv.org/html/2407.01231v1#S2.F2 "Figure 2 ‣ 2.1 Data and Tasks ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")a.

Furthermore, a collection of events that happened at the same timestamp ${t}$ form a *timestamped event set* ${\bm{E}}^{t}=\{{e}_{1}^{t},...,{e}_{M}^{t}\}$, where $M$ is the number of unique events at time ${t}$. These events $\{{\bm{E}}^{t}\}_{t=1}^{T}$ can therefore be organized into a temporal graph, with countries as nodes and events’ relations as edges.

The task of event forecasting $(t+l,s,?,o)$ is to predict all the events between a pair of countries $s$ and $o$, happening $l$ days in the future from the current time $t$. Formally, given historical events up to the current time ${\bm{E}}^{\leq t}$, our goal is to forecast future relationships ${\bm{E}}_{s,o}^{t+l}$ between a pair of countries. This includes utilizing events involving third parties, such as interactions with their mutual neighbors.

In the example of Figure [1](https://arxiv.org/html/2407.01231v1#S2.F1 "Figure 1 ‣ 2.1 Data and Tasks ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting"), we demonstrate how to predict which actions Australia will adopt towards China on 18 November 2023 based on all available information up to 17 November 2023. This can also be formatted as a structured query “(2023-11-17 + [1 day], AUS, ?, CHN)”, where the temporal distance of the forecasted event is one day. From the historical events, we can see that the two countries last long-standing tensions; though news show the leader of Australia visited China and agreed to ease tension, this signal does not change the overall tendency, and their relationship keeps being Disapprove and Accuse on certain focuses. Thus, the agent over-relying short-term news and eventually gives the wrong prediction diplomatic cooperation.

### 2.2 Agents and Environments

![Refer to caption](img/36df6777888cdb6f7940ff3e93b766d5.png)

Figure 3: Overview of the LLM agent’s interaction with the multi-source environment using the ReAct strategy for forecasting a query event. The framework consists of three main steps: (1) Think: The agent analyzes the current status and plans the next action based on the query and the provided API specifications. (2) Act: The agent generates a “Single Function” call or a “Code Block” to retrieve and analyze relevant data from the database. (3) Execute: The Python interpreter runs the generated code with the API implementation and database and produces observations. These steps are iteratively performed until the agent reaches a final forecast for the future relation.

Similar to human political analysts, LLM agents must leverage a variety of information sources to make reliable predictions. To this end, we abstract the environment by incorporating coding APIs that facilitate interactions with various knowledge sources. Within this environment, we can develop an LLM agent that employs these APIs through the ReAct strategy [[33](https://arxiv.org/html/2407.01231v1#bib.bib33)], characterized by the iterative steps of think, act, and observe. This structured approach allows the agent to analyze the current situation, retrieve additional data, and observe outcomes to make reliable forecasting.

APIs. We provide a comprehensive set of API to the LLM agent, enabling the execution of the generated codes to access a rich database of historical events and news articles. The API contains the essential data classes and a suite of functions designed to accommodate various types of information within the database. Data classes range from unary types such as date, country, and relation, to composite types like date range, event, and news articles. Functions, executable via standard Python syntax, allow the agent to efficiently query the database through code interface. The design of these functions is characterized in two aspects:

*   •

    Information types. These functions cover various types of information, including country and relation code-name mapping and hierarchy, and count, listing, and distribution of events and news articles. For example, the function map_relation_description_to_cameo takes a relation description and returns a list of the five most likely relations with their respective CAMEO codes, names, and descriptions, providing precise relation information as needed.

*   •

    Search conditions. Additionally, the API functions related to events and news articles include various optional parameters that enable tailored searches based on different criteria. For instance, the function get_event enables searches by specifying conditions like date_range, head_entities, tail_entities, relations, and text_description to fetch events that meet these conditions from the database.

The API specifications and full implementations are shown in Appendix [M](https://arxiv.org/html/2407.01231v1#A13 "Appendix M Additional Information about API ‣ item 1 ‣ L.1.4 Agent ReAct Process ‣ L.1 GPT-4o-based Agent with ReAct and “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting").

Interaction with environment. In Mirai, agents are given the API specifications, which include meticulously documented Python docstrings for all data classes and function definitions, abstracting the underlying implementation details. The environment is equipped with a Python code sandbox with full access to APIs and databases. The agent uses the ReAct strategy in an iterative manner, alternating between think, act, and observe to gather information and perform forecasting. The pipeline is illustrated in Figure [3](https://arxiv.org/html/2407.01231v1#S2.F3 "Figure 3 ‣ 2.2 Agents and Environments ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting").

1.  1.

    Think. Specifically, the agent first thinks about the current situation. If it is confident to deliver a final forecast based on the current information and analysis, it provides the answer and stops the iteration. Otherwise, it further analyzes the current status and plans subsequent actions. In the first step shown in Figure [3](https://arxiv.org/html/2407.01231v1#S2.F3 "Figure 3 ‣ 2.2 Agents and Environments ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting"), the agent plans to first retrieve recent events directly involving the two countries and later verify the details by checking related news articles.

2.  2.

    Act. Next, the agent acts by generating executable codes to interact with the environment. There are two types of action: “Single Function” or “Code Block”. A “Single Function” facilitates straightforward data retrieval, whereas a “Code Block” supports a more flexible and larger action space, accommodating complex control flows such as loops and conditional statements. Also, the agent is allowed to use functions defined in the API and can additionally utilize safe, well-established Python libraries such as numpy, networkx, and scikit-learn. As shown in Figure [3](https://arxiv.org/html/2407.01231v1#S2.F3 "Figure 3 ‣ 2.2 Agents and Environments ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting"), the agent can write either a “Code Block” with an imported library and an inline loop, or a “Single Function” call with targeted countries as the argument value.

3.  3.

    Observe. The environment receives the code generated by the agent, executing it internally using a Python interpreter with full access to API implementations and the database. The output from this execution is then passed to the agent as the content of its ‘Observation’ step. In particular, the agent can observe the corresponding output if its generated code executes successfully; otherwise, it can only observe a specified error message along with the error type. In the figure, the written code is executed, and results are sent back to the agent memory to proceed next iteration.

These ‘Thought’, ‘Action’, and ‘Observation’ from the previous iterations are stored in the agent’s memory base and used as the context of the agent in the next iteration. Additionally, the variables defined in the code generated in any previous action steps are stored and available for future actions. Examples are shown in Appendix [L](https://arxiv.org/html/2407.01231v1#A12 "Appendix L Additional Forecasting Examples of LLM Agent ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting").

### 2.3 Database Construction

Pre-processing. We construct a GDELT-based environment to enable agents’ interaction with both knowledge graph and textual information. Initially, we filtered the dataset for events occurring between Jan. 1, 2023, and Nov. 30, 2023, aligning event dates with their respective news publish dates to avoid information leakage. We standardize the CountryCode to ISO-3166 norms and exclude any entries with missing or outdated codes, and standardize Event codes to the second level of the CAMEO ontology to ensure a consistent and detailed representation. Third-level event codes, which are more noisy and contain more extraction errors were excluded. We also only consider international events. For the news articles, credibility was assessed by counting the daily mentions of each event, with a threshold of at least 50 mentions to filter out unreliable sources. News content, including titles and body text, was then downloaded and cleaned following the OBELICS [[34](https://arxiv.org/html/2407.01231v1#bib.bib34)] protocol, which involved removing low-quality text based on word counts, character and word repetition ratios, and the presence of special characters and flagged words, thereby significantly reducing noise and enhancing the reliability of the textual information stored in our database. We list the details for dataset construction in Appendix [F](https://arxiv.org/html/2407.01231v1#A6 "Appendix F Details of Dataset Construction ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting"). We finalized a collection of 991,759 GDELT event records, corresponding to 59,161 unique $(t,s,r,o)$ events and 296,630 unique news articles. We display our curated events over the world map in Figure [2](https://arxiv.org/html/2407.01231v1#S2.F2 "Figure 2 ‣ 2.1 Data and Tasks ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")b and [2](https://arxiv.org/html/2407.01231v1#S2.F2 "Figure 2 ‣ 2.1 Data and Tasks ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")c, illustrating global coverage and varying intensities of conflict and mediation across regions.

Test query set construction. We construct the test data using records from November 2023, comprising 152,500 GDELT event records and 7385 unique events. To further ensure the data quality and minimize potential extraction errors inherent in GDELT records, we set a higher threshold of at least 100 daily mentions and 5 downloaded news articles for each event. This stricter filtering results in a collection of 2,136 unique $(t,s,r,o)$ events. We construct the test query set based on this collection, which leads to 705 $(t,s,?,o)$ query and answer, where each answer includes a list of relations occurring between the specified subject and object country at time $t$ in this collection. Note that this stricter filtering is only applied for the test query construction and will not remove data from the database. Additionally, we sample 100 queries from the test query set to form a test query subset, ensuring a balanced representation of dates throughout the month, countries across continents, and relations spanning the first-level CAMEO code types.

Evaluation metrics. We instruct the agent to generate final forecasting answer in a JSON dictionary, where keys are predicted two-digit first-level CAMEO codes and the values are lists of predicted three-digit second-level CAMEO codes inherited from the keys. For example, the JSON dictionary “{"01": ["011", "012"], "02": ["023"]}” indicates the first level relation predictions for "01: Make public statement" and "02: Appeal", along with second level relation predictions "011: Decline comment", "012: Make pessimistic comment", and "023: Appeal for material aid". We evaluate these relation predictions by calculating precision, recall, and F1 score between the predicted and ground-truth lists. Moreover, we map the predicted and ground truth relations to their respective binary and quadratic classes (as shown in Figure [2](https://arxiv.org/html/2407.01231v1#S2.F2 "Figure 2 ‣ 2.1 Data and Tasks ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")a). Since each relation in the ground-truth list may belong to different classes, we employ the empirical Kullback-Leibler (KL) divergence of predictions to the ground truth: $D_{\text{KL}}(P||Q)=\sum_{i}P(i)\log\left(\frac{P(i)}{Q(i)}\right)$ to measure the discrepancy, where $P$ and $Q$ represent the frequencies of ground-truth and predicted relations respectively. A lower KL divergence indicates a better alignment of the model’s predictions with the ground-truth list.

## 3 Experiments

Our experiment section begins with comparing the forecasting performance of different agent methods with different prediction horizons (Sec.[3.1](https://arxiv.org/html/2407.01231v1#S3.SS1 "3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")). Moreover, we evaluate agents with different base language models (Sec.[3.2](https://arxiv.org/html/2407.01231v1#S3.SS2 "3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")), and finally analyze several key aspects (Sec.[3.3](https://arxiv.org/html/2407.01231v1#S3.SS3 "3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")) to understand agents’ behavior.

### 3.1 Evaluate Forecasting with Different Agent Methods and Tools

We investigate the effect of different tools (APIs) and agent tool-use strategies. We use gpt-3.5-turbo-0125 [[35](https://arxiv.org/html/2407.01231v1#bib.bib35)] as the base model and evaluate on the 705 queries in the test set. For all experiments, we set the model temperature to $0.4$ and run 5 times to calculate the mean and standard deviation. We provide the detailed prompts in Appendix [K](https://arxiv.org/html/2407.01231v1#A11 "Appendix K Prompts ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting").

Table 1: Experimental results on the test set with different agent tools and the tool-use strategies. The best-performing score is highlighted in bold and the second-best is underlined.

{tblr}

colspec = ccccccccccc, row1-2 = bg=gray!25, row4,7-8 = bg=gray!10 \SetCell[r=2]cAgent \SetCell[c=2]cTool-Use \SetCell[r=2]cBinary
KL ($\Downarrow$) \SetCell[r=2]cQuad
KL ($\Downarrow$) \SetCell[c=3]cFirst-level Relation (%) \SetCell[c=3]cSecond-level Relation (%)
Action Type API Pre. ($\Uparrow$) Rec. ($\Uparrow$) F1 ($\Uparrow$) Pre. ($\Uparrow$) Rec. ($\Uparrow$) F1 ($\Uparrow$)
Direct IO — — 6.5[±1.7] 15.9[±1.5]27.6[±8.1] 19.7[±5.9] 18.8[±6.9] 6.6[±1.5] 5.1[±0.4] 3.5[±0.8]
ZS-COT — — 6.9[±0.8] 10.1[±0.8]27.6[±4.0] 36.0[±4.5] 26.7[±4.1] 10.2[±1.4] 17.4[±1.1] 10.5[±0.7]

\SetCell

[r=2]cReAct Single Function *Event-Only* 33.5[±0.7] 6.7[±0.7]44.3[±3.9] 54.2[±3.9] 41.4[±1.7] 25.3[±2.6] 47.4[±2.4] 26.9[±1.9]

Single Function *News-Only* 6.1[±1.0] 12.8[±0.6]27.8[±3.1] 25.9[±2.9] 21.8[±2.3] 6.3[±2.2] 9.0[±2.0] 5.4[±1.3]

\SetCell

[r=2]cReAct Single Function All 3.1[±0.5] 5.9[±1.0]47.6[±5.8] 58.3[±2.6] 44.2[±4.0] 28.7[±3.9] 51.0[±4.0] 29.6[±3.7]
Code Block All 5.1[±0.9] 8.9[±0.5]27.1[±4.0] 38.6[±2.5] 25.9[±2.2] 11.6[±2.4] 26.3[±2.0] 12.6[±1.7] 

For agent implementations, we consider the following two methods without tool-use:

Direct IO represents the standard LLM chatbot approach that provides answers without tool-use or explicit reasoning. This serves as a baseline to reflect the internal world knowledge of the LLMs when forecasting.

Zero-Shot Chain-of-Thought (ZS-CoT) [[36](https://arxiv.org/html/2407.01231v1#bib.bib36), [37](https://arxiv.org/html/2407.01231v1#bib.bib37)]: In the ZS-CoT variant, we add an instruction prompt to the LLM to encourage explicit step-by-step thinking before making the final prediction.

For Tool-Use agents, We follow ReAct [[31](https://arxiv.org/html/2407.01231v1#bib.bib31)] to interact with our provided environments through an iterative process of thinking, acting, and observing. We implement two variants of ReAct for tool-use: 1) “Single Function” and 2) “Code Block”. Details are discussed in Sec. [2.2](https://arxiv.org/html/2407.01231v1#S2.SS2 "2.2 Agents and Environments ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting").

ReAct agents can utilize tools. We thus implement different variants by restricting their access to utilize 1) *News-Only* APIs; 2) *Event-Only* APIs; 3) *All* data classes and functions.

The experimental results in Table [3.1](https://arxiv.org/html/2407.01231v1#S3.SS1 "3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting") reveal several key insights into agent performance:

1) Mirai presents a challenging task for LLM agents. The best agent (ReAct with “Single Function” using all APIs) for second-level relation predictions achieves a precision of $28.7$ and an F1 score of $29.6$. These results underscore the complexity and difficulty of the temporal forecasting tasks in Mirai and highlight the substantial room for improvement in LLM agents for event forecasting.

2) Predicting fine-grained relations proves more difficult. All models exhibit higher KL divergence for quadratic than binary classes, and lower F1 scores for second-level predictions compared to first-level ones. These findings confirm that predicting fine-grained relation types is more challenging.

3) Diverse tool-use is critical for temporal forecasting. ZS-CoT and Direct-IO, which rely solely on the internal world knowledge of LLMs for forecasting without tool-use, significantly underperform the ReAct agent with full API access to the database. This emphasizes the importance of basing forecasting and reasoning on retrieved historical data and knowledge. In terms of tool types, ReAct agents using *News-Only* APIs perform much worse than agents with *Event-Only* APIs. While news articles provide detailed context for events, they can also introduce noise and lead to issues such as excessively long context, posing additional challenges for LLM agents. Moreover, the agents using both types of information achieve the optimal results.

### 3.2 Evaluate Forecasting with Different Base LLMs

Table 2: Experimental results on the test subset using different base LLMs and action types. The best-performing score is highlighted in bold and the second-best is underlined.

{tblr}

colspec = ccccccccccc, row1-2 = bg=gray!25, row5-6,9-10 = bg=gray!10 \SetCell[r=2]cModel \SetCell[r=2]cTraining Data
Cutoff Date \SetCell[r=2]cAction Type \SetCell[r=2]cBinary
KL ($\Downarrow$) \SetCell[r=2]cQuad
KL ($\Downarrow$) \SetCell[c=3]cFirst-level Relation (%) \SetCell[c=3]cSecond-level Relation (%)
Pre. ($\Uparrow$) Rec. ($\Uparrow$) F1 ($\Uparrow$) Pre. ($\Uparrow$) Rec. ($\Uparrow$) F1 ($\Uparrow$)
\SetCell[r=2]cMistral-7B \SetCell[r=2]c— Single Function 9.6[±2.4] 14.1[±1.9]27.2[±8.2] 13.1[±3.6] 14.4[±3.2] 14.1[±4.4] 7.0[±2.2] 6.6[±2.3]
Code Block 9.0[±3.0] 13.1[±2.3]25.8[±6.9] 10.4[±4.8] 11.1[±3.8] 10.0[±3.8] 5.8[±4.1] 4.6[±1.1]
\SetCell[r=2]cgpt-3.5-turbo \SetCell[r=2]c2021-09 Single Function 3.9[±1.0] 6.7[±1.7]52.6[±9.3] 46.8[±8.5] 38.2[±4.9] 36.7[±9.2] 41.7[±7.6] 27.9[±3.6]
Code Block3.6[±0.7] 8.0[±1.7]32.8[±4.7] 41.0[±2.0] 29.7[±2.9] 14.4[±5.0] 33.7[±5.3] 14.4[±2.6]
\SetCell[r=2]cgpt-4-turbo \SetCell[r=2]c2023-12 Single Function 2.4[±0.6] 6.1[±0.8]55.0[±7.5] 43.9[±7.8] 39.8[±4.9] 33.5[±7.5] 43.5[±5.4] 30.0[±1.9]
Code Block2.0[±1.1] 6.0[±2.0]46.4[±8.7] 51.7[±10.0] 40.0[±8.7] 32.7[±4.9] 43.2[±9.5] 28.7[±5.0]
\SetCell[r=2]cgpt-4o \SetCell[r=2]c2023-10 Single Function 1.8[±1.0] 4.4[±1.8]48.7[±8.7] 63.7[±8.8] 45.5[±4.6] 31.2[±6.7] 59.2[±7.3] 32.6[±2.7]
Code Block1.6[±1.1] 4.3[±1.9]42.3[±9.4] 64.5[±9.5] 44.1[±8.1] 29.1[±7.3] 59.6[±7.6] 32.8[±6.4] 

We then investigate the role of the underlying LLMs in the agent’s performance. We evaluate both open-sourced LLM Mistral-7B-Instruct-v0.2 [[38](https://arxiv.org/html/2407.01231v1#bib.bib38)] (run on a single NVIDIA RTX A6000 GPU), as well as close-sourced LLMs including gpt-3.5-turbo-0125 [[35](https://arxiv.org/html/2407.01231v1#bib.bib35)], gpt-4-turbo-2024-04-09 [[22](https://arxiv.org/html/2407.01231v1#bib.bib22)], and the recently released gpt-4o-2024-05-13 [[39](https://arxiv.org/html/2407.01231v1#bib.bib39)]. Comparisons are done on a data-balanced test subset comprising 100 queries, with all models evaluated under the ReAct framework, allowing access to all APIs. The action types can be either “Single Function” or “Code Block” with a maximum tool call limit set to 20 steps. All models use the same prompt content and structure shown in Appendix [K](https://arxiv.org/html/2407.01231v1#A11 "Appendix K Prompts ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting"). The experimental results are presented in Table [3.2](https://arxiv.org/html/2407.01231v1#S3.SS2 "3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting"), and a further analysis of the agent’s final status is provided in Appendix [J.1](https://arxiv.org/html/2407.01231v1#A10.SS1 "J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting"). We observe the following findings:

1) Code Block benefits stronger LLMs but hurts weaker models: The “Code Block” action type provides greater flexibility than the “Single Function”. However, its benefits are not uniformly achieved across all models. Mistral-7B and gpt-3.5-turbo show reduced performance with Code Block, while stronger models like gpt-4-turbo and gpt-4o gains improvements from it. This indicates that the ability to generate coherent and practical long Code Blocks is a distinguishing factor that determines LLMs as reliable forecasting agents.

2) GPT-4o consistently outperforms other models: gpt-4o, the most recent LLM, consistently achieves the highest performance across different metrics. Notably, for second-level relation prediction, gpt-4o achieves F1 scores of $32.6$ and $32.8$ using “Single Function” and “Code Block”, surpassing all other models including gpt-4-turbo-2024-04-09. This indicates that Mirai is hard enough, and can effectively distinguish different LLMs’ advanced reasoning capabilities.

Can self-consistency make a small model stronger? It is evident that stronger LLMs have better agent performance; however, can we enhance a weaker LLM to achieve comparable forecasting performance using inference-time computation? To explore this, we take Mistral-7B as the base LLM with ReAct using the “Single Function” strategy. For each query, we perform multiple sampling at a temperature of $0.4$. We then consider a variant of self-consistency, which only keeps entries appearing more than twice. We also calculate F1 (Max@K), which assesses the F1 score for each instance and keeps the maximum score across all rounds. As shown in Figure [4](https://arxiv.org/html/2407.01231v1#S3.F4 "Figure 4 ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")a, with more samples, the performance of Mistral-7B significantly improves. Initially, a single sample achieves an F1 score of $6.6$ for Mistral-7B, which is considerably lower than the scores achieved by larger models. However, as more solutions being sampled, the F1 (Max@K) and self-consistency of Mistral-7B improve progressively. By the 10th samples, the Max@K reaches $33.9$, even surpassing gpt-4o. This result highlights the potential of the inference-time search methods like self-consistency to push the boundaries of smaller language models in event forecasting.

Code execution error analysis. Our implemented agents interact with tools via code but often encounter execution error. We summarize the error types for different LLMs in Figure [5](https://arxiv.org/html/2407.01231v1#S3.F5 "Figure 5 ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")b. We can see that invalid dates and invalid attributes are the two most frequent errors, with even gpt-4-turbo exhibiting a frequency of such errors. Notably, gpt-4o makes significantly fewer execution errors. This enhanced code generation capability contributes to its superior performance for event forecasting.

![Refer to caption](img/94e6ee81752b2de9500142a8ccdcfec6.png)![Refer to caption](img/d417f68419b96ee484bdbadbc5507cf5.png)

Figure 4: a) Self-consistency of Mistral-7B model increases with more samples. b) F1 scores of different base LLM agents on relation prediction, categorized based on the quadratic classes.

![Refer to caption](img/609af8210bc5322c4d43c5fe1fb1f18b.png)![Refer to caption](img/96a798bd9c08f723093b7c358a617e7a.png)

Figure 5: a) F1 Accuracy for each API function. b) Code execution error analysis for different LLMs.

### 3.3 Analyzing Agent Behaviours

![Refer to caption](img/1e44ba62ae59e88700b6205f05c83ff7.png)![Refer to caption](img/cacadb53d9ae0a6ef369cf26e03e58ff.png)

Figure 6: Evaluation of LLM Agents in different temporal distances of the forecasting event.

![Refer to caption](img/348f316ec56a7b51b60dd0716359733d.png)![Refer to caption](img/01f895d611a500b082ecbcc0ce89a8ed.png)

Figure 7: Action order analysis in LLM agents. a) Tool-Use Transition Graph of called API functions. Edge thickness indicates transition frequency. b) Freq.(correct) - Freq.(incorrect), in which red (blue) edges indicate positive (negative) contributions.

Impact of temporal distance of the forecasting target. Our defined event forecasting task varies by temporal distance $l$, which specifies how far into the future we want to predict. We thus conduct an ablation study with $l$ set to 1, 7, 30, and 90 days. Specifically, we fix the query event date and limit the accessible data to $l$ days prior to the query event date. The experimental results depicted in Figure [6](https://arxiv.org/html/2407.01231v1#S3.F6 "Figure 6 ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting") reveal a clear trend: as the temporal distance increases, the F1 score decreases and KL-divergence increases. This indicates that the agent’s ability to provide accurate predictions diminishes for events further in the future. When the temporal distance is small, such as 1 or 7 days, the agent has access to more recent and relevant information, providing a strong signal (e.g., human experts’ analysis) for making accurate predictions. Thus, to comprehensively benchmark the forecasting capabilities of LLM agents, we should focus on long-term predictions such as those spanning 30 or 90 days. These longer durations require the agents to capture and anticipate potential trend shifts, which may be influenced by a broader range of factors and more complex dependencies.

Forecasting accuracy on different relation types. We further split the datasets into distinct quadratic relation classes and compute the F1 score for each class, as illustrated in Figure [4](https://arxiv.org/html/2407.01231v1#S3.F4 "Figure 4 ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")b. The results show that all models exhibit significantly higher performance for “verbal cooperation” and “material conflict”, while lower in the other two categories. Several factors contribute to these observations. First, “verbal cooperation” events are more prevalent in the dataset, allowing the model to retrieve more such historical events. Second, “material conflicts” has a consistent pattern of extended duration within the same set of countries. Conversely, events categorized under “material cooperation” and “verbal conflicts”, such as “057: Sign formal agreement” and “084: Return or release”, tend to be more abrupt and unpredictable, demanding subtle trend analysis and contextual knowledge, leading to lower performance in these categories. These observations highlight the need for LLMs capable of understanding the nuances and complexities of different event types.

How tool-use ordering influences forecasting. We further investigate the impact of action order on the GPT-4o agent in “Single Function” mode. Figure [7](https://arxiv.org/html/2407.01231v1#S3.F7 "Figure 7 ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting") shows the transition graph from the initial query to the correct final answer, with thicker edges indicating more frequent transitions. Typically, the agent begins with get_relation_distribution or get_event to gather an initial set of recent and frequent events for key information, and often concludes with browse_news_article and get_news_articles, which retrieve news content to make accurate forecasts. To further understand whether each function helps forecasting, we subtract the frequency of incorrect predictions from those of correct predictions, as shown in Figure [7](https://arxiv.org/html/2407.01231v1#S3.F7 "Figure 7 ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")b. Here, red edges represent sequences typically leading to accurate outcomes, and blue edges indicate error-prone paths. Actions like browse_news_article and get_entity_distribution typically result in correct answers more frequently. Notably, get_news_articles has a direct blue link to the answer, suggesting that this function leads more often to incorrect answers because it only returns news titles, which are too vague for accurate prediction. However, when followed by browse_news_article and then providing the answer, the agent is more likely to produce correct outcomes. Similar patterns are observed with get_event, where adding get_entity_distribution turns a negative link to a positive one to the answer. Figure [5](https://arxiv.org/html/2407.01231v1#S3.F5 "Figure 5 ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")a further demonstrates how each function contributes to the final performance, showing that for the first-level prediction, get_{child/sibling}_relation are more useful. These results emphasize the importance for strategic action planning in LLM agents for effective temporal forecasting.

## 4 Related Work

Table 3: Comparison of Mirai with other temporal reasoning benchmarks. “Method” refers to the methodology of original and recent models evaluated on the benchmark. ICL stands for LLM w/ In-Context Learning, FT stands for Task-Specific Fine-Tuning.

{tblr}

colspec = ccccccccc, row1-2 = bg=gray!25, roweven[3-13] = bg=gray!5 \SetCell[r=2]cBenchmark \SetCell[c=2]cTemporal Reasoning \SetCell[r=2]cTask Format \SetCell[c=3]cInformation \SetCell[r=2]cMethod
Understanding Forecasting Time Series KG Textual API
TempQuestions [[40](https://arxiv.org/html/2407.01231v1#bib.bib40)] ✓ KGQA ✓ KGQA Systems
CRONQuestions [[41](https://arxiv.org/html/2407.01231v1#bib.bib41)] ✓ KGQA ✓ Bert-based FT
TempoQR [[42](https://arxiv.org/html/2407.01231v1#bib.bib42)] ✓ KGQA ✓ Bert-based FT
TORQUE [[43](https://arxiv.org/html/2407.01231v1#bib.bib43)] ✓ QA ✓ Bert-based FT
TempReason [[44](https://arxiv.org/html/2407.01231v1#bib.bib44)] ✓ QA ✓ ✓ ICL + Task-specific FT
TRAM [[45](https://arxiv.org/html/2407.01231v1#bib.bib45)] ✓ MCQ ✓ ICL + Bert-based FT
TCELongBench [[46](https://arxiv.org/html/2407.01231v1#bib.bib46)] ✓ ✓ Ordering QA; MCQ ✓ ICL
ForecastQA [[47](https://arxiv.org/html/2407.01231v1#bib.bib47)] ✓ MCQ ✓ Bert-based FT
Approach [[48](https://arxiv.org/html/2407.01231v1#bib.bib48)] ✓ QA ✓ ICL
IntervalQA [[8](https://arxiv.org/html/2407.01231v1#bib.bib8)] ✓ Numerical QA; MCQ ✓✓ ICL
TKGs [[49](https://arxiv.org/html/2407.01231v1#bib.bib49), [30](https://arxiv.org/html/2407.01231v1#bib.bib30)] ✓ Link Prediction ✓ Graph FT + ICL + Task-specific FT
Mirai ✓ Relation List ✓✓ ✓LLM Agent 

In recent years, various benchmarks have been developed to evaluate temporal reasoning capabilities in AI systems, focusing primarily on question answering and link prediction. Mirai distinguishes itself by assessing LLMs in the forecasting task, and further employing a relational task format, incorporating diverse information sources of knowledge graphs, text, and code-based APIs, and utilizing an agent-based methodology that supports intermediate reasoning steps. We summarize our differences to these existing benchmarks in Table [4](https://arxiv.org/html/2407.01231v1#S4 "4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting"), and provide further discussions from the following aspects and more in Appendix [D](https://arxiv.org/html/2407.01231v1#A4 "Appendix D Additional related work ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting").

### 4.1 Temporal Reasoning Benchmarks

Many benchmarks sensing the temporal reasoning ability of AI models have been constructed, but they have different focuses and settings with Mirai, particularly in terms of task, information, and method, as shown in Table [4](https://arxiv.org/html/2407.01231v1#S4 "4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting"). One line of benchmarks focuses on the temporal understanding ability of the model [[40](https://arxiv.org/html/2407.01231v1#bib.bib40), [41](https://arxiv.org/html/2407.01231v1#bib.bib41), [42](https://arxiv.org/html/2407.01231v1#bib.bib42), [43](https://arxiv.org/html/2407.01231v1#bib.bib43), [44](https://arxiv.org/html/2407.01231v1#bib.bib44), [45](https://arxiv.org/html/2407.01231v1#bib.bib45)], such as understanding the temporal relations between available facts in knowledge graphs (KGs) or text, either a short piece of text or a document corpus. While the temporal forecasting task largely differs from understanding, where the reasoning target is unseen in the database for the model, and as such, the model has to not only understand but to reason. For forecasting, there are two main task formulations among previous benchmarks: the QA task format for benchmarks with history information represented in textual format [[8](https://arxiv.org/html/2407.01231v1#bib.bib8), [46](https://arxiv.org/html/2407.01231v1#bib.bib46), [47](https://arxiv.org/html/2407.01231v1#bib.bib47), [48](https://arxiv.org/html/2407.01231v1#bib.bib48), [50](https://arxiv.org/html/2407.01231v1#bib.bib50)], and graph link prediction task format for temporal knowledge graph(TKG)-based benchmarks [[49](https://arxiv.org/html/2407.01231v1#bib.bib49), [30](https://arxiv.org/html/2407.01231v1#bib.bib30)]. However, the uniformat of information sources either lacks of support to clearly structural facts or contextual detail for the model to perform advanced reasoning, while in Mirai, we provide both information sources. Additionally, we provide carefully constructed API with various data classes and functions that access to various part of the data. With the flexibility provided by code generation, the model is exposed to a broader and more flexible range of information. More importantly, Mirai distinguishes itself by introducing an agentic environment specifically designed to evaluate LLM agents in the forecasting task. This represents a significant departure from previous work, which has not explored or even considered the potential of performing temporal forecasting tasks using LLM agents.

### 4.2 Evaluation of Language Agents

Previous research has investigated the performance of LLM agents in a variety of domains, including arithmetic reasoning focused on obtaining correct solutions [[51](https://arxiv.org/html/2407.01231v1#bib.bib51), [52](https://arxiv.org/html/2407.01231v1#bib.bib52), [53](https://arxiv.org/html/2407.01231v1#bib.bib53)], proficiency assessment in utilizing tools and reporting results [[54](https://arxiv.org/html/2407.01231v1#bib.bib54), [55](https://arxiv.org/html/2407.01231v1#bib.bib55), [56](https://arxiv.org/html/2407.01231v1#bib.bib56)], evaluation of web navigation skills to find specific websites [[57](https://arxiv.org/html/2407.01231v1#bib.bib57), [58](https://arxiv.org/html/2407.01231v1#bib.bib58), [59](https://arxiv.org/html/2407.01231v1#bib.bib59)], and planning travel itineraries under given constraints [[60](https://arxiv.org/html/2407.01231v1#bib.bib60)]. However, these evaluations do not fully address the challenges posed by tasks involving complex international events with diverse information formats and temporal attributes. Mirai presents a unique task in this context, where the agent must navigate and reason over the structured events and textual news articles with temporal information. This setup requires the agent to effectively handle multilateral relationships and information spanning different time periods. Furthermore, Mirai assesses the LLM agent’s ability to reason and predict information that not be directly available in the provided database. This adds an additional layer of complexity, as the agent must leverage its understanding of the available information to make informed predictions about future events or fill in missing details. By evaluating LLM agents in this challenging setting, Mirai provides valuable insights into their capacity to process and reason over complex, temporally-structured information and their ability to generate accurate predictions based on incomplete data.

### 4.3 LLMs for Tool-Use

Large Language Models (LLMs) have demonstrated remarkable language understanding [[61](https://arxiv.org/html/2407.01231v1#bib.bib61)] and reasoning capabilities [[62](https://arxiv.org/html/2407.01231v1#bib.bib62)]. However, they also possess inherent limitations, such as their inability to provide up-to-date responses based on external knowledge or to perform complex mathematical reasoning. In response to these challenges, recent advancements have seen the integration of LLMs with various external tools [[63](https://arxiv.org/html/2407.01231v1#bib.bib63)]. Notable examples include TALM [[64](https://arxiv.org/html/2407.01231v1#bib.bib64)] and ToolFormer [[65](https://arxiv.org/html/2407.01231v1#bib.bib65)], which utilize in-context learning to enhance the model’s ability to leverage different tools in tasks like question answering and mathematical reasoning. Chameleon [[66](https://arxiv.org/html/2407.01231v1#bib.bib66)] employs an LLM as a natural language planner to deduce the optimal sequence of tools to be used, subsequently executing these tools to generate the final output. AVIS [[67](https://arxiv.org/html/2407.01231v1#bib.bib67)] employs dynamic tree search to synthesize the most effective tool-use sequence. ToolkenGPT [[68](https://arxiv.org/html/2407.01231v1#bib.bib68)] integrates tool-use operators as special tokens and trains the model through sequence-to-sequence training. ToolLLM [[69](https://arxiv.org/html/2407.01231v1#bib.bib69)] introduces an instruction tuning dataset encompassing over 16,000 real-world APIs, significantly enhancing the model’s capability to utilize these tools effectively.

## 5 Conclusion and Limitation

In conclusion, we introduce Mirai, a benchmark constructed for evaluating LLM agents in temporal forecasting international event with tools (APIs) to access an extensive historical event and news database. The results reveals the complexity and difficulty for current LLM Agents in generating contextually and syntax-wise correct code and performing complex temporal reasoning over the multi-party and multi-timestamped data for an effective prediction, highlighting a substantial space for further effects in this direction.

Our work also has several limitations: 1) Only a few representative LLMs were tested, leaving broader evaluations with more open-sourced models; 2) The current API is basic, primarily providing functions for counting, listing, and statistical distribution. Future enhancements could include time series analysis and the ability for agents to add new functions for more comprehensive analysis. 3) The study was limited by cost of API usage, so we only conduct small number of experimental rounds and result in high variance. More extensive testing is suggested for future studies to achieve more stable results. Full discussion of limitation can be found in Appendix [C](https://arxiv.org/html/2407.01231v1#A3 "Appendix C Limitations ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting"). In the future, we plan to incorporate APIs to support more knowledge sources such as time-series and multimodal information, and consider testing more open-source LLMs and agent architectures.

## Acknowledgements

Research was supported in part by NIH U24DK097771, U54HG012517, NSF 1829071, 2106859, 2119643, 2200274, 2202693, and 2312501, DARPA HR00112490370, and Optum Lab.

## References

*   Brown and Lee [2018] Thomas Brown and Susan Lee. Predictive analytics in economic sanctions and international policy. *Journal of International Economics*, 26(4):311–330, 2018.
*   Smith and Doe [2020] Johnathan Smith and Jane Doe. Geopolitical risk assessment in international relations. *Journal of Global Politics*, 15(3):200–225, 2020.
*   Johnson and Roberts [2019] Emily Johnson and Mark Roberts. The role of diplomacy in shaping foreign policy. *Diplomatic Review*, 12(2):145–170, 2019.
*   Davis and Nguyen [2017] Richard Davis and Anh Nguyen. Strategic alliances and predictive diplomacy: A review of historical data. *Political Science Quarterly*, 132(1):45–72, 2017.
*   Mahdisoltani et al. [2015] Farzaneh Mahdisoltani, Joanna Biega, and Fabian M Suchanek. YAGO3: A Knowledge Base from Multilingual Wikipedias. January 2015. CIDR 2015.
*   Jin et al. [2020a] Woojeong Jin, Meng Qu, Xisen Jin, and Xiang Ren. Recurrent Event Network: Autoregressive Structure Inference over Temporal Knowledge Graphs, October 2020a. EMNLP 2020.
*   Li et al. [2021a] Zixuan Li, Xiaolong Jin, Wei Li, Saiping Guan, Jiafeng Guo, Huawei Shen, Yuanzhuo Wang, and Xueqi Cheng. Temporal Knowledge Graph Reasoning Based on Evolutional Representation Learning, April 2021a. SIGIR 2021.
*   Zou et al. [2022] Andy Zou, Tristan Xiao, Ryan Jia, Joe Kwon, Mantas Mazeika, Richard Li, Dawn Song, Jacob Steinhardt, Owain Evans, and Dan Hendrycks. Forecasting Future World Events with Neural Networks. arXiv, October 2022. NeurIPS 2022.
*   Reddy et al. [2023] Revanth Gangi Reddy, Yi R. Fung, Qi Zeng, Manling Li, Ziqi Wang, Paul Sullivan, and Heng Ji. SmartBook: AI-Assisted Situation Report Generation, March 2023. arXiv.
*   Galárraga et al. [2017] Luis Galárraga, Simon Razniewski, Antoine Amarilli, and Fabian M. Suchanek. Predicting completeness in knowledge bases. In Maarten de Rijke, Milad Shokouhi, Andrew Tomkins, and Min Zhang, editors, *Proceedings of the Tenth ACM International Conference on Web Search and Data Mining, WSDM 2017, Cambridge, United Kingdom, February 6-10, 2017*, pages 375–383\. ACM, 2017.
*   Huang et al. [2024] Zijie Huang, Jeehyun Hwang, Junkai Zhang, Jinwoo Baik, Weitong Zhang, Dominik Wodarz, Yizhou Sun, Quanquan Gu, and Wei Wang. Causal graph ODE: continuous treatment effect modeling in multi-agent dynamical systems. In Tat-Seng Chua, Chong-Wah Ngo, Ravi Kumar, Hady W. Lauw, and Roy Ka-Wei Lee, editors, *Proceedings of the ACM on Web Conference 2024, WWW 2024, Singapore, May 13-17, 2024*, pages 4607–4617\. ACM, 2024.
*   Mclean et al. [2009] Dr Mclean, Alan Patterson, and John Williams. Risk assessment, policy-making and the limits of knowledge: The precautionary principle and international relations. *International Relations*, 23:548–566, 12 2009.
*   Sumers et al. [2024] Theodore R. Sumers, Shunyu Yao, Karthik Narasimhan, and Thomas L. Griffiths. Cognitive Architectures for Language Agents, March 2024. arXiv:2309.02427 [cs].
*   Liu et al. [2023a] Xiao Liu, Hao Yu, Hanchen Zhang, Yifan Xu, Xuanyu Lei, Hanyu Lai, Yu Gu, Hangliang Ding, Kaiwen Men, Kejuan Yang, Shudan Zhang, Xiang Deng, Aohan Zeng, Zhengxiao Du, Chenhui Zhang, Sheng Shen, Tianjun Zhang, Yu Su, Huan Sun, Minlie Huang, Yuxiao Dong, and Jie Tang. AgentBench: Evaluating LLMs as Agents, October 2023a. arXiv:2308.03688 [cs].
*   Weng [2023] Lilian Weng. LLM Powered Autonomous Agents, June 2023. Section: posts.
*   [16] AutoGPT Documentation.
*   Wang et al. [2023] Guanzhi Wang, Yuqi Xie, Yunfan Jiang, Ajay Mandlekar, Chaowei Xiao, Yuke Zhu, Linxi Fan, and Anima Anandkumar. Voyager: An Open-Ended Embodied Agent with Large Language Models, October 2023. arXiv:2305.16291 [cs].
*   Shen et al. [2023] Yongliang Shen, Kaitao Song, Xu Tan, Dongsheng Li, Weiming Lu, and Yueting Zhuang. HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in Hugging Face, December 2023. arXiv:2303.17580 [cs].
*   Lu et al. [2023a] Pan Lu, Baolin Peng, Hao Cheng, Michel Galley, Kai-Wei Chang, Ying Nian Wu, Song-Chun Zhu, and Jianfeng Gao. Chameleon: Plug-and-Play Compositional Reasoning with Large Language Models, October 2023a. arXiv:2304.09842 [cs].
*   Zhuang et al. [2023a] Yuchen Zhuang, Yue Yu, Kuan Wang, Haotian Sun, and Chao Zhang. ToolQA: A Dataset for LLM Question Answering with External Tools, June 2023a. arXiv:2306.13304 [cs].
*   Li et al. [2023a] Minghao Li, Yingxiu Zhao, Bowen Yu, Feifan Song, Hangyu Li, Haiyang Yu, Zhoujun Li, Fei Huang, and Yongbin Li. API-Bank: A Comprehensive Benchmark for Tool-Augmented LLMs, October 2023a. arXiv:2304.08244 [cs].
*   Achiam et al. [2023] Josh Achiam, Steven Adler, Sandhini Agarwal, Lama Ahmad, Ilge Akkaya, Florencia Leoni Aleman, Diogo Almeida, Janko Altenschmidt, Sam Altman, Shyamal Anadkat, et al. Gpt-4 technical report. *arXiv preprint arXiv:2303.08774*, 2023.
*   Anthropic [2023] Anthropic. Claude: An ai assistant by anthropic, 2023.
*   DeepMind [2023] Google DeepMind. Gemini: An ai model by google deepmind, 2023.
*   Touvron et al. [2023] Hugo Touvron, Thibaut Lavril, Gautier Izacard, Xavier Martinet, Marie-Anne Lachaux, Timothée Lacroix, Baptiste Roziere, Naman Goyal, Eric Hambro, Faisal Azhar, et al. Llama: Open and efficient foundation language models, 2023.
*   Yuan et al. [2023] Siyu Yuan, Jiangjie Chen, Ziquan Fu, Xuyang Ge, Soham Shah, Charles Robert Jankowski, Yanghua Xiao, and Deqing Yang. Distilling Script Knowledge from Large Language Models for Constrained Language Planning, May 2023. arXiv:2305.05252 [cs].
*   Liu et al. [2023b] Bo Liu, Yuqian Jiang, Xiaohan Zhang, Qiang Liu, Shiqi Zhang, Joydeep Biswas, and Peter Stone. LLM+P: Empowering Large Language Models with Optimal Planning Proficiency, September 2023b. arXiv:2304.11477 [cs].
*   Valmeekam et al. [2023] Karthik Valmeekam, Matthew Marquez, Alberto Olmo, Sarath Sreedharan, and Subbarao Kambhampati. PlanBench: An Extensible Benchmark for Evaluating Large Language Models on Planning and Reasoning about Change, November 2023. arXiv:2206.10498 [cs].
*   Ma et al. [2023a] Yunshan Ma, Chenchen Ye, Zijian Wu, Xiang Wang, Yixin Cao, and Tat-Seng Chua. Context-aware Event Forecasting via Graph Disentanglement. In *Proceedings of the 29th ACM SIGKDD Conference on Knowledge Discovery and Data Mining*, pages 1643–1652, August 2023a. KDD 2023.
*   Leetaru and Schrodt [2013] Kalev Leetaru and Philip A Schrodt. GDELT: Global Data on Events, Location and Tone,. 2013.
*   Yao et al. [2023a] Shunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran, Karthik R. Narasimhan, and Yuan Cao. React: Synergizing reasoning and acting in language models. In *The Eleventh International Conference on Learning Representations, ICLR 2023, Kigali, Rwanda, May 1-5, 2023*. OpenReview.net, 2023a.
*   Boschee et al. [2015a] Elizabeth Boschee, Jennifer Lautenschlager, Sean O’Brien, Steve Shellman, James Starz, and Michael Ward. Cameo.cdb.09b5.pdf. In *ICEWS Coded Event Data*. Harvard Dataverse, 2015a.
*   Yao et al. [2023b] Shunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran, Karthik Narasimhan, and Yuan Cao. ReAct: Synergizing Reasoning and Acting in Language Models, March 2023b. arXiv:2210.03629 [cs].
*   Laurençon et al. [2023] Hugo Laurençon, Lucile Saulnier, Léo Tronchon, Stas Bekman, Amanpreet Singh, Anton Lozhkov, Thomas Wang, Siddharth Karamcheti, Alexander M. Rush, Douwe Kiela, Matthieu Cord, and Victor Sanh. OBELICS: an open web-scale filtered dataset of interleaved image-text documents. In Alice Oh, Tristan Naumann, Amir Globerson, Kate Saenko, Moritz Hardt, and Sergey Levine, editors, *Advances in Neural Information Processing Systems 36: Annual Conference on Neural Information Processing Systems 2023, NeurIPS 2023, New Orleans, LA, USA, December 10 - 16, 2023*, 2023.
*   gpt [2023] GPT-3.5-Turbo, [https://platform.openai.com/docs/models/gpt-3-5-turbo](https://platform.openai.com/docs/models/gpt-3-5-turbo), 2023.
*   Wei et al. [2023] Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Brian Ichter, Fei Xia, Ed Chi, Quoc Le, and Denny Zhou. Chain-of-Thought Prompting Elicits Reasoning in Large Language Models, January 2023. arXiv:2201.11903 [cs].
*   Kojima et al. [2022] Takeshi Kojima, Shixiang Shane Gu, Machel Reid, Yutaka Matsuo, and Yusuke Iwasawa. Large language models are zero-shot reasoners. In Sanmi Koyejo, S. Mohamed, A. Agarwal, Danielle Belgrave, K. Cho, and A. Oh, editors, *Advances in Neural Information Processing Systems 35: Annual Conference on Neural Information Processing Systems 2022, NeurIPS 2022, New Orleans, LA, USA, November 28 - December 9, 2022*, 2022.
*   Jiang et al. [2023] Albert Q. Jiang, Alexandre Sablayrolles, Arthur Mensch, Chris Bamford, Devendra Singh Chaplot, Diego de las Casas, Florian Bressand, Gianna Lengyel, Guillaume Lample, Lucile Saulnier, Lélio Renard Lavaud, Marie-Anne Lachaux, Pierre Stock, Teven Le Scao, Thibaut Lavril, Thomas Wang, Timothée Lacroix, and William El Sayed. Mistral 7b, 2023.
*   gpt [2024] Gpt-4o contributions. 2024.
*   Jia et al. [2018] Zhen Jia, Abdalghani Abujabal, Rishiraj Saha Roy, Jannik Strötgen, and Gerhard Weikum. TempQuestions: A Benchmark for Temporal Question Answering. In *Companion Proceedings of the The Web Conference 2018*, WWW ’18, pages 1057–1062, Republic and Canton of Geneva, CHE, April 2018\. International World Wide Web Conferences Steering Committee. ISBN 978-1-4503-5640-4. WWW 2018.
*   Saxena et al. [2021] Apoorv Saxena, Soumen Chakrabarti, and Partha Talukdar. Question Answering Over Temporal Knowledge Graphs. In *Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing (Volume 1: Long Papers)*, pages 6663–6676, Online, August 2021\. Association for Computational Linguistics. ACL 2021.
*   Mavromatis et al. [2021] Costas Mavromatis, Prasanna Lakkur Subramanyam, Vassilis N. Ioannidis, Soji Adeshina, Phillip R. Howard, Tetiana Grinberg, Nagib Hakim, and George Karypis. TempoQR: Temporal Question Reasoning over Knowledge Graphs. arXiv, December 2021. AAAI 2022.
*   Ning et al. [2020a] Qiang Ning, Hao Wu, Rujun Han, Nanyun Peng, Matt Gardner, and Dan Roth. TORQUE: A Reading Comprehension Dataset of Temporal Ordering Questions. In *Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP)*, pages 1158–1172, Online, November 2020a. Association for Computational Linguistics. EMNLP 2020.
*   Tan et al. [2023a] Qingyu Tan, Hwee Tou Ng, and Lidong Bing. Towards Benchmarking and Improving the Temporal Reasoning Capability of Large Language Models. In *Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)*, pages 14820–14835, Toronto, Canada, July 2023a. Association for Computational Linguistics. ACL 2023.
*   Wang and Zhao [2024] Yuqing Wang and Yun Zhao. TRAM: Benchmarking Temporal Reasoning for Large Language Models, May 2024. arXiv:2310.00835 [cs].
*   Zhang et al. [2024] Zhihan Zhang, Yixin Cao, Chenchen Ye, Yunshan Ma, Lizi Liao, and Tat-Seng Chua. Analyzing Temporal Complex Events with Large Language Models? A Benchmark towards Temporal, Long Context Understanding, June 2024. arXiv:2406.02472 [cs].
*   Jin et al. [2021] Woojeong Jin, Rahul Khanna, Suji Kim, Dong-Ho Lee, Fred Morstatter, Aram Galstyan, and Xiang Ren. ForecastQA: A Question Answering Challenge for Event Forecasting with Temporal Text Data. In *Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing (Volume 1: Long Papers)*, pages 4636–4650, Online, August 2021\. Association for Computational Linguistics. ACL 2021.
*   Halawi et al. [2024] Danny Halawi, Fred Zhang, Chen Yueh-Han, and Jacob Steinhardt. Approaching Human-Level Forecasting with Language Models, February 2024. URL [http://arxiv.org/abs/2402.18563](http://arxiv.org/abs/2402.18563). arXiv:2402.18563 [cs].
*   Boschee et al. [2015b] Elizabeth Boschee, Jennifer Lautenschlager, Sean O’Brien, Steve Shellman, James Starz, and Michael Ward. Icews coded event data, 2015b.
*   Schoenegger et al. [2024] Philipp Schoenegger, Indre Tuminauskaite, Peter S. Park, and Philip E. Tetlock. Wisdom of the Silicon Crowd: LLM Ensemble Prediction Capabilities Rival Human Crowd Accuracy, May 2024. URL [http://arxiv.org/abs/2402.19379](http://arxiv.org/abs/2402.19379). arXiv:2402.19379 [cs].
*   Roy and Roth [2015] Subhro Roy and Dan Roth. Solving general arithmetic word problems. In *Proceedings of EMNLP*, 2015.
*   Cobbe et al. [2021] Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro Nakano, et al. Training verifiers to solve math word problems. *arXiv preprint arXiv:2110.14168*, 2021.
*   Patel et al. [2021] Arkil Patel, Satwik Bhattamishra, and Navin Goyal. Are NLP models really able to solve simple math word problems? In *Proceedings of NAACL*, 2021.
*   Li et al. [2023b] Minghao Li, Yingxiu Zhao, Bowen Yu, Feifan Song, Hangyu Li, Haiyang Yu, Zhoujun Li, Fei Huang, and Yongbin Li. Api-bank: A comprehensive benchmark for tool-augmented llms. In *Proceedings of EMNLP*, 2023b.
*   Xu et al. [2023a] Qiantong Xu, Fenglu Hong, Bo Li, Changran Hu, Zhengyu Chen, and Jian Zhang. On the tool manipulation capability of open-source large language models. *arXiv preprint arXiv:2305.16504*, 2023a.
*   Zhuang et al. [2023b] Yuchen Zhuang, Yue Yu, Kuan Wang, Haotian Sun, and Chao Zhang. ToolQA: A dataset for LLM question answering with external tools. In *Proceedings of NeurIPS*, 2023b.
*   Deng et al. [2023] Xiang Deng, Yu Gu, Boyuan Zheng, Shijie Chen, Samuel Stevens, Boshi Wang, Huan Sun, and Yu Su. Mind2web: Towards a generalist agent for the web. In *Proceedings of NeurIPS*, 2023.
*   Zhou et al. [2024] Shuyan Zhou, Frank F Xu, Hao Zhu, Xuhui Zhou, Robert Lo, Abishek Sridhar, Xianyi Cheng, Yonatan Bisk, Daniel Fried, Uri Alon, et al. Webarena: A realistic web environment for building autonomous agents. In *Proceedings of ICLR*, 2024.
*   Liu et al. [2024] Xiao Liu, Hao Yu, Hanchen Zhang, Yifan Xu, Xuanyu Lei, Hanyu Lai, Yu Gu, Hangliang Ding, Kaiwen Men, Kejuan Yang, et al. Agentbench: Evaluating llms as agents. In *Proceedings of ICLR*, 2024.
*   Xie et al. [2024] Jian Xie, Kai Zhang, Jiangjie Chen, Tinghui Zhu, Renze Lou, Yuandong Tian, Yanghua Xiao, and Yu Su. TravelPlanner: A Benchmark for Real-World Planning with Language Agents, February 2024. arXiv:2402.01622 [cs].
*   Radford et al. [2018] Alec Radford, Karthik Narasimhan, Tim Salimans, Ilya Sutskever, et al. Improving language understanding by generative pre-training. 2018.
*   Wei et al. [2022] Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Brian Ichter, Fei Xia, Ed H. Chi, Quoc V. Le, and Denny Zhou. Chain-of-thought prompting elicits reasoning in large language models. In *NeurIPS*, 2022. URL [http://papers.nips.cc/paper_files/paper/2022/hash/9d5609613524ecf4f15af0f7b31abca4-Abstract-Conference.html](http://papers.nips.cc/paper_files/paper/2022/hash/9d5609613524ecf4f15af0f7b31abca4-Abstract-Conference.html).
*   Mialon et al. [2023] Grégoire Mialon, Roberto Dessì, Maria Lomeli, Christoforos Nalmpantis, Ram Pasunuru, Roberta Raileanu, Baptiste Rozière, Timo Schick, Jane Dwivedi-Yu, Asli Celikyilmaz, Edouard Grave, Yann LeCun, and Thomas Scialom. Augmented language models: a survey. In *arXiv preprint arXiv:2302.07842*, 2023.
*   Parisi et al. [2022] Aaron Parisi, Yao Zhao, and Noah Fiedel. Talm: Tool augmented language models. In *arXiv preprint arXiv:2205.12255*, 2022.
*   Schick et al. [2023] Timo Schick, Jane Dwivedi-Yu, Roberto Dessi, Roberta Raileanu, Maria Lomeli, Eric Hambro, Luke Zettlemoyer, Nicola Cancedda, and Thomas Scialom. Toolformer: Language models can teach themselves to use tools. In *Proceedings of NeurIPS*, 2023.
*   Lu et al. [2023b] Pan Lu, Baolin Peng, Hao Cheng, Michel Galley, Kai-Wei Chang, Ying Nian Wu, Song-Chun Zhu, and Jianfeng Gao. Chameleon: Plug-and-play compositional reasoning with large language models. In *Proceedings of NeurIPS*, 2023b.
*   Hu et al. [2023] Ziniu Hu, Ahmet Iscen, Chen Sun, Kai-Wei Chang, Yizhou Sun, David Ross, Cordelia Schmid, and Alireza Fathi. AVIS: autonomous visual information seeking with large language model agent. In Alice Oh, Tristan Naumann, Amir Globerson, Kate Saenko, Moritz Hardt, and Sergey Levine, editors, *Advances in Neural Information Processing Systems 36: Annual Conference on Neural Information Processing Systems 2023, NeurIPS 2023, New Orleans, LA, USA, December 10 - 16, 2023*, 2023. URL [http://papers.nips.cc/paper_files/paper/2023/hash/029df12a9363313c3e41047844ecad94-Abstract-Conference.html](http://papers.nips.cc/paper_files/paper/2023/hash/029df12a9363313c3e41047844ecad94-Abstract-Conference.html).
*   Hao et al. [2023] Shibo Hao, Tianyang Liu, Zhen Wang, and Zhiting Hu. Toolkengpt: Augmenting frozen language models with massive tools via tool embeddings. In Alice Oh, Tristan Naumann, Amir Globerson, Kate Saenko, Moritz Hardt, and Sergey Levine, editors, *Advances in Neural Information Processing Systems 36: Annual Conference on Neural Information Processing Systems 2023, NeurIPS 2023, New Orleans, LA, USA, December 10 - 16, 2023*, 2023. URL [http://papers.nips.cc/paper_files/paper/2023/hash/8fd1a81c882cd45f64958da6284f4a3f-Abstract-Conference.html](http://papers.nips.cc/paper_files/paper/2023/hash/8fd1a81c882cd45f64958da6284f4a3f-Abstract-Conference.html).
*   Qin et al. [2023] Yujia Qin, Shihao Liang, Yining Ye, Kunlun Zhu, Lan Yan, Yaxi Lu, Yankai Lin, Xin Cong, Xiangru Tang, Bill Qian, Sihan Zhao, Runchu Tian, Ruobing Xie, Jie Zhou, Mark Gerstein, Dahai Li, Zhiyuan Liu, and Maosong Sun. Toolllm: Facilitating large language models to master 16000+ real-world apis. *CoRR*, abs/2307.16789, 2023. doi: 10.48550/ARXIV.2307.16789. URL [https://doi.org/10.48550/arXiv.2307.16789](https://doi.org/10.48550/arXiv.2307.16789).
*   Tan et al. [2023b] Qingyu Tan, Hwee Tou Ng, and Lidong Bing. Towards benchmarking and improving the temporal reasoning capability of large language models. In *ACL*, pages 14820–14835\. Association for Computational Linguistics, 2023b.
*   Ning et al. [2020b] Qiang Ning, Hao Wu, Rujun Han, Nanyun Peng, Matt Gardner, and Dan Roth. TORQUE: A reading comprehension dataset of temporal ordering questions. In *EMNLP*, pages 1158–1172, 2020b.
*   Zhou et al. [2019] Ben Zhou, Daniel Khashabi, Qiang Ning, and Dan Roth. “going on a vacation” takes longer than “going for a walk”: A study of temporal commonsense understanding. In *EMNLP*, pages 3363–3369, 2019.
*   Zhang and Choi [2021] Michael Zhang and Eunsol Choi. Situatedqa: Incorporating extra-linguistic contexts into qa. In *EMNLP*, 2021.
*   Wang and Zhao [2023] Yuqing Wang and Yun Zhao. Tram: Benchmarking temporal reasoning for large language models. 2023.
*   Jin et al. [2020b] Woojeong Jin, Meng Qu, Xisen Jin, and Xiang Ren. Recurrent event network: Autoregressive structure inferenceover temporal knowledge graphs. In *EMNLP (1)*, pages 6669–6683\. Association for Computational Linguistics, 2020b.
*   Li et al. [2021b] Zixuan Li, Xiaolong Jin, Wei Li, Saiping Guan, Jiafeng Guo, Huawei Shen, Yuanzhuo Wang, and Xueqi Cheng. Temporal knowledge graph reasoning based on evolutional representation learning. In *SIGIR*, pages 408–417\. ACM, 2021b.
*   Park et al. [2022] Namyong Park, Fuchen Liu, Purvanshi Mehta, Dana Cristofor, Christos Faloutsos, and Yuxiao Dong. Evokg: Jointly modeling event time and network structure for reasoning over temporal knowledge graphs. In *WSDM*, pages 794–803\. ACM, 2022.
*   Zhu et al. [2020] Cunchao Zhu, Muhao Chen, Changjun Fan, Guangquan Cheng, and Yan Zhan. Learning from history: Modeling temporal knowledge graphs with sequential copy-generation networks. In *AAAI Conference on Artificial Intelligence*, 2020.
*   Sun et al. [2021] Haohai Sun, Jialu Zhong, Yunpu Ma, Zhen Han, and Kun He. Timetraveler: Reinforcement learning for temporal knowledge graph forecasting. In *EMNLP*, 2021.
*   Li et al. [2021c] Zixuan Li, Xiaolong Jin, Saiping Guan, Wei Li, Jiafeng Guo, Yuanzhuo Wang, and Xueqi Cheng. Search from history and reason for future: Two-stage reasoning on temporal knowledge graphs. In *ACL*, 2021c.
*   Trivedi et al. [2017] Rakshit Trivedi, Hanjun Dai, Yichen Wang, and Le Song. Know-evolve: deep temporal reasoning for dynamic knowledge graphs. In *ICML*, page 3462–3471, 2017.
*   Ding et al. [2021] Zifeng Ding, Zhen Han, Yunpu Ma, and Volker Tresp. Temporal knowledge graph forecasting with neural ode. abs/2101.05151, 2021.
*   Deng et al. [2020] Songgaojun Deng, Huzefa Rangwala, and Yue Ning. Dynamic knowledge graph based multi-event forecasting. In *KDD*, pages 1585–1595\. ACM, 2020.
*   Deng et al. [2021] Songgaojun Deng, Huzefa Rangwala, and Yue Ning. Understanding event predictions via contextualized multilevel feature learning. In *CIKM*, pages 342–351\. ACM, 2021.
*   Ma et al. [2023b] Yunshan Ma, Chenchen Ye, Zijian Wu, Xiang Wang, Yixin Cao, and Tat-Seng Chua. Context-aware event forecasting via graph disentanglement. In *KDD*, pages 1643–1652\. ACM, 2023b.
*   Ma et al. [2023c] Yunshan Ma, Chenchen Ye, Zijian Wu, Xiang Wang, Yixin Cao, Liang Pang, and Tat-Seng Chua. Structured, complex and time-complete temporal event forecasting. *CoRR*, abs/2312.01052, 2023c.
*   Xu et al. [2023b] Wenjie Xu, Ben Liu, Miao Peng, Xu Jia, and Min Peng. Pre-trained language model with prompts for temporal knowledge graph completion. In *ACL (Findings)*, pages 7790–7803\. Association for Computational Linguistics, 2023b.
*   Lee et al. [2023] Dong-Ho Lee, Kian Ahrabian, Woojeong Jin, Fred Morstatter, and Jay Pujara. Temporal knowledge graph forecasting without knowledge using in-context learning. In *EMNLP*, pages 544–557\. Association for Computational Linguistics, 2023.
*   Liao et al. [2023] Ruotong Liao, Xu Jia, Yunpu Ma, and Volker Tresp. Gentkg: Generative forecasting on temporal knowledge graph. *CoRR*, abs/2310.07793, 2023.
*   Shi et al. [2023] Xiaoming Shi, Siqiao Xue, Kangrui Wang, Fan Zhou, James Y. Zhang, JUN ZHOU, Chenhao Tan, and Hongyuan Mei. Language models can improve event prediction by few-shot abductive reasoning. In *NeurIPS*, 2023.
*   Brown et al. [2020] Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. Language models are few-shot learners. *Advances in neural information processing systems*, 33:1877–1901, 2020.
*   Chowdhery et al. [2023] Aakanksha Chowdhery, Sharan Narang, Jacob Devlin, Maarten Bosma, Gaurav Mishra, Adam Roberts, Paul Barham, Hyung Won Chung, Charles Sutton, Sebastian Gehrmann, et al. Palm: Scaling language modeling with pathways. *Journal of Machine Learning Research*, 24(240):1–113, 2023.
*   Chen et al. [2021] Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, et al. Evaluating large language models trained on code. *arXiv preprint arXiv:2107.03374*, 2021.
*   Wang et al. [2021] Yue Wang, Weishi Wang, Shafiq Joty, and Steven CH Hoi. Codet5: Identifier-aware unified pre-trained encoder-decoder models for code understanding and generation. In *Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing*, pages 8696–8708, 2021.
*   Nijkamp et al. [2022] Erik Nijkamp, Bo Pang, Hiroaki Hayashi, Lifu Tu, Huan Wang, Yingbo Zhou, Silvio Savarese, and Caiming Xiong. Codegen: An open large language model for code with multi-turn program synthesis. *arXiv preprint arXiv:2203.13474*, 2022.
*   Li et al. [2022] Yujia Li, David Choi, Junyoung Chung, Nate Kushman, Julian Schrittwieser, Rémi Leblond, Tom Eccles, James Keeling, Felix Gimeno, Agustin Dal Lago, et al. Competition-level code generation with alphacode. *Science*, 378(6624):1092–1097, 2022.
*   Li et al. [2023c] Raymond Li, Loubna Ben Allal, Yangtian Zi, Niklas Muennighoff, Denis Kocetkov, Chenghao Mou, Marc Marone, Christopher Akiki, Jia Li, Jenny Chim, et al. Starcoder: may the source be with you! *arXiv preprint arXiv:2305.06161*, 2023c.
*   Luo et al. [2023] Ziyang Luo, Can Xu, Pu Zhao, Qingfeng Sun, Xiubo Geng, Wenxiang Hu, Chongyang Tao, Jing Ma, Qingwei Lin, and Daxin Jiang. Wizardcoder: Empowering code large language models with evol-instruct. *arXiv preprint arXiv:2306.08568*, 2023.
*   Gunasekar et al. [2023] Suriya Gunasekar, Yi Zhang, Jyoti Aneja, Caio César Teodoro Mendes, Allie Del Giorno, Sivakanth Gopi, Mojan Javaheripi, Piero Kauffmann, Gustavo de Rosa, Olli Saarikivi, et al. Textbooks are all you need. *arXiv preprint arXiv:2306.11644*, 2023.
*   Roziere et al. [2023] Baptiste Roziere, Jonas Gehring, Fabian Gloeckle, Sten Sootla, Itai Gat, Xiaoqing Ellen Tan, Yossi Adi, Jingyu Liu, Tal Remez, Jérémy Rapin, et al. Code llama: Open foundation models for code. *arXiv preprint arXiv:2308.12950*, 2023.
*   Bai et al. [2023] Jinze Bai, Shuai Bai, Yunfei Chu, Zeyu Cui, Kai Dang, Xiaodong Deng, Yang Fan, Wenbin Ge, Yu Han, Fei Huang, et al. Qwen technical report. *arXiv preprint arXiv:2309.16609*, 2023.
*   Guo et al. [2024] Daya Guo, Qihao Zhu, Dejian Yang, Zhenda Xie, Kai Dong, Wentao Zhang, Guanting Chen, Xiao Bi, Y Wu, YK Li, et al. Deepseek-coder: When the large language model meets programming–the rise of code intelligence. *arXiv preprint arXiv:2401.14196*, 2024.
*   Austin et al. [2021] Jacob Austin, Augustus Odena, Maxwell Nye, Maarten Bosma, Henryk Michalewski, David Dohan, Ellen Jiang, Carrie Cai, Michael Terry, Quoc Le, et al. Program synthesis with large language models. *arXiv preprint arXiv:2108.07732*, 2021.

###### Appendix

1.  [1 Introduction](https://arxiv.org/html/2407.01231v1#S1 "In Mirai: Evaluating LLM Agents for Event Forecasting")
2.  [2 The Mirai Benchmark](https://arxiv.org/html/2407.01231v1#S2 "In Mirai: Evaluating LLM Agents for Event Forecasting")
    1.  [2.1 Data and Tasks](https://arxiv.org/html/2407.01231v1#S2.SS1 "In 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
    2.  [2.2 Agents and Environments](https://arxiv.org/html/2407.01231v1#S2.SS2 "In 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
    3.  [2.3 Database Construction](https://arxiv.org/html/2407.01231v1#S2.SS3 "In 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
3.  [3 Experiments](https://arxiv.org/html/2407.01231v1#S3 "In Mirai: Evaluating LLM Agents for Event Forecasting")
    1.  [3.1 Evaluate Forecasting with Different Agent Methods and Tools](https://arxiv.org/html/2407.01231v1#S3.SS1 "In 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
        1.  [3.2 Evaluate Forecasting with Different Base LLMs](https://arxiv.org/html/2407.01231v1#S3.SS2 "In 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
            1.  [3.3 Analyzing Agent Behaviours](https://arxiv.org/html/2407.01231v1#S3.SS3 "In 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                1.  [4 Related Work](https://arxiv.org/html/2407.01231v1#S4 "In 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                    1.  [4.1 Temporal Reasoning Benchmarks](https://arxiv.org/html/2407.01231v1#S4.SS1 "In 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                        1.  [4.2 Evaluation of Language Agents](https://arxiv.org/html/2407.01231v1#S4.SS2 "In 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                            1.  [4.3 LLMs for Tool-Use](https://arxiv.org/html/2407.01231v1#S4.SS3 "In 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                1.  [5 Conclusion and Limitation](https://arxiv.org/html/2407.01231v1#S5 "In 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                    1.  [A Reproducibility Statement](https://arxiv.org/html/2407.01231v1#A1 "In Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                    2.  [B Datasheet for MIRAI](https://arxiv.org/html/2407.01231v1#A2 "In Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                        1.  [B.1 Motivation](https://arxiv.org/html/2407.01231v1#A2.SS1 "In Appendix B Datasheet for MIRAI ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                        2.  [B.2 Distribution](https://arxiv.org/html/2407.01231v1#A2.SS2 "In Appendix B Datasheet for MIRAI ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                        3.  [B.3 Maintenance](https://arxiv.org/html/2407.01231v1#A2.SS3 "In Appendix B Datasheet for MIRAI ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                        4.  [B.4 Composition](https://arxiv.org/html/2407.01231v1#A2.SS4 "In Appendix B Datasheet for MIRAI ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                        5.  [B.5 Collection Process](https://arxiv.org/html/2407.01231v1#A2.SS5 "In Appendix B Datasheet for MIRAI ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                        6.  [B.6 Uses](https://arxiv.org/html/2407.01231v1#A2.SS6 "In Appendix B Datasheet for MIRAI ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                    3.  [C Limitations](https://arxiv.org/html/2407.01231v1#A3 "In Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                    4.  [D Additional related work](https://arxiv.org/html/2407.01231v1#A4 "In Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                        1.  [D.1 Temporal Event Forecasting Methods](https://arxiv.org/html/2407.01231v1#A4.SS1 "In Appendix D Additional related work ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                        2.  [D.2 LLMs for Code Generation](https://arxiv.org/html/2407.01231v1#A4.SS2 "In Appendix D Additional related work ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                    5.  [E Additional Details of the Database](https://arxiv.org/html/2407.01231v1#A5 "In Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                        1.  [E.1 Countries and ISO Codes](https://arxiv.org/html/2407.01231v1#A5.SS1 "In Appendix E Additional Details of the Database ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                        2.  [E.2 Relations and CAMEO Codes](https://arxiv.org/html/2407.01231v1#A5.SS2 "In Appendix E Additional Details of the Database ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                    6.  [F Details of Dataset Construction](https://arxiv.org/html/2407.01231v1#A6 "In Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                    7.  [G Term of Use for GDELT Dataset](https://arxiv.org/html/2407.01231v1#A7 "In Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                    8.  [H Broader Impact](https://arxiv.org/html/2407.01231v1#A8 "In Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                    9.  [I Additional Details about Agent Setup](https://arxiv.org/html/2407.01231v1#A9 "In Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                    10.  [J Additional Experimental Results and Analysis](https://arxiv.org/html/2407.01231v1#A10 "In Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                        1.  [J.1 Analysis of the Final Status of Different LLM Agents](https://arxiv.org/html/2407.01231v1#A10.SS1 "In Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                            1.  [J.2 Analysis on Function Types](https://arxiv.org/html/2407.01231v1#A10.SS2 "In J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                1.  [K Prompts](https://arxiv.org/html/2407.01231v1#A11 "In J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                    1.  [K.1 System Prompts](https://arxiv.org/html/2407.01231v1#A11.SS1 "In Appendix K Prompts ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                        1.  [K.1.1 System Prompt for ReAct Agent with Action Type as “Single Function”](https://arxiv.org/html/2407.01231v1#A11.SS1.SSS1 "In K.1 System Prompts ‣ Appendix K Prompts ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                        2.  [K.1.2 System Prompt for ReAct Agent with Action Type as “Code Block”](https://arxiv.org/html/2407.01231v1#A11.SS1.SSS2 "In K.1 System Prompts ‣ Appendix K Prompts ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                        3.  [K.1.3 System Prompt for Direct Agent](https://arxiv.org/html/2407.01231v1#A11.SS1.SSS3 "In K.1 System Prompts ‣ Appendix K Prompts ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                        4.  [K.1.4 System Prompt for CoT Agent](https://arxiv.org/html/2407.01231v1#A11.SS1.SSS4 "In K.1 System Prompts ‣ Appendix K Prompts ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                    2.  [K.2 Query Prompt](https://arxiv.org/html/2407.01231v1#A11.SS2 "In Appendix K Prompts ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                    3.  [K.3 Answer Extraction Prompt](https://arxiv.org/html/2407.01231v1#A11.SS3 "In Appendix K Prompts ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                2.  [L Additional Forecasting Examples of LLM Agent](https://arxiv.org/html/2407.01231v1#A12 "In J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                    1.  [L.1 GPT-4o-based Agent with ReAct and “Code Block” Action](https://arxiv.org/html/2407.01231v1#A12.SS1 "In Appendix L Additional Forecasting Examples of LLM Agent ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                        1.  [L.1.1 Query Details](https://arxiv.org/html/2407.01231v1#A12.SS1.SSS1 "In L.1 GPT-4o-based Agent with ReAct and “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                        2.  [L.1.2 Query Prompt](https://arxiv.org/html/2407.01231v1#A12.SS1.SSS2 "In L.1 GPT-4o-based Agent with ReAct and “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                        3.  [L.1.3 System Prompt](https://arxiv.org/html/2407.01231v1#A12.SS1.SSS3 "In L.1 GPT-4o-based Agent with ReAct and “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                        4.  [L.1.4 Agent ReAct Process](https://arxiv.org/html/2407.01231v1#A12.SS1.SSS4 "In L.1 GPT-4o-based Agent with ReAct and “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                            1.  [M Additional Information about API](https://arxiv.org/html/2407.01231v1#A13 "In item 1 ‣ L.1.4 Agent ReAct Process ‣ L.1 GPT-4o-based Agent with ReAct and “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                                1.  [M.1 Overview of API Data Classes and Functions](https://arxiv.org/html/2407.01231v1#A13.SS1 "In Appendix M Additional Information about API ‣ item 1 ‣ L.1.4 Agent ReAct Process ‣ L.1 GPT-4o-based Agent with ReAct and “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                                2.  [M.2 API Specification](https://arxiv.org/html/2407.01231v1#A13.SS2 "In Appendix M Additional Information about API ‣ item 1 ‣ L.1.4 Agent ReAct Process ‣ L.1 GPT-4o-based Agent with ReAct and “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
                                                                3.  [M.3 API Implementation](https://arxiv.org/html/2407.01231v1#A13.SS3 "In Appendix M Additional Information about API ‣ item 1 ‣ L.1.4 Agent ReAct Process ‣ L.1 GPT-4o-based Agent with ReAct and “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")

## Appendix A Reproducibility Statement

We provide detailed information and explanation of our experimental setup, dataset, and evaluation metrics, ensuring reproducibility. Specifically, we describe the following:

*   •

    Experimental setup (Sec. [3](https://arxiv.org/html/2407.01231v1#S3 "3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")): Detailed descriptions of the hardware and software configurations, including libraries and tools used.

*   •

    Dataset (Sec. [2](https://arxiv.org/html/2407.01231v1#S2 "2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting") & Appendix [F](https://arxiv.org/html/2407.01231v1#A6 "Appendix F Details of Dataset Construction ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")): Comprehensive information on the dataset used, including sources, preprocessing steps, and any techniques applied.

*   •

    Evaluation Metrics (Sec. [2.3](https://arxiv.org/html/2407.01231v1#S2.SS3 "2.3 Database Construction ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")): Clear definitions for the metrics chosen to evaluate performance.

Additionally, we commit to releasing the following resources for the replication of our results:

*   •

    Codebase: The complete codebase, including scripts for data preprocessing, model serving, and evaluation. This is made available on a public repository ([https://github.com/yecchen/MIRAI](https://github.com/yecchen/MIRAI)).

*   •

    Dataset: The processed dataset, along with detailed instructions on how to construct the dataset ([https://drive.google.com/file/d/1xmSEHZ_wqtBu1AwLpJ8wCDYmT-jRpfrN/view?usp=sharing](https://drive.google.com/file/d/1xmSEHZ_wqtBu1AwLpJ8wCDYmT-jRpfrN/view?usp=sharing)).

By providing these resources, we aim to ensure that our work is fully reproducible and can be independently verified by the research community.

## Appendix B Datasheet for MIRAI

### B.1 Motivation

1.  1.

    For what purpose was the dataset created?
    The MIRAI dataset was created to evaluate different capabilities of Large Language Model (LLM) agents in forecasting international events.

2.  2.

    Who created the dataset and on behalf of which entity?
    The dataset was developed by a group of university researchers studying LLM reasoning. All rights are held by the individuals themselves, rather than by third-party stakeholders.

3.  3.

    Who funded the creation of the dataset?
    The academic institutions support the university reasearch lab that the authors affiliate in.

### B.2 Distribution

1.  1.

    Will the dataset be distributed to third parties outside of the entity?
    Yes, the dataset, evaluation codes and leaderboards are intended to be publicly available to foster future research and development.

2.  2.

    How will the dataset be distributed?
    The database and codebase are currently available on [Google Drive](https://drive.google.com/file/d/1xmSEHZ_wqtBu1AwLpJ8wCDYmT-jRpfrN/view?usp=sharing) and [Github](https://github.com/yecchen/MIRAI).

3.  3.

    Have any third parties imposed IP-based or other restrictions on the data associated with the instances?
    No, there are no IP-based or other restrictions on the data: MIRAI is curated based on the GDELT⁶⁶6[GDELT Project: https://www.gdeltproject.org/](https://www.gdeltproject.org/) Event Database, which is an open platform for research and analysis of global society and all datasets released by the GDELT Project are available for unlimited and unrestricted use for any academic, commercial, or governmental use of any kind without fee; Data are allowed for any redistribution, rehost, republish, and mirror of the GDELT datasets in any form, with necessary citations⁷⁷7[GDELT Term of Use: https://www.gdeltproject.org/about.html#termsofuse](https://www.gdeltproject.org/about.html#termsofuse).

4.  4.

    Do any export controls or other regulatory restrictions apply to the dataset or to individual instances?
    No, there are no export controls or other regulatory restrictions applied to this dataset.

5.  5.

    When will the dataset be distributed?
    The dataset has been made publicly available with the [project website](https://mirai-llm.github.io/), [Google Drive](https://drive.google.com/file/d/1xmSEHZ_wqtBu1AwLpJ8wCDYmT-jRpfrN/view?usp=sharing), and [Github](https://github.com/yecchen/MIRAI).

6.  6.

    Will the dataset be distributed under a copyright or other IP license, and/or under applicable terms of use (ToU)?
    The dataset will be distributed under the CC BY-NC 4.0 license, allowing for use and distribution for non-commercial purposes with appropriate attribution.

### B.3 Maintenance

1.  1.

    Who will be supporting/hosting/maintaining the dataset?
    The dataset maintenance will be supporting/hosting/maintaining by the authors.

2.  2.

    How can the owner/curator/manager of the dataset be contacted?
    The owner/curator/manager of the dataset can be contacted through the authors’ emails.

3.  3.

    Will the dataset be updated? (e.g., to correct labeling errors, add new instances, delete instances)?
    Yes, the dataset will be updated whenever necessary to ensure accuracy, and announcements will be made accordingly.

4.  4.

    If the dataset relates to people, are there applicable limits on the retention of the data associated with the instances (e.g., were the individuals in question told that their data would be retained for a fixed period of time and then deleted?)
    NA. This dataset does not contain data related to individuals or personal identifiers.

5.  5.

    Will older version of the dataset continue to be supported/hosted/maintained? NA. Currently, there are no older versions of the dataset, as this is its first release. As the dataset evolves, the possibility of supporting and maintaining older versions will be considered based on community needs and resource availability.

6.  6.

    If others want to extend/augment/build on/contribute to the dataset, is there a mechanism for them to do so? Researchers and developers interested in extending, augmenting, or contributing to the dataset are encouraged to submit their changes through GitHub pull requests. For additional inquiries or detailed discussions, contacting the authors via email is recommended.

### B.4 Composition

1.  1.

    What do the instances that comprise the dataset represent?
    Each instance in the dataset represents a structured record of international events, including the date, involved countries, and type of event, along with associated news articles and metadata.

2.  2.

    How many instances are there in total?
    The database comprises 991,759 GDELT event records from January 2023 to November 2023, corresponding to 59,161 unique events and 296,630 news articles. The test set contains 705 relation prediction queries, and the test subset contains 100 queries.

3.  3.

    Does the dataset contain all possible instances or is it a sample of instances from a larger set?
    The dataset represents a curated sample from the entire GDELT database. It has been created through meticulously designed data cleaning and preprocessing steps aimed at enhancing the quality and reliability of the event data.

4.  4.

    Is there a label or target associated with each instance?
    Yes, each instance in the dataset is an event labeled with a relation type derived from the CAMEO⁸⁸8[Conflict and Mediation Event Observations (CAMEO): https://parusanalytics.com/eventdata/data.dir/cameo.html](https://parusanalytics.com/eventdata/data.dir/cameo.html) event taxonomy.

5.  5.

    Is any information missing from individual instances?
    No, all instances are complete with all available information.

6.  6.

    Are there recommended data splits (e.g., training, development/validation, testing)?
    The dataset includes records from January 2023 to November 2023\. The recommended testing set is constructed based on records from November 2023\. For testing, each instance utilizes all preceding records as its historical dataset to ensure accuracy and relevance in analysis.

7.  7.

    Are there any errors, sources of noise, or redundancies in the dataset?
    The dataset has undergone extensive cleaning and structuring to minimize errors and noise. However, residual noise from the original GDELT database may still be present.

8.  8.

    Is the dataset self-contained, or does it link to or otherwise rely on external resources (e.g., websites, tweets, other datasets)?
    While the dataset is primarily self-contained, it includes URLs to news articles, providing links to external resources for further context and verification.

9.  9.

    Does the dataset contain data that might be considered confidential?
    No, the dataset contains publicly available data and does not include confidential information.

10.  10.

    Does the dataset contain data that, if viewed directly, might be offensive, insulting, threatening, or might otherwise cause anxiety?
    The dataset may include descriptions of sensitive events, such as global conflicts, due to its focus on international relations. However, thorough checks such as flagging word ratios are employed during the data cleaning process to identify and potentially exclude inappropriate paragraphs or entire news articles and events. This ensures the minimization of distressing content while maintaining the integrity and relevance of the dataset for academic study.

### B.5 Collection Process

1.  1.

    How was the data associated with each instance acquired?
    Data for each instance was sourced from the GDELT project, which aggregates global event data and news articles from various worldwide media. Detailed information can be found in Section [2.3](https://arxiv.org/html/2407.01231v1#S2.SS3 "2.3 Database Construction ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting") and Appendix [F](https://arxiv.org/html/2407.01231v1#A6 "Appendix F Details of Dataset Construction ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting") of the paper.

2.  2.

    What mechanisms or procedures were used to collect the data (e.g., hardware apparatus or sensor, manual human curation, software program, software API)? Data collection was facilitated through software programs that aggregate event data and news articles from various sources. This automated collection is followed by data cleaning processes to enhance completeness and reliability. For a detailed description of the collection and cleaning methods, please refer to Section [2.3](https://arxiv.org/html/2407.01231v1#S2.SS3 "2.3 Database Construction ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting") and Appendix [F](https://arxiv.org/html/2407.01231v1#A6 "Appendix F Details of Dataset Construction ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting") of the paper. All dataset construction scripts are available in [Github](https://github.com/yecchen/MIRAI) and also described in the README.

3.  3.

    Who was involved in the data collection process? (e.g., students, crowdworkers, contractors) and how were they compensated (e.g., how much were crowdworkers paid)
    The data collection and preprocessing were conducted by the authors, who are university researchers. This work was performed as part of their academic research activities.

4.  4.

    Does the dataset relate to people?
    No. The dataset does not contain personal data or directly relate to individual people.

5.  5.

    Did you collect the data from the individuals in questions directly, or obtain it via third parties or other sources (e.g., websites)?
    The dataset does not involve data collected from individuals directly. Instead, it is curated from the GDELT project, which aggregates information from various global news media sources.

### B.6 Uses

1.  1.

    Has the dataset been used for any tasks already?
    The dataset has not been used for any tasks other than the ones proposed and examined in this current paper, specifically for benchmarking the forecasting capabilities of LLM agents in predicting international relations.

2.  2.

    What (other) tasks could the dataset be used for?
    In addition to benchmarking LLM agents, the dataset could be valuable for research in geopolitics, the development of other event prediction algorithms, sentiment analysis of international events, and trend analysis in global political dynamics.

3.  3.

    Is there anything about the composition of the dataset or the way it was collected and preprocessed/cleaned/labeled that might impact future uses? The dataset was meticulously collected and preprocessed to ensure high quality and reliability. However, the reliance on the GDELT project as the primary data source and the specific cleaning process applied might influence its applicability to certain tasks. Users should consider these factors when applying the dataset to different research areas or methodologies.

4.  4.

    Are there tasks for which the dataset should not be used? The dataset should not be used for any tasks that violate the terms of use associated with the GDELT project.

## Appendix C Limitations

We acknowledge a few limitations in our current work. Firstly, the forecasting events in the test set might have been exposed to the most recently published LLMs, such as the gpt-4-turbo-2024-04-09, which has training data up to December 2023\. While the background knowledge of LLMs about international relations matters for accurate forecasting, this benchmark still challenges them in retrieving grounded facts from the database and performing reliable forecasting. Secondly, many other base LLMs are not tested in the experiments. However, we chose some representative models for both open-source and closed-source LLMs, leaving more comprehensive tests for future work. Thirdly, while the current API covers functions like count, listing, and basic distribution statistics of events and news articles, more functionality can be added to the function pool in the future. For example, to further encourage the agent to analyze based on temporal trends, functions related to time series could be added to the API. We could also allow agents to generate and add useful functions to the API during their reasoning process to support a more diverse toolset. Fourthly, current experiments are limited by cost and time considerations. More rounds of experiments should be added for each different LLM and various settings. We observe some large variance in the experimental results, which may be caused by the current model temperature of 0.4 and the limited number of 5 rounds per experiment.

## Appendix D Additional related work

### D.1 Temporal Event Forecasting Methods

LLMs have been tested for their temporal understanding through tasks such as temporal event ordering or storyline comprehension [[70](https://arxiv.org/html/2407.01231v1#bib.bib70), [71](https://arxiv.org/html/2407.01231v1#bib.bib71), [72](https://arxiv.org/html/2407.01231v1#bib.bib72), [73](https://arxiv.org/html/2407.01231v1#bib.bib73), [74](https://arxiv.org/html/2407.01231v1#bib.bib74)]. In the context of temporal forecasting, LLMs have also been evaluated on recent text-based temporal forecasting benchmarks [[8](https://arxiv.org/html/2407.01231v1#bib.bib8), [46](https://arxiv.org/html/2407.01231v1#bib.bib46)]. However, these evaluations typically involve providing LLMs with retrieved context for in-context learning and then directly answering the forecast question. This approach limits the interaction between the LLM and the database and lacks important intermediate thinking and reasoning steps crucial for accurate forecasting. In contrast, Mirai establishes a comprehensive environment that enables an LLM to act as an agent, interacting with the database through multiple rounds of thinking, retrieving diverse information, and providing a complete reasoning path to the final forecast answer. This setup allows for a more thorough evaluation of the LLM’s temporal reasoning capabilities and its ability to effectively retrieving and analyzing the available information.

Significant research has also been conducted in the field of structured event temporal forecasting. Various methods have been proposed, including aggregating temporal and relational information among entities [[75](https://arxiv.org/html/2407.01231v1#bib.bib75), [76](https://arxiv.org/html/2407.01231v1#bib.bib76), [77](https://arxiv.org/html/2407.01231v1#bib.bib77)], retrieving relevant historical events [[78](https://arxiv.org/html/2407.01231v1#bib.bib78), [79](https://arxiv.org/html/2407.01231v1#bib.bib79), [80](https://arxiv.org/html/2407.01231v1#bib.bib80)], and modeling the continuous time evolution of events [[81](https://arxiv.org/html/2407.01231v1#bib.bib81), [82](https://arxiv.org/html/2407.01231v1#bib.bib82)]. Efforts have also been made to incorporate textual event information into Temporal Knowledge Graphs (TKGs). Glean [[83](https://arxiv.org/html/2407.01231v1#bib.bib83)] and CMF [[84](https://arxiv.org/html/2407.01231v1#bib.bib84)] integrate textual embeddings into graph edges, while SeCoGD [[85](https://arxiv.org/html/2407.01231v1#bib.bib85)] employs textual topic modeling to separate subgraphs. The MidEast-TE dataset and LoGo model [[86](https://arxiv.org/html/2407.01231v1#bib.bib86)] utilize text clustering to construct complex events for forecasting with local and global contexts. However, these methods still perform forecast reasoning solely on graphs using graph-based techniques. Recent studies have explored the use of LLMs for temporal event forecasting by transforming the TKG formulation into text sequences and converting missing object prediction into next token prediction [[87](https://arxiv.org/html/2407.01231v1#bib.bib87)]. GPT-NeoX-ICL [[88](https://arxiv.org/html/2407.01231v1#bib.bib88)] employs in-context learning of LLMs and constructs prompts as a list of historical events in quadruplet format. GENTKG [[89](https://arxiv.org/html/2407.01231v1#bib.bib89)] enhances the selection of historical event inputs using a temporal logical rule-based retrieval strategy, while LAMP [[90](https://arxiv.org/html/2407.01231v1#bib.bib90)] applies LLMs to perform abductive reasoning to assist the retrieval process. However, these works only investigate LLMs with in-context learning or simple task-specific fine-tuning. In contrast, Mirai explores forecasting with an LLM agent that supports explicit information gathering and reasoning steps, enabling a hybrid approach that leverages both text and graph data.

### D.2 LLMs for Code Generation

Early advancements in LLMs have greatly impacted the field of code generation. Notable early models such as GPT-3 [[91](https://arxiv.org/html/2407.01231v1#bib.bib91)] and PALM [[92](https://arxiv.org/html/2407.01231v1#bib.bib92)] have demonstrated the potential of LLMs to assist in code completion and generation. Subsequent models have built upon the foundation of pre-trained LLMs, further refining capabilities specific to code generation. This has led to the development of code-specific LLMs such as Codex [[93](https://arxiv.org/html/2407.01231v1#bib.bib93)], Code T5 [[94](https://arxiv.org/html/2407.01231v1#bib.bib94)], CodeGen [[95](https://arxiv.org/html/2407.01231v1#bib.bib95)], AlphaCode [[96](https://arxiv.org/html/2407.01231v1#bib.bib96)], StarCoder [[97](https://arxiv.org/html/2407.01231v1#bib.bib97)], WizardCoder [[98](https://arxiv.org/html/2407.01231v1#bib.bib98)], and phi-1 [[99](https://arxiv.org/html/2407.01231v1#bib.bib99)]. Moreover, code from open-source platforms such as GitHub has increasingly been incorporated into the pre-training data for recent LLMs [[25](https://arxiv.org/html/2407.01231v1#bib.bib25), [22](https://arxiv.org/html/2407.01231v1#bib.bib22)]. This integration has led to improved performance of LLMs such as Code Llama [[100](https://arxiv.org/html/2407.01231v1#bib.bib100)], Code-Qwen [[101](https://arxiv.org/html/2407.01231v1#bib.bib101)], and DeepSeek-Coder [[102](https://arxiv.org/html/2407.01231v1#bib.bib102)] on popular code-related tasks [[93](https://arxiv.org/html/2407.01231v1#bib.bib93), [103](https://arxiv.org/html/2407.01231v1#bib.bib103)].

## Appendix E Additional Details of the Database

### E.1 Countries and ISO Codes

We show the ISO 3166 Alpha-3 country codes and names in Table [4](https://arxiv.org/html/2407.01231v1#A5.T4 "Table 4 ‣ E.1 Countries and ISO Codes ‣ Appendix E Additional Details of the Database ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting") and Table [5](https://arxiv.org/html/2407.01231v1#A5.T5 "Table 5 ‣ E.1 Countries and ISO Codes ‣ Appendix E Additional Details of the Database ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting").

Table 4: List of Countries and their ISO-3166 Alpha-3 Codes (Part 1)

 | Code | Country | Code | Country | Code | Country |
| AND | Andorra | ARE | United Arab Emirates | AFG | Afghanistan |
| ATG | Antigua and Barbuda | AIA | Anguilla | ALB | Albania |
| ARM | Armenia | AGO | Angola | ATA | Antarctica |
| ARG | Argentina | ASM | American Samoa | AUT | Austria |
| AUS | Australia | ABW | Aruba | ALA | Åland |
| AZE | Azerbaijan | BIH | Bosnia and Herzegovina | BRB | Barbados |
| BGD | Bangladesh | BEL | Belgium | BFA | Burkina Faso |
| BGR | Bulgaria | BHR | Bahrain | BDI | Burundi |
| BEN | Benin | BLM | Saint Barthélemy | BMU | Bermuda |
| BRN | Brunei | BOL | Bolivia | BES | Bonaire, Sint Eustatius, and Saba |
| BRA | Brazil | BHS | Bahamas | BTN | Bhutan |
| BVT | Bouvet Island | BWA | Botswana | BLR | Belarus |
| BLZ | Belize | CAN | Canada | CCK | Cocos (Keeling) Islands |
| COD | DR Congo | CAF | Central African Republic | COG | Congo Republic |
| CHE | Switzerland | CIV | Ivory Coast | COK | Cook Islands |
| CHL | Chile | CMR | Cameroon | CHN | China |
| COL | Colombia | CRI | Costa Rica | CUB | Cuba |
| CPV | Cabo Verde | CUW | Curaçao | CXR | Christmas Island |
| CYP | Cyprus | CZE | Czechia | DEU | Germany |
| DJI | Djibouti | DNK | Denmark | DMA | Dominica |
| DOM | Dominican Republic | DZA | Algeria | ECU | Ecuador |
| EST | Estonia | EGY | Egypt | ESH | Western Sahara |
| ERI | Eritrea | ESP | Spain | ETH | Ethiopia |
| FIN | Finland | FJI | Fiji | FLK | Falkland Islands |
| FSM | Micronesia | FRO | Faroe Islands | FRA | France |
| GAB | Gabon | GBR | United Kingdom | GRD | Grenada |
| GEO | Georgia | GUF | French Guiana | GGY | Guernsey |
| GHA | Ghana | GIB | Gibraltar | GRL | Greenland |
| GMB | The Gambia | GIN | Guinea | GLP | Guadeloupe |
| GNQ | Equatorial Guinea | GRC | Greece | SGS | South Georgia and South Sandwich Islands |
| GTM | Guatemala | GUM | Guam | GNB | Guinea-Bissau |
| GUY | Guyana | HKG | Hong Kong | HMD | Heard and McDonald Islands |
| HND | Honduras | HRV | Croatia | HTI | Haiti |
| HUN | Hungary | IDN | Indonesia | IRL | Ireland |
| ISR | Israel | IMN | Isle of Man | IND | India |
| IOT | British Indian Ocean Territory | IRQ | Iraq | IRN | Iran |
| ISL | Iceland | ITA | Italy | JEY | Jersey |
| JAM | Jamaica | JOR | Jordan | JPN | Japan |
| KEN | Kenya | KGZ | Kyrgyzstan | KHM | Cambodia |
| KIR | Kiribati | COM | Comoros | KNA | St Kitts and Nevis |
| PRK | North Korea | KOR | South Korea | KWT | Kuwait |
| CYM | Cayman Islands | KAZ | Kazakhstan | LAO | Laos |
| LBN | Lebanon | LCA | Saint Lucia | LIE | Liechtenstein |
| LKA | Sri Lanka | LBR | Liberia | LSO | Lesotho |
| LTU | Lithuania | LUX | Luxembourg | LVA | Latvia |
| LBY | Libya | MAR | Morocco | MCO | Monaco |
| MDA | Moldova | MNE | Montenegro | MAF | Saint Martin |
| MDG | Madagascar | MHL | Marshall Islands | MKD | North Macedonia |
| MLI | Mali | MMR | Myanmar | MNG | Mongolia |
| MAC | Macao | MNP | Northern Mariana Islands | MTQ | Martinique |
| MRT | Mauritania | MSR | Montserrat | MLT | Malta |
| MUS | Mauritius | MDV | Maldives | MWI | Malawi |
| MEX | Mexico | MYS | Malaysia | MOZ | Mozambique |
| NAM | Namibia | NCL | New Caledonia | NER | Niger |
| NFK | Norfolk Island | NGA | Nigeria | NIC | Nicaragua |
| NLD | The Netherlands | NOR | Norway | NPL | Nepal |
| NRU | Nauru | NIU | Niue | NZL | New Zealand |
| OMN | Oman | PAN | Panama | PER | Peru |
| PYF | French Polynesia | PNG | Papua New Guinea | PHL | Philippines |
| PAK | Pakistan | POL | Poland | SPM | Saint Pierre and Miquelon |
| PCN | Pitcairn Islands | PRI | Puerto Rico | PSE | Palestine |
| PRT | Portugal | PLW | Palau | PRY | Paraguay |
| QAT | Qatar | REU | Réunion | ROU | Romania |
| SRB | Serbia | RUS | Russia | RWA | Rwanda |
| SAU | Saudi Arabia | SLB | Solomon Islands | SYC | Seychelles |
| SDN | Sudan | SWE | Sweden | SGP | Singapore |
| SHN | Saint Helena | SVN | Slovenia | SJM | Svalbard and Jan Mayen |
| SVK | Slovakia | SLE | Sierra Leone | SMR | San Marino | 

Table 5: List of Countries and their ISO-3166 Alpha-3 Codes (Part 2)

 | Code | Country | Code | Country | Code | Country |
| SEN | Senegal | SOM | Somalia | SUR | Suriname |
| SSD | South Sudan | STP | São Tomé and Príncipe | SLV | El Salvador |
| SXM | Sint Maarten | SYR | Syria | SWZ | Eswatini |
| TCA | Turks and Caicos Islands | TCD | Chad | ATF | French Southern Territories |
| TGO | Togo | THA | Thailand | TJK | Tajikistan |
| TKL | Tokelau | TLS | Timor-Leste | TKM | Turkmenistan |
| TUN | Tunisia | TON | Tonga | TUR | Türkiye |
| TTO | Trinidad and Tobago | TUV | Tuvalu | TWN | Taiwan |
| TZA | Tanzania | UKR | Ukraine | UGA | Uganda |
| UMI | U.S. Outlying Islands | USA | United States | URY | Uruguay |
| UZB | Uzbekistan | VAT | Vatican City | VCT | St Vincent and Grenadines |
| VEN | Venezuela | VGB | British Virgin Islands | VIR | U.S. Virgin Islands |
| VNM | Vietnam | VUT | Vanuatu | WLF | Wallis and Futuna |
| WSM | Samoa | XKX | Kosovo | YEM | Yemen |
| MYT | Mayotte | ZAF | South Africa | ZMB | Zambia |
| ZWE | Zimbabwe |  |  |  |  | 

### E.2 Relations and CAMEO Codes

We show the CAMEO relation codes and names, where the first-level relations are in two digits, and the second-level relations are in three digits with the first two digits be the same as its parent relation:

*   •

    01: Make public statement

    *   –

        010: Make statement, not specified

    *   –

        011: Decline comment

    *   –

        012: Make pessimistic comment

    *   –

        013: Make optimistic comment

    *   –

        014: Consider policy option

    *   –

        015: Acknowledge or claim responsibility

    *   –

        016: Reject accusation or deny responsibility

    *   –

        017: Engage in symbolic act

    *   –

        018: Make empathetic comment

    *   –

        019: Express accord

*   •

    02: Appeal

    *   –

        020: Make an appeal or request, not specified

    *   –

        021: Appeal for material cooperation

    *   –

        022: Appeal for diplomatic cooperation

    *   –

        023: Appeal for material aid

    *   –

        024: Appeal for political reform

    *   –

        025: Appeal to yield

    *   –

        026: Appeal to others to meet or negotiate

    *   –

        027: Appeal to others to settle dispute

    *   –

        028: Appeal to others to engage in or accept mediation

*   •

    03: Express intent to cooperate

    *   –

        030: Express intent to cooperate, not specified

    *   –

        031: Express intent to engage in material cooperation

    *   –

        032: Express intent to engage in diplomatic cooperation

    *   –

        033: Express intent to provide material aid

    *   –

        034: Express intent to institute political reform

    *   –

        035: Express intent to yield

    *   –

        036: Express intent to meet or negotiate

    *   –

        037: Express intent to settle dispute

    *   –

        038: Express intent to accept mediation

    *   –

        039: Express intent to mediate

*   •

    04: Consult

    *   –

        040: Consult, not specified

    *   –

        041: Discuss by telephone

    *   –

        042: Make a visit

    *   –

        043: Host a visit

    *   –

        044: Meet at a third location

    *   –

        045: Engage in mediation

    *   –

        046: Engage in negotiation

*   •

    05: Engage in diplomatic cooperation

    *   –

        050:Engage in diplomatic cooperation, not specified

    *   –

        051: Praise or endorse

    *   –

        052: Defend verbally

    *   –

        053: Rally support on behalf of

    *   –

        054: Grant diplomatic recognition

    *   –

        055: Apologize

    *   –

        056: Forgive

    *   –

        057: Sign formal agreement

*   •

    06: Engage in material cooperation

    *   –

        060: Engage in material cooperation, not specified

    *   –

        061: Cooperate economically

    *   –

        062: Cooperate militarily

    *   –

        063: Engage in judicial cooperation

    *   –

        064: Share intelligence or information

*   •

    07: Provide aid

    *   –

        070: Provide aid, not specified

    *   –

        071: Provide economic aid

    *   –

        072: Provide military aid

    *   –

        073: Provide humanitarian aid

    *   –

        074: Provide military protection or peacekeeping

    *   –

        075: Grant asylum

*   •

    08: Yield

    *   –

        080: Yield, not specified

    *   –

        081: Ease administrative sanctions

    *   –

        082: Ease political dissent

    *   –

        083: Accede to requests or demands for political reform

    *   –

        084: Return or release

    *   –

        085: Ease economic sanction or boycott or embargo

    *   –

        086: Allow international involvement

    *   –

        087: De-escalate military engagement

*   •

    09: Investigate

    *   –

        090: Investigate, not specified

    *   –

        091: Investigate crime or corruption

    *   –

        092: Investigate human rights abuses

    *   –

        093: Investigate military action

    *   –

        094: Investigate war crimes

*   •

    10: Demand

    *   –

        100: Demand, not specified

    *   –

        101: Demand material cooperation

    *   –

        102: Demand for diplomatic cooperation

    *   –

        103: Demand material aid

    *   –

        104: Demand political reform

    *   –

        105: Demand that target yield

    *   –

        106: Demand meeting or negotiation

    *   –

        107: Demand settling of dispute

    *   –

        108: Demand mediation

*   •

    11: Disapprove

    *   –

        110: Disapprove, not specified

    *   –

        111: Criticize or denounce

    *   –

        112: Accuse

    *   –

        113: Rally opposition against

    *   –

        114: Complain officially

    *   –

        115: Bring lawsuit against

    *   –

        116: Find guilty or liable (legally)

*   •

    12: Reject

    *   –

        120: All rejections and refusals

    *   –

        121: Reject material cooperation

    *   –

        122: Reject request or demand for material aid

    *   –

        123: Reject request or demand for political reform

    *   –

        124: Refuse to yield

    *   –

        125: Reject proposal to meet or discuss or negotiate

    *   –

        126: Reject mediation

    *   –

        127: Reject plan or agreement to settle dispute

    *   –

        128: Defy norms or law

    *   –

        129: Veto

*   •

    13: Threaten

    *   –

        130: Threaten, not specified

    *   –

        131: Threaten non-force

    *   –

        132: Threaten with administrative sanctions

    *   –

        133: Threaten political dissent

    *   –

        134: Threaten to halt negotiations

    *   –

        135: Threaten to halt mediation

    *   –

        136: Threaten to halt international involvement

    *   –

        137: Threaten with repression

    *   –

        138: Threaten with military force

    *   –

        139: Give ultimatum

*   •

    14: Protest

    *   –

        140: Engage in political dissent, not specified

    *   –

        141: Demonstrate or rally

    *   –

        142: Conduct hunger strike

    *   –

        143: Conduct strike or boycott

    *   –

        144: Obstruct passage or block

    *   –

        145: Protest violently or riot

*   •

    15: Exhibit military posture

    *   –

        150: Exhibit military or police power, not specified

    *   –

        151: Increase police alert status

    *   –

        152: Increase military alert status

    *   –

        153: Mobilize or increase police power

    *   –

        154: Mobilize or increase armed forces

    *   –

        155: Mobilize or increase cyber-forces

*   •

    16: Reduce relations

    *   –

        160: Reduce relations, not specified

    *   –

        161: Reduce or break diplomatic relations

    *   –

        162: Reduce or stop material aid

    *   –

        163: Impose embargo or boycott or sanctions

    *   –

        164: Halt negotiations

    *   –

        165: Halt mediation

    *   –

        166: Expel or withdraw

*   •

    17: Coerce

    *   –

        170: Coerce

    *   –

        171: Seize or damage property

    *   –

        172: Impose administrative sanctions

    *   –

        173: Arrest or detain

    *   –

        174: Expel or deport individuals

    *   –

        175: Use repression

    *   –

        176: Attack cybernetically

*   •

    18: Assault

    *   –

        180: Use unconventional violence, not specified

    *   –

        181: Abduct or hijack or take hostage

    *   –

        182: Physically assault

    *   –

        183: Conduct suicide or car or other non-military bombing

    *   –

        184: Use as human shield

    *   –

        185: Attempt to assassinate

    *   –

        186: Assassinate

*   •

    19: Fight

    *   –

        190: Use conventional military force, not specified

    *   –

        191: Impose blockade or restrict movement

    *   –

        192: Occupy territory

    *   –

        193: Fight with small arms and light weapons

    *   –

        194: Fight with artillery and tanks

    *   –

        195: Employ aerial weapons

    *   –

        196: Violate ceasefire

*   •

    20: Engage in unconventional mass violence

    *   –

        200: Use massive unconventional force, not specified

    *   –

        201: Engage in mass expulsion

    *   –

        202: Engage in mass killings

    *   –

        203: Engage in ethnic cleansing

    *   –

        204: Use weapons of mass destruction

## Appendix F Details of Dataset Construction

We construct the database based on the GDELT⁹⁹9[https://www.gdeltproject.org/](https://www.gdeltproject.org/) project, which systematically captures global news media, extracts information about countries and events mentioned, and updates this data every 15 minutes. The data stored in GDLET contains attributes about the event date, actor, action (relation), geography, and source news. The original GDELT dataset, while extensive, contains significant noise due to its rapid update frequency and the diverse nature of its sources. We thus propose the folowing data-cleaning pre-processing steps.

Events. We focus on the GDELT data from Jan. 1, 2023, to Nov. 30, 2023\. To mitigate potential information leakage, we ensured that the event date coincided exactly with its source news publish date. We standardized the CountryCode to the ISO-3166 and excluded any missing or outdated entries. As our analysis was restricted to international events, we then filte out all domestic events where the subject was identical to the object at the country level. The EventCode was standardized to the second level of the CAMEO ontology, providing a specific yet consistent level of detail. We opted not to include third-level relation information for two primary reasons: the absence of sublevel relations for all second-level categories, which introduces inconsistencies, and the higher likelihood of extraction errors in the finely detailed third-level data in the GDELT dataset.

News articles. To enhance the reliability of the information, we utilized the news sources of the events to assess credibility. Specifically, we calculated the daily mentions of each event—defined as the number of distinct news sources discussing the event—based on the 15-minute updates from GDELT. We only retained events with at least 50 daily mentions to diminish the influence of less reliable sources, such as personal blogs or advertisements, and to decrease the incidence of erroneously extracted events. We then download the news documents from the corresponding news URLs of each event. In the current database, we only keep textual information from the news, including new titles and news content. Following the OBELICS [[34](https://arxiv.org/html/2407.01231v1#bib.bib34)] protocol for web text cleaning, we applied rigorous filters at both the paragraph and document levels, targeting criteria such as a low number of words, high repetition ratios of characters and words, and an excessive presence of special characters and flagged words. These measures were crucial in significantly reducing the noise from web content.

## Appendix G Term of Use for GDELT Dataset

Based on [https://www.gdeltproject.org/about.html#termsofuse](https://www.gdeltproject.org/about.html#termsofuse), GDELT dataset “is an open platform for research and analysis of global society and thus all datasets released by the GDELT Project are available for unlimited and unrestricted use for any academic, commercial, or governmental use of any kind without fee.”, as long as “any use or redistribution of the data must include a citation to the GDELT Project and a link to this website ([https://www.gdeltproject.org/](https://www.gdeltproject.org/)).”, which we’ve cited in abstract.

## Appendix H Broader Impact

##### Positive impact.

This paper aims to construct high-level and high-quality instruction to improve the scientific reasoning capability of LLMs, which helps LLMs to better give the answers to questions at the college level. Collecting diverse instructions, annotating self-reflective instructions, and filtering out low-quality instructions provide researchers insights to prepare training datasets.

##### Negative impact.

A drawback of this work is that the scale of the training dataset and model is relatively small, and we can address this by bootstrapping a more large training dataset. We believe that the benefits of data generation manner outweigh the downside.

## Appendix I Additional Details about Agent Setup

Final answer extraction. Our agent has two stopping criteria: 1) The agent makes the final answer. 2) The reasoning process fails to reach an answer (Consecutive Invalid Actions, Consecutive Repetitive Actions, or Max Iterations Exceeded). Afterwards, we always perform an answer extraction step, which is performed by gpt-3.5-turbo. The prompt for answer extraction is shown in Appendix [K.3](https://arxiv.org/html/2407.01231v1#A11.SS3 "K.3 Answer Extraction Prompt ‣ Appendix K Prompts ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting").

## Appendix J Additional Experimental Results and Analysis

### J.1 Analysis of the Final Status of Different LLM Agents

Table 6: Average number of ReAct iterations and the number of test cases ending in different final status.

{tblr}

colspec = cccccccc, row1-2 = bg=gray!25, row5-6,9-10 = bg=gray!10 \SetCell[r=2]cModel \SetCell[r=2]cTraining Data
Cutoff Date \SetCell[r=2]cAction Type \SetCell[r=2]cAvg. Iterations \SetCell[c=4]cFinal Status
\SetCellc,mFinal Answer \SetCellc,mConsecutive
Invalid Actions \SetCellc,mConsecutive
Repetitive Actions \SetCellc,mMax Iterations
Exceeded
\SetCell[r=2]cMistral-7B \SetCell[r=2]c— Single Function 4.23 79 19 2 0
Code Block 2.84 54 45 1 0
\SetCell[r=2]cgpt-3.5-turbo \SetCell[r=2]c2021-09 Single Function 2.54 98 1 1 0
Code Block3.43 84 15 1 0
\SetCell[r=2]cgpt-4-turbo \SetCell[r=2]c2023-12 Single Function 8.76 99 0 1 0
Code Block4.68 93 5 2 0
\SetCell[r=2]cgpt-4o \SetCell[r=2]c2023-10 Single Function 8.79 98 0 0 2
Code Block5.58 95 4 1 0 

Following the experiment on different base LLMs in Sec. [3.2](https://arxiv.org/html/2407.01231v1#S3.SS2 "3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting"), we further analyze the final status of the agent when it triggers the termination conditions in the ReAct process. The agent-environment interactions were terminated based on four different statuses:

*   •

    Final Answer: This status is triggered when the model explicitly indicates completion by declaring a "final answer," indicating that it has generated its final forecast.

*   •

    Consecutive Invalid Actions: Interaction is halted if the model consecutively executes non-executable actions more than three times.

*   •

    Consecutive Repetitive Actions: A similar threshold of three consecutive repetitive actions prompts termination under this status.

*   •

    Maximum Iterations Exceeded: Termination occurs if the agent engages in more than 20 rounds of iterations without making a forecast answer.

We show the final status 1) The GPT series demonstrates enhanced capability in concluding interactions with a final answer: The GPT series frequently concludes interactions with a final answer, indicating its superior ability to comprehend instructions, utilize tools correctly, and perform reasoning to generate the final forecast. In contrast, the smaller open-source model, Mistral-7b, has a round one-quarter of cases and one-half of the cases generating consecutive invalid answers when using single function and code block, respectively, suggesting limited abilities in adhering to data types, functions, Python syntax, and following detailed instructions.

2) Generating code blocks proves more challenging than generating single functions as action: Across all models, there is a higher occurrence of errors when generating code blocks compared to single functions. This pattern highlights the greater complexity and increased likelihood of errors associated with composing multiple lines of code over simple function calls.

3) Advanced models engage in more extensive information gathering, resulting in better forecasting performance: Advanced models, such as GPT-4 Turbo and GPT-4o, engage in significantly more information gathering, with average iterations much more or even double than GPT-3.5 Turbo and Mistral-7B. This intensive data collection from the database may contribute to their enhanced performance, as previously illustrated in Table [3.2](https://arxiv.org/html/2407.01231v1#S3.SS2 "3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting"). These models exhibit better planning capability, effectively identifying and searching for related historical information.

![Refer to caption](img/7bb9964ef7e0cecd4cf71f88fdaf01e7.png)

Figure 8: Correlation of F1 Accuracy to Action Sequence Length

### J.2 Analysis on Function Types

## Appendix K Prompts

### K.1 System Prompts

The system prompt provides the necessary background information, task description, and guidelines for the LLM agent. In our case, we introduce the forecasting task, basic information of the database, the defined API, and the planning strategies in the system prompt.

#### K.1.1 System Prompt for ReAct Agent with Action Type as “Single Function”

<svg class="ltx_picture" height="675.21" id="A11.SS1.SSS1.p1.pic1" overflow="visible" version="1.1" width="600"><g fill="#000000" stroke="#000000" stroke-width="0.4pt" transform="translate(0,675.21) matrix(1 0 0 -1 0 0)"><g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 655.47)"><foreignobject color="#FFFFFF" height="13.84" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">System prompt for ReAct agent with action type as single function (part 1)</foreignobject></g> <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 13.78)"><foreignobject color="#000000" height="623.97" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">You are an expert in forecasting future events based on historical data. The database contains news articles from January 1, 2023 to the current date {current_date_nlp} and the events extracted from these articles. The events are in the form of (date, subject country, relation, object country), where the countries are represented by ISO 3166-1 alpha-3 codes and the relations are represented by the CAMEO codes defined in the ‘Conflict and Mediation Event Observations’ ontology. The relations are hierarchical: first-level relations are general parent relations represented by two-digit CAMEO codes, while second-level relations are more specific child relations represented by three-digit CAMEO codes. Child relations have the same first two digits as their parent relations. For example, ‘01’ is a first-level relation, and ‘010’ and ‘011’ are some of its second-level relations. The relations in the database are represented in the second-level form. Your task is to forecast the future relations between two entities in a given query. You have access to a defined Python API that allows you to query the database for historical events and statistics, and to get precise information about the ISO country codes and CAMEO relation codes. The defined API is described as follows: ```python {api_description} ``` You will use an iterative approach, interleaving ’Thought’, ’Action’, and ’Observation’ steps to collect information and perform the forecast. You may perform up to {max_iterations} iterations. The steps are as follows: - ‘Thought’: Analyze the current information and reason about the current situation, and predicts which API you want to use (try to use different APIs to collect diverse information) or make a decision that you want to make a final answer. - ‘Action’: Use the API to gather more information or provide the final forecast. - If using the API: the action must be only one single line of exactly one function        call from the API with appropriate inputs, without additional code, explanations, or        natural language descriptions. - If making the final forecast: the action must start immediately with ‘Final Answer:’,        and follow with the results in the expected JSON format. - ‘Observation’: Return the output of the called function. To make a reasonable forecast, you should collect both news and relational evidence to support your prediction. When you are fully confident that you accumulate enough information to make the final forecast, you should start the ‘Thought’ with your reasoning using the news and structural information to make the prediction, and then start the ‘Action’ step with ‘Final Answer:’ followed by the answer in the expected JSON format. The answer should be a JSON dictionary where the keys are the forecasted two-digit first-level CAMEO codes and the values are lists of forecasted three-digit second-level CAMEO codes that are child relations of the key. For example, ‘Action: Final Answer: "01": ["010", "011", "012"], "02": ["020", "023"]’.</foreignobject></g></g></svg><svg class="ltx_picture" height="163.16" id="A11.SS1.SSS1.p2.pic1" overflow="visible" version="1.1" width="600"><g fill="#000000" stroke="#000000" stroke-width="0.4pt" transform="translate(0,163.16) matrix(1 0 0 -1 0 0)"><g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 143.42)"><foreignobject color="#FFFFFF" height="13.84" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">System prompt for ReAct agent with action type as single function (part 2)</foreignobject></g> <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 13.78)"><foreignobject color="#000000" height="111.93" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">The final answer will be evaluated based on the precision and recall of the forecasted first-level and second-level relations, so only include confident first-level and second-level CAMEO codes in your final forecast. Try to use different APIs to collect diverse information (including multi-hop relations), such as the precise meaning of CAMEO codes, insights from news content, relational data, and statistical analyses to support your forecasts. Consider not only the frequency of the relations but also the temporal aspects of the data when making your forecast.</foreignobject></g></g></svg>

#### K.1.2 System Prompt for ReAct Agent with Action Type as “Code Block”

<svg class="ltx_picture" height="644.69" id="A11.SS1.SSS2.p1.pic1" overflow="visible" version="1.1" width="600"><g fill="#000000" stroke="#000000" stroke-width="0.4pt" transform="translate(0,644.69) matrix(1 0 0 -1 0 0)"><g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 624.95)"><foreignobject color="#FFFFFF" height="13.84" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">System prompt for ReAct agent with action type as code block (part 1)</foreignobject></g> <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 13.78)"><foreignobject color="#000000" height="593.45" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">You are an expert in forecasting future events based on historical data. The database contains news articles from January 1, 2023 to the current date {current_date_nlp} and the events extracted from these articles. The events are in the form of (date, subject country, relation, object country), where the countries are represented by ISO 3166-1 alpha-3 codes and the relations are represented by the CAMEO codes defined in the ‘Conflict and Mediation Event Observations’ ontology. The relations are hierarchical: first-level relations are general parent relations represented by two-digit CAMEO codes, while second-level relations are more specific child relations represented by three-digit CAMEO codes. Child relations have the same first two digits as their parent relations. For example, ‘01’ is a first-level relation, and ‘010’ and ‘011’ are some of its second-level relations. The relations in the database are represented in the second-level form. Your task is to forecast the future relations between two entities in a given query. You have access to a defined Python API that allows you to query the database for historical events and statistics, and to get precise information about the ISO country codes and CAMEO relation codes. You are also authorized to utilize additional safe, well-established Python libraries such as numpy, pandas, scikit-learn, and NetworkX to enhance your data analysis and forecasting accuracy. The defined API is described as follows: ``` python {api_description} ``` You will use an iterative approach, interleaving ‘Thought’, ‘Action’, and ‘Observation’ steps to collect information and perform the forecast. You may perform up to max_iterations iterations. The steps are as follows: - ‘Thought’: Analyze the current information and reason about the current situation, and predicts which API you want to use (try to use different APIs to collect diverse information) or make a decision that you want to make a final answer. - ‘Action’: Use the API to gather more information or provide the final forecast. - If gathering more data: the action must be an executable Python code snippet that        starts with ‘```python’ and ends with ‘```’. It can contain multiple lines of codes and        function calls using the defined API or Python libraries. You must use print() to output        the results, and only the printed output will be returned in the observation step. - If making the final forecast: the action must start immediately with ‘Final Answer:’,        and follow with the answer in the expected JSON format. This should not be enclosed        within triple backticks. - ‘Observation’: Return the printed output of the executed code snippet.</foreignobject></g></g></svg><svg class="ltx_picture" height="316.91" id="A11.SS1.SSS2.p2.pic1" overflow="visible" version="1.1" width="600"><g fill="#000000" stroke="#000000" stroke-width="0.4pt" transform="translate(0,316.91) matrix(1 0 0 -1 0 0)"><g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 297.17)"><foreignobject color="#FFFFFF" height="13.84" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">System prompt for ReAct agent with action type as code block (part 2)</foreignobject></g> <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 13.78)"><foreignobject color="#000000" height="265.67" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">To make a reasonable forecast, you should collect both news and relational evidence to support your prediction. When you are fully confident that you accumulate enough information to make the final forecast, you should start the ‘Thought’ with your reasoning using the news and structural information to make the prediction, and then start the ‘Action’ step with ‘Final Answer:’ followed by the answer in the expected JSON format. The answer should be a JSON dictionary where the keys are the forecasted two-digit first-level CAMEO codes and the values are lists of forecasted three-digit second-level CAMEO codes that are child relations of the key. For example, ‘Action: Final Answer: {"01": ["010", "011", "012"], "02": ["020", "023"]}’. The final answer will be evaluated based on the precision and recall of the forecasted first-level and second-level relations, so only include confident first-level and second-level CAMEO codes in your final forecast. Try to use different APIs and Python libraries to collect diverse information (including multi-hop relations), such as the precise meaning of CAMEO codes, insights from news content, relational data, and statistical analyses to support your forecasts. Consider not only the frequency of the relations but also the temporal aspects of the data when making your forecast.</foreignobject></g></g></svg>

#### K.1.3 System Prompt for Direct Agent

<svg class="ltx_picture" height="327.67" id="A11.SS1.SSS3.p1.pic1" overflow="visible" version="1.1" width="600"><g fill="#000000" stroke="#000000" stroke-width="0.4pt" transform="translate(0,327.67) matrix(1 0 0 -1 0 0)"><g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 309.47)"><foreignobject color="#FFFFFF" height="12.3" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">System prompt for direct agent</foreignobject></g> <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 13.78)"><foreignobject color="#000000" height="277.97" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">You are an expert in forecasting future events based on historical data. The events are in the form of (date, subject country, relation, object country), where the countries are represented by ISO 3166-1 alpha-3 codes and the relations are represented by the CAMEO codes defined in the ‘Conflict and Mediation Event Observations’ ontology. The relations are hierarchical: first-level relations are general parent relations represented by two-digit CAMEO codes, while second-level relations are more specific child relations represented by three-digit CAMEO codes. Child relations have the same first two digits as their parent relations. For example, ‘01’ is a first-level relation, and ‘010’ and ‘011’ are some of its second-level relations. The relations in the database are represented in the second-level form. Your task is to forecast the future relations between two entities in a given query. The answer should be a JSON dictionary where the keys are the forecasted two-digit first-level CAMEO codes and the values are lists of forecasted three-digit second-level CAMEO codes that are child relations of the key. For example, ‘Final Answer: {{“01”: [“010”, “011”, “012”], “02”: [“020”, “023”]}}’. The final answer will be evaluated based on the precision and recall of the forecasted first-level and second-level relations, so only include confident first-level and second-level CAMEO codes in your final forecast.</foreignobject></g></g></svg>

#### K.1.4 System Prompt for CoT Agent

<svg class="ltx_picture" height="377.48" id="A11.SS1.SSS4.p1.pic1" overflow="visible" version="1.1" width="600"><g fill="#000000" stroke="#000000" stroke-width="0.4pt" transform="translate(0,377.48) matrix(1 0 0 -1 0 0)"><g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 359.28)"><foreignobject color="#FFFFFF" height="12.3" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">System prompt for CoT</foreignobject></g> <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 13.78)"><foreignobject color="#000000" height="327.78" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">You are an expert in forecasting future events based on historical data. The events are in the form of (date, subject country, relation, object country), where the countries are represented by ISO 3166-1 alpha-3 codes and the relations are represented by the CAMEO codes defined in the ‘Conflict and Mediation Event Observations’ ontology. The relations are hierarchical: first-level relations are general parent relations represented by two-digit CAMEO codes, while second-level relations are more specific child relations represented by three-digit CAMEO codes. Child relations have the same first two digits as their parent relations. For example, ‘01’ is a first-level relation, and ‘010’ and ‘011’ are some of its second-level relations. The relations in the database are represented in the second-level form. Your task is to forecast the future relations between two entities in a given query. To make a reasonable forecast, you should first think and reason based on your background knowledge. When you are confident that you have conducted enough analysis to make the final answer, you should start answering by ’Therefore, the final answer is:‘ followed by the answer in the expected JSON format. The JSON format should be a JSON dictionary where the keys are the forecasted two-digit first-level CAMEO codes and the values are lists of forecasted three-digit second-level CAMEO codes that are child relations of the key. For example, ‘{{“01”: [“010”, “011”, “012”], “02”: [“020”, “023”]}}’. The final answer will be evaluated based on the precision and recall of the forecasted first-level and second-level relations, so only include confident first-level and second-level CAMEO codes in your final forecast.</foreignobject></g></g></svg>

### K.2 Query Prompt

<svg class="ltx_picture" height="113.2" id="A11.SS2.p1.pic1" overflow="visible" version="1.1" width="600"><g fill="#000000" stroke="#000000" stroke-width="0.4pt" transform="translate(0,113.2) matrix(1 0 0 -1 0 0)"><g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 95.15)"><foreignobject color="#FFFFFF" height="12.15" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">Query prompt</foreignobject></g> <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 13.78)"><foreignobject color="#000000" height="63.65" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">Please forecast the relations that {actor1_name} will take towards {actor2_name} on {future_date_nlp} based on historical information up to {current_date_nlp}. I.e. forecast the relation CAMEO codes in query event Event(date={future_date}, head_entity=ISOCode({actor1_code}), relation=CAMEOCode(?), tail_entity=ISOCode({actor2_code})).</foreignobject></g></g></svg>

### K.3 Answer Extraction Prompt

<svg class="ltx_picture" height="543.37" id="A11.SS3.p1.pic1" overflow="visible" version="1.1" width="600"><g fill="#000000" stroke="#000000" stroke-width="0.4pt" transform="translate(0,543.37) matrix(1 0 0 -1 0 0)"><g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 525.32)"><foreignobject color="#FFFFFF" height="12.15" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">Answer extraction prompt</foreignobject></g> <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 13.78)"><foreignobject color="#000000" height="493.83" overflow="visible" transform="matrix(1 0 0 -1 0 16.6)" width="556.69">Please help me extract final answer for forecasting the future relations between two entities in a given query: forecast the relations that {actor1_name} will take towards {actor2_name} on {future_date_nlp} based on historical information up to current_date_nlp. I.e. forecast the relation CAMEO codes in query event Event(date={future_date}, head_entity=ISOCode({actor1_code}), relation=CAMEOCode(?), tail_entity=ISOCode({actor2_code})). I have used interleaving ‘Thought’, ‘Action’, and ‘Observation’ steps to collect information from the database and perform the forecast. The database contains news articles from January 1, 2023 to the current date current_date_nlp and the events extracted from these articles. The events are in the form of (date, subject country, relation, object country), where the countries are represented by ISO 3166-1 alpha-3 codes and the relations are represented by the CAMEO codes defined in the ‘Conflict and Mediation Event Observations’ ontology. The relations are hierarchical: first-level relations are general parent relations represented by two-digit CAMEO codes, while second-level relations are more specific child relations represented by three-digit CAMEO codes. Child relations have the same first two digits as their parent relations. For example, ‘01’ is a first-level relation, and ‘010’ and ‘011’ are some of its second-level relations. The relations in the database are represented in the second-level form. The final forecast answer need to forecast both first-level and second-level CAMEO codes, and will be evaluated based on the precision and recall of both levels of relations. The final answer content should be a JSON dictionary where the keys are the forecasted two-digit first-level CAMEO codes and the values are lists of forecasted three-digit second-level CAMEO codes that are child relations of the key. For example, {{“01”: [“010”, “011”, “012”], “02”: [“020”, “023”]}}. The latest information and forecast I have collected is as follows: {info} If final forecast answer has been made in the collected information indicated by "Final Answer:", you must only reformat the final forecast answer in the expected JSON dictionary format inside XML tags. For example: <answer>{{“01”: [“010”, “011”, “012”], “02”: [“020”, “023”]}}</answer>. Otherwise, if no final forecast is made, you must reason based on the information you have collected and generate a confident final forecast answer to the query, and then reformat your answer in the expected JSON dictionary format inside XML tags.</foreignobject></g></g></svg>

## Appendix L Additional Forecasting Examples of LLM Agent

In this section, we show examples of how LLM agents perform reasoning for the forecasting query. The query-specific values are highlighted in yellow in the system prompt and query prompt, which follows the prompt templates shown in Appendix [K](https://arxiv.org/html/2407.01231v1#A11 "Appendix K Prompts ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting"). For simplicity, we use {api_description} as a placeholder for the API specification in the prompt, which is replaced by the actual contents shown in Appendix [M](https://arxiv.org/html/2407.01231v1#A13 "Appendix M Additional Information about API ‣ item 1 ‣ L.1.4 Agent ReAct Process ‣ L.1 GPT-4o-based Agent with ReAct and “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent ‣ J.2 Analysis on Function Types ‣ J.1 Analysis of the Final Status of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4.2 Evaluation of Language Agents ‣ 4.1 Temporal Reasoning Benchmarks ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting") in experiments.

### L.1 GPT-4o-based Agent with ReAct and “Code Block” Action

#### L.1.1 Query Details

*   •

    Query Quadruplet: (2023-11-03, AUS, ?, CHN)

*   •

    Temporal Distance: 1; therefore, the current date is 2023-11-02

*   •

    Agent Max Steps: 20

#### L.1.2 Query Prompt

Please forecast the relations that Australia will take towards China on November 03, 2023 based on historical information up to November 02, 2023. I.e. forecast the relation CAMEO codes in query event Event(date=2023-11-03, head_entity=ISOCode(AUS), relation=CAMEOCode(?), tail_entity=ISOCode(CHN)).

#### L.1.3 System Prompt

You are an expert in forecasting future events based on historical data. The database contains news articles from January 1, 2023 to the current date November 02, 2023 and the events extracted from these articles. The events are in the form of (date, subject country, relation, object country), where the countries are represented by ISO 3166-1 alpha-3 codes and the relations are represented by the CAMEO codes defined in the "Conflict and Mediation Event Observations" ontology. The relations are hierarchical: first-level relations are general parent relations represented by two-digit CAMEO codes, while second-level relations are more specific child relations represented by three-digit CAMEO codes. Child relations have the same first two digits as their parent relations. For example, "01" is a first-level relation, and "010" and "011" are some of its second-level relations. The relations in the database are represented in the second-level form.

Your task is to forecast the future relations between two entities in a given query. You have access to a defined Python API that allows you to query the database for historical events and statistics, and to get precise information about the ISO country codes and CAMEO relation codes. You are also authorized to utilize additional safe, well-established Python libraries such as numpy, pandas, scikit-learn, and NetworkX to enhance your data analysis and forecasting accuracy.

The defined API is described as follows:
``` python
{api_description} ```

You will use an iterative approach, interleaving "Thought", "Action", and "Observation" steps to collect information and perform the forecast. You may perform up to 20 iterations. The steps are as follows:

- "Thought": Analyze the current information and reason about the current situation, and predicts which API you want to use (try to use different APIs to collect diverse information) or make a decision that you want to make a final answer.
- "Action": Use the API to gather more information or provide the final forecast.
      - If gathering more data: the action must be an executable Python code snippet that starts with ```python and ends with ```. It can contain multiple lines of codes and function calls using the defined API or Python libraries. You must use print() to output the results, and only the printed output will be returned in the observation step.
      - If making the final forecast: the action must start immediately with "Final Answer:", and follow with the answer in the expected JSON format. This should not be enclosed within triple backticks.
- "Observation": Return the printed output of the executed code snippet.

To make a reasonable forecast, you should collect both news and relational evidence to support your prediction. When you are fully confident that you accumulate enough information to make the final forecast, you should start the "Thought" with your reasoning using the news and structural information to make the prediction, and then start the "Action" step with "Final Answer:" followed by the answer in the expected JSON format. The answer should be a JSON dictionary where the keys are the forecasted two-digit first-level CAMEO codes and the values are lists of forecasted three-digit second-level CAMEO codes that are child relations of the key. For example, "Action: Final Answer: {"01": ["010", "011", "012"], "02": ["020", "023"]}".

The final answer will be evaluated based on the precision and recall of the forecasted first-level and second-level relations, so only include confident first-level and second-level CAMEO codes in your final forecast.

Try to use different APIs and Python libraries to collect diverse information (including multi-hop relations), such as the precise meaning of CAMEO codes, insights from news content, relational data, and statistical analyses to support your forecasts. Consider not only the frequency of the relations but also the temporal aspects of the data when making your forecast.

#### L.1.4 Agent ReAct Process

1.  1.

    Thought: To forecast the relations that Australia will take towards China on November 03, 2023, we need to gather historical data on the interactions between these two countries. This includes examining the frequency and types of relations observed in the past, as well as any recent trends or significant events that might influence future relations.

    We will proceed with the following steps:

    1.  (a)

        Retrieve Historical Events: Gather events involving Australia (AUS) and China (CHN) to understand the context and types of relations that have occurred in the past.

    2.  (b)

        Analyze Relation Distribution: Analyze the distribution of different CAMEO codes in these events to identify the most common types of interactions.

    3.  (c)

        Examine Recent Trends: Focus on recent events to detect any emerging trends or shifts in relations.

    4.  (d)

        Contextual Analysis: Review news articles to gain insights into the context and underlying reasons for these relations.

    Let"s start by retrieving historical events between Australia and China.

    Action:

    [⬇](data:text/plain;base64,ZnJvbSBkYXRldGltZSBpbXBvcnQgZGF0ZXRpbWUKCiMgRGVmaW5lIHRoZSBkYXRlIHJhbmdlIGZvciB0aGUgaGlzdG9yaWNhbCBkYXRhIGNvbGxlY3Rpb24Kc3RhcnRfZGF0ZSA9IERhdGUoIjIwMjMtMDEtMDEiKQplbmRfZGF0ZSA9IERhdGUoIjIwMjMtMTEtMDIiKQpkYXRlX3JhbmdlID0gRGF0ZVJhbmdlKHN0YXJ0X2RhdGU9c3RhcnRfZGF0ZSwgZW5kX2RhdGU9ZW5kX2RhdGUpCgojIERlZmluZSB0aGUgSVNPIGNvZGVzIGZvciBBdXN0cmFsaWEgYW5kIENoaW5hCmF1c19jb2RlID0gSVNPQ29kZSgiQVVTIikKY2huX2NvZGUgPSBJU09Db2RlKCJDSE4iKQoKIyBSZXRyaWV2ZSBoaXN0b3JpY2FsIGV2ZW50cyBpbnZvbHZpbmcgQXVzdHJhbGlhIGFuZCBDaGluYQpldmVudHMgPSBnZXRfZXZlbnRzKGRhdGVfcmFuZ2U9ZGF0ZV9yYW5nZSwgaGVhZF9lbnRpdGllcz1bYXVzX2NvZGVdLCB0YWlsX2VudGl0aWVzPVtjaG5fY29kZV0pCgojIFByaW50IHRoZSByZXRyaWV2ZWQgZXZlbnRzCmZvciBldmVudCBpbiBldmVudHM6CiAgICBwcmludChldmVudClcZW5ke2xzdGxpc3Rpbmd9CiAgICBcdGV4dGJme09ic2VydmF0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMS0wMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMS0wMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDAiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMS0wMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMS0wMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMS0wMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIxNzMiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMS0wMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0zMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0zMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0zMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0zMCIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0zMCIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0zMCIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yOSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yNyIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yNyIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yNiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIxNzMiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yNiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNjEiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yNiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yNSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMyIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMyIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMyIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzEiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMyIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNjEiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDAiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNjEiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDMiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDAiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpXGVuZHtsc3RsaXN0aW5nfQogICAgXGl0ZW0gXHRleHRiZntUaG91Z2h0fToKICAgIFRoZSByZXRyaWV2ZWQgZXZlbnRzIGluZGljYXRlIGEgdmFyaWV0eSBvZiByZWxhdGlvbnMgYmV0d2VlbiBBdXN0cmFsaWEgYW5kIENoaW5hLiBUbyBmb3JlY2FzdCB0aGUgZnV0dXJlIHJlbGF0aW9ucywgd2UgbmVlZCB0byBhbmFseXplIHRoZSBkaXN0cmlidXRpb24gb2YgdGhlc2UgcmVsYXRpb25zIHRvIGlkZW50aWZ5IHRoZSBtb3N0IGNvbW1vbiB0eXBlcyBhbmQgYW55IHJlY2VudCB0cmVuZHMuCgogICAgTmV4dCwgd2Ugd2lsbCBhbmFseXplIHRoZSBkaXN0cmlidXRpb24gb2YgdGhlIGRpZmZlcmVudCBDQU1FTyBjb2RlcyBpbiB0aGVzZSBldmVudHMgdG8gaWRlbnRpZnkgdGhlIG1vc3QgZnJlcXVlbnQgaW50ZXJhY3Rpb25zLiBUaGlzIHdpbGwgaGVscCB1cyB1bmRlcnN0YW5kIHRoZSBkb21pbmFudCB0eXBlcyBvZiByZWxhdGlvbnMgYW5kIGFueSBlbWVyZ2luZyBwYXR0ZXJucy4KCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQpmcm9tIGNvbGxlY3Rpb25zIGltcG9ydCBDb3VudGVyCgojIEV4dHJhY3QgdGhlIENBTUVPIGNvZGVzIGZyb20gdGhlIHJldHJpZXZlZCBldmVudHMKY2FtZW9fY29kZXMgPSBbZXZlbnQucmVsYXRpb24uY29kZSBmb3IgZXZlbnQgaW4gZXZlbnRzXQoKIyBDb3VudCB0aGUgZnJlcXVlbmN5IG9mIGVhY2ggQ0FNRU8gY29kZQpjYW1lb19jb2RlX2NvdW50cyA9IENvdW50ZXIoY2FtZW9fY29kZXMpCgojIFByaW50IHRoZSBkaXN0cmlidXRpb24gb2YgQ0FNRU8gY29kZXMKZm9yIGNvZGUsIGNvdW50IGluIGNhbWVvX2NvZGVfY291bnRzLml0ZW1zKCk6CiAgICBwcmludChmIkNBTUVPIENvZGU6IHtjb2RlfSwgQ291bnQ6IHtjb3VudH0iKVxlbmR7bHN0bGlzdGluZ30KICAgIFx0ZXh0YmZ7T2JzZXJ2YXRpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KQ0FNRU8gQ29kZTogMDQyLCBDb3VudDogMTAKQ0FNRU8gQ29kZTogMDQwLCBDb3VudDogMwpDQU1FTyBDb2RlOiAwMzYsIENvdW50OiA4CkNBTUVPIENvZGU6IDE3MywgQ291bnQ6IDIKQ0FNRU8gQ29kZTogMDQ2LCBDb3VudDogMgpDQU1FTyBDb2RlOiAwNjEsIENvdW50OiAzCkNBTUVPIENvZGU6IDAzMSwgQ291bnQ6IDEKQ0FNRU8gQ29kZTogMDQzLCBDb3VudDogMVxlbmR7bHN0bGlzdGluZ30KICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBUaGUgZGlzdHJpYnV0aW9uIG9mIENBTUVPIGNvZGVzIGZyb20gdGhlIGhpc3RvcmljYWwgZXZlbnRzIGJldHdlZW4gQXVzdHJhbGlhIGFuZCBDaGluYSByZXZlYWxzIHRoYXQgY2VydGFpbiB0eXBlcyBvZiBpbnRlcmFjdGlvbnMgYXJlIG1vcmUgZnJlcXVlbnQgdGhhbiBvdGhlcnMuIFNwZWNpZmljYWxseSwgdGhlIG1vc3QgY29tbW9uIHJlbGF0aW9ucyBhcmU6CgogICAgLSBcdGV4dGJmezA0Mn06IDEwIG9jY3VycmVuY2VzXFwKICAgIC0gXHRleHRiZnswMzZ9OiA4IG9jY3VycmVuY2VzXFwKICAgIC0gXHRleHRiZnswNDB9OiAzIG9jY3VycmVuY2VzXFwKICAgIC0gXHRleHRiZnswNjF9OiAzIG9jY3VycmVuY2VzXFwKICAgIC0gXHRleHRiZnswNDZ9OiAyIG9jY3VycmVuY2VzXFwKICAgIC0gXHRleHRiZnsxNzN9OiAyIG9jY3VycmVuY2VzXFwKICAgIC0gXHRleHRiZnswMzF9OiAxIG9jY3VycmVuY2VcXAogICAgLSBcdGV4dGJmezA0M306IDEgb2NjdXJyZW5jZVxcCiAgICBUbyBtYWtlIGEgbW9yZSBpbmZvcm1lZCBmb3JlY2FzdCwgd2Ugc2hvdWxkIHVuZGVyc3RhbmQgd2hhdCB0aGVzZSBDQU1FTyBjb2RlcyByZXByZXNlbnQuIFdlIHdpbGwgbWFwIHRoZXNlIGNvZGVzIHRvIHRoZWlyIGRlc2NyaXB0aW9ucyB0byBnYWluIGluc2lnaHRzIGludG8gdGhlIG5hdHVyZSBvZiB0aGVzZSBpbnRlcmFjdGlvbnMuCgogICAgXHRleHRiZntBY3Rpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KIyBEZWZpbmUgdGhlIENBTUVPIGNvZGVzIHRvIG1hcApjYW1lb19jb2Rlc190b19tYXAgPSBbIjA0MiIsICIwMzYiLCAiMDQwIiwgIjA2MSIsICIwNDYiLCAiMTczIiwgIjAzMSIsICIwNDMiXQoKIyBNYXAgdGhlIENBTUVPIGNvZGVzIHRvIHRoZWlyIGRlc2NyaXB0aW9ucwpyZWxhdGlvbnMgPSBbbWFwX2NhbWVvX3RvX3JlbGF0aW9uKENBTUVPQ29kZShjb2RlKSkgZm9yIGNvZGUgaW4gY2FtZW9fY29kZXNfdG9fbWFwXQoKIyBQcmludCB0aGUgZGVzY3JpcHRpb25zIG9mIHRoZSBDQU1FTyBjb2Rlcwpmb3IgcmVsYXRpb24gaW4gcmVsYXRpb25zOgogICAgcHJpbnQoZiJDQU1FTyBDb2RlOiB7cmVsYXRpb24uY2FtZW9fY29kZS5jb2RlfSwgTmFtZToge3JlbGF0aW9uLm5hbWV9LCBEZXNjcmlwdGlvbjoge3JlbGF0aW9uLmRlc2NyaXB0aW9ufSIpXGVuZHtsc3RsaXN0aW5nfQogICAgXHRleHRiZntPYnNlcnZhdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQpDQU1FTyBDb2RlOiAwNDIsIE5hbWU6IE1ha2UgYSB2aXNpdCwgRGVzY3JpcHRpb246IFRyYXZlbCB0byBhbm90aGVyIGxvY2F0aW9uIGZvciBhIG1lZXRpbmcgb3Igb3RoZXIgZXZlbnQuCkNBTUVPIENvZGU6IDAzNiwgTmFtZTogRXhwcmVzcyBpbnRlbnQgdG8gbWVldCBvciBuZWdvdGlhdGUsIERlc2NyaXB0aW9uOiBPZmZlciwgcHJvbWlzZSwgYWdyZWUgdG8sIG9yIG90aGVyd2lzZSBpbmRpY2F0ZSB3aWxsaW5nbmVzcyBvciBjb21taXRtZW50IHRvIG1lZXQsIHZpc2l0LCBvciBlbmdhZ2UgaW4gdGFsa3Mgb3IgbmVnb3RpYXRpb25zLgpDQU1FTyBDb2RlOiAwNDAsIE5hbWU6IENvbnN1bHQsIG5vdCBzcGVjaWZpZWQsIERlc2NyaXB0aW9uOiBBbGwgY29uc3VsdGF0aW9ucyBhbmQgbWVldGluZ3MsIG5vdCBvdGhlcndpc2Ugc3BlY2lmaWVkLgpDQU1FTyBDb2RlOiAwNjEsIE5hbWU6IENvb3BlcmF0ZSBlY29ub21pY2FsbHksIERlc2NyaXB0aW9uOiBJbml0aWF0ZSwgcmVzdW1lLCBpbXByb3ZlLCBvciBleHBhbmQgZWNvbm9taWMgZXhjaGFuZ2Ugb3IgY29vcGVyYXRpb24uCkNBTUVPIENvZGU6IDA0NiwgTmFtZTogRW5nYWdlIGluIG5lZ290aWF0aW9uLCBEZXNjcmlwdGlvbjogTmVnb3RpYXRlIG9yIGJhcmdhaW4gd2l0aCBvdGhlcnMuCkNBTUVPIENvZGU6IDE3MywgTmFtZTogQXJyZXN0IG9yIGRldGFpbiwgRGVzY3JpcHRpb246IExlZ2FsIG9yIGV4dHJhanVkaWNpYWwgYXJyZXN0cywgZGV0ZW50aW9ucywgb3IgaW1wcmlzb25tZW50cy4KQ0FNRU8gQ29kZTogMDMxLCBOYW1lOiBFeHByZXNzIGludGVudCB0byBlbmdhZ2UgaW4gbWF0ZXJpYWwgY29vcGVyYXRpb24sIERlc2NyaXB0aW9uOiBPZmZlciwgcHJvbWlzZSwgYWdyZWUgdG8sIG9yIG90aGVyd2lzZSBpbmRpY2F0ZSB3aWxsaW5nbmVzcyBvciBjb21taXRtZW50IHRvIGVuZ2FnZSBpbiBvciBleHBhbmQgbWF0ZXJpYWwgY29vcGVyYXRpdmUgZXhjaGFuZ2UsIHN1Y2ggYXMgZXhwcmVzcyBpbnRlbnQgdG8gY29vcGVyYXRlIGVjb25vbWljYWxseSwgbWlsaXRhcmlseSwgb24ganVkaWNpYWwgbWF0dGVycywgYW5kIG9uIGludGVsbGlnZW5jZS4KQ0FNRU8gQ29kZTogMDQzLCBOYW1lOiBIb3N0IGEgdmlzaXQsIERlc2NyaXB0aW9uOiBIb3N0IG9yIHJlY2VpdmUgYSB2aXNpdG9yIGF0IHJlc2lkZW5jZSwgb2ZmaWNlIG9yIGhvbWUgY291bnRyeS5cZW5ke2xzdGxpc3Rpbmd9CiAgICBcaXRlbSBcdGV4dGJme1Rob3VnaHR9OgogICAgVGhlIG1hcHBlZCBDQU1FTyBjb2RlcyBhbmQgdGhlaXIgZGVzY3JpcHRpb25zIHByb3ZpZGUgdmFsdWFibGUgaW5zaWdodHMgaW50byB0aGUgbmF0dXJlIG9mIGludGVyYWN0aW9ucyBiZXR3ZWVuIEF1c3RyYWxpYSBhbmQgQ2hpbmEuIEhlcmUgYXJlIHRoZSBrZXkgcmVsYXRpb25zIG9ic2VydmVkOgoKICAgIC0gXHRleHRiZnswNDIgKE1ha2UgYSB2aXNpdCl9OiAxMCBvY2N1cnJlbmNlcyDigJMgSW5kaWNhdGVzIGZyZXF1ZW50IHRyYXZlbCBmb3IgbWVldGluZ3Mgb3IgZXZlbnRzLlxcCiAgICAtIFx0ZXh0YmZ7MDM2IChFeHByZXNzIGludGVudCB0byBtZWV0IG9yIG5lZ290aWF0ZSl9OiA4IG9jY3VycmVuY2VzIOKAkyBTaG93cyBhIHN0cm9uZyBpbnRlbnQgdG8gZW5nYWdlIGluIHRhbGtzIG9yIG5lZ290aWF0aW9ucy5cXAogICAgLSBcdGV4dGJmezA0MCAoQ29uc3VsdCwgbm90IHNwZWNpZmllZCl9OiAzIG9jY3VycmVuY2VzIOKAkyBHZW5lcmFsIGNvbnN1bHRhdGlvbnMgYW5kIG1lZXRpbmdzLlxcCiAgICAtIFx0ZXh0YmZ7MDYxIChDb29wZXJhdGUgZWNvbm9taWNhbGx5KX06IDMgb2NjdXJyZW5jZXMg4oCTIEVjb25vbWljIGNvb3BlcmF0aW9uIGluaXRpYXRpdmVzLlxcCiAgICAtIFx0ZXh0YmZ7MDQ2IChFbmdhZ2UgaW4gbmVnb3RpYXRpb24pfTogMiBvY2N1cnJlbmNlcyDigJMgQWN0dWFsIG5lZ290aWF0aW9ucyBvciBiYXJnYWluaW5nLlxcCiAgICAtIFx0ZXh0YmZ7MTczIChBcnJlc3Qgb3IgZGV0YWluKX06IDIgb2NjdXJyZW5jZXMg4oCTIExlZ2FsIG9yIGV4dHJhanVkaWNpYWwgYXJyZXN0cyBvciBkZXRlbnRpb25zLlxcCiAgICAtIFx0ZXh0YmZ7MDMxIChFeHByZXNzIGludGVudCB0byBlbmdhZ2UgaW4gbWF0ZXJpYWwgY29vcGVyYXRpb24pfTogMSBvY2N1cnJlbmNlIOKAkyBJbnRlbnQgdG8gY29vcGVyYXRlIG1hdGVyaWFsbHkuXFwKICAgIC0gXHRleHRiZnswNDMgKEhvc3QgYSB2aXNpdCl9OiAxIG9jY3VycmVuY2Ug4oCTIEhvc3RpbmcgdmlzaXRvcnMuXFwKCiAgICBHaXZlbiB0aGlzIGRhdGEsIHdlIGNhbiBzZWUgdGhhdCB0aGUgbW9zdCBmcmVxdWVudCBpbnRlcmFjdGlvbnMgaW52b2x2ZSB2aXNpdHMsIGV4cHJlc3Npb25zIG9mIGludGVudCB0byBtZWV0IG9yIG5lZ290aWF0ZSwgYW5kIGVjb25vbWljIGNvb3BlcmF0aW9uLiBUaGVzZSBpbnRlcmFjdGlvbnMgc3VnZ2VzdCBhIHBhdHRlcm4gb2YgZGlwbG9tYXRpYyBlbmdhZ2VtZW50IGFuZCBlY29ub21pYyBjb2xsYWJvcmF0aW9uLCB3aXRoIG9jY2FzaW9uYWwgbGVnYWwgYWN0aW9ucy4KCiAgICBUbyBmdXJ0aGVyIHNvbGlkaWZ5IG91ciBmb3JlY2FzdCwgd2Ugc2hvdWxkIGV4YW1pbmUgcmVjZW50IG5ld3MgYXJ0aWNsZXMgdG8gdW5kZXJzdGFuZCB0aGUgY29udGV4dCBhbmQgYW55IHVuZGVybHlpbmcgcmVhc29ucyBmb3IgdGhlc2UgaW50ZXJhY3Rpb25zLiBUaGlzIHdpbGwgaGVscCB1cyBpZGVudGlmeSBhbnkgZW1lcmdpbmcgdHJlbmRzIG9yIHNpZ25pZmljYW50IGV2ZW50cyB0aGF0IG1pZ2h0IGluZmx1ZW5jZSBmdXR1cmUgcmVsYXRpb25zLgoKICAgIE5leHQsIHdlIHdpbGwgcmV0cmlldmUgcmVjZW50IG5ld3MgYXJ0aWNsZXMgaW52b2x2aW5nIEF1c3RyYWxpYSBhbmQgQ2hpbmEgdG8gZ2FpbiBjb250ZXh0dWFsIGluc2lnaHRzLgoKICAgIFx0ZXh0YmZ7QWN0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dCiMgRGVmaW5lIHRoZSBkYXRlIHJhbmdlIGZvciByZWNlbnQgbmV3cyBhcnRpY2xlcwpyZWNlbnRfc3RhcnRfZGF0ZSA9IERhdGUoIjIwMjMtMTAtMDEiKQpyZWNlbnRfZW5kX2RhdGUgPSBEYXRlKCIyMDIzLTExLTAyIikKcmVjZW50X2RhdGVfcmFuZ2UgPSBEYXRlUmFuZ2Uoc3RhcnRfZGF0ZT1yZWNlbnRfc3RhcnRfZGF0ZSwgZW5kX2RhdGU9cmVjZW50X2VuZF9kYXRlKQoKIyBSZXRyaWV2ZSByZWNlbnQgbmV3cyBhcnRpY2xlcyBpbnZvbHZpbmcgQXVzdHJhbGlhIGFuZCBDaGluYQpuZXdzX2FydGljbGVzID0gZ2V0X25ld3NfYXJ0aWNsZXMoZGF0ZV9yYW5nZT1yZWNlbnRfZGF0ZV9yYW5nZSwgaGVhZF9lbnRpdGllcz1bYXVzX2NvZGVdLCB0YWlsX2VudGl0aWVzPVtjaG5fY29kZV0pCgojIFByaW50IHRoZSByZXRyaWV2ZWQgbmV3cyBhcnRpY2xlcwpmb3IgYXJ0aWNsZSBpbiBuZXdzX2FydGljbGVzOgogICAgcHJpbnQoYXJ0aWNsZSlcZW5ke2xzdGxpc3Rpbmd9CiAgICBcdGV4dGJme09ic2VydmF0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIk5vIHF1aWNrIGZpeCB0byByZW1haW5pbmcgdGFyaWZmcyBhaGVhZCBvZiBDaGluYSB2aXNpdCIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIkNoaW5hInMgYWdncmVzc2lvbiBpbiBJbmRvLVBhY2lmaWMgbGVhZHMgdG8gImNvbmNlcm4gYW5kIGFuZ3N0IjogUGV0ZXIgRHV0dG9uLCBBdXN0cmFsaWEicyBsZWFkZXIgb2Ygb3Bwb3NpdGlvbiIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIkF1c3RyYWxpYSBhbmQgQ2hpbmEgZXllIG5ldyB3YXlzIHRvIGhlYWwgb2xkIHdvdW5kcyIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIkFsYmFuZXNlIG11c3QgYWltIGJleW9uZCBiaWxhdGVyYWwgb3V0Y29tZXMgb24gQmVpamluZyB2aXNpdCIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIldlc3Rlcm4gQXVzdHJhbGlhbiBQcmVtaWVyIEFubm91bmNlcyBWaXNpdCB0byBDaGluYSIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIkF1c3RyYWxpYW4gUE0icyBDaGluYSB2aXNpdCB3aWxsIGhlbHAgbm9ybWFsaXplIHJlbGF0aW9ucywgc2F5cyBleC10cmFkZSBtaW5pc3RlciIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIk5pY2hvbGFzIE1vb3JlIG9uIGhvdyB0byBnZXQgaW4gZWFybHkgb24gdGhlIG5leHQgYmlnIGdyb3d0aCBzdG9yeSIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIlBNInMgQ2hpbmEgdHJpcCBjZW1lbnRzIG5ldyBlcmEgZm9yIHRpZXMiKQooRGF0ZShkYXRlPSIyMDIzLTExLTAyIiksICJQTSB0byB0YWtlIGEgaGFyZCBsaW5lIG9uIHRyYWRlIHdpdGggQ2hpbmEiKQooRGF0ZShkYXRlPSIyMDIzLTExLTAxIiksICJBdXN0cmFsaWFuIFByaW1lIE1pbmlzdGVyIEFudGhvbnkgQWxiYW5lc2UgdG8gcmFpc2UgaW1wcmlzb25lZCBkZW1vY3JhY3kgYmxvZ2dlciBkdXJpbmcgQ2hpbmEgdmlzaXQiKVxlbmR7bHN0bGlzdGluZ30KICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBUaGUgcmVjZW50IG5ld3MgYXJ0aWNsZXMgcHJvdmlkZSB2YWx1YWJsZSBjb250ZXh0IGZvciB0aGUgcmVsYXRpb25zIGJldHdlZW4gQXVzdHJhbGlhIGFuZCBDaGluYS4gS2V5IHRoZW1lcyBpbmNsdWRlOlxcCgogICAgMS4gXHRleHRiZntEaXBsb21hdGljIFZpc2l0cyBhbmQgRW5nYWdlbWVudHN9OiBNdWx0aXBsZSBhcnRpY2xlcyBoaWdobGlnaHQgdGhlIHVwY29taW5nIHZpc2l0IG9mIEF1c3RyYWxpYW4gUHJpbWUgTWluaXN0ZXIgQW50aG9ueSBBbGJhbmVzZSB0byBDaGluYS4gVGhpcyBhbGlnbnMgd2l0aCB0aGUgZnJlcXVlbnQgb2NjdXJyZW5jZSBvZiBDQU1FTyBjb2RlIFx0ZXh0YmZ7MDQyIChNYWtlIGEgdmlzaXQpfS5cXAogICAgMi4gXHRleHRiZntFY29ub21pYyBDb29wZXJhdGlvbiBhbmQgVHJhZGV9OiBEaXNjdXNzaW9ucyBhcm91bmQgdHJhZGUgYW5kIGVjb25vbWljIGNvb3BlcmF0aW9uIGFyZSBwcm9taW5lbnQsIGluZGljYXRpbmcgb25nb2luZyBlZmZvcnRzIHRvIGltcHJvdmUgZWNvbm9taWMgdGllcy4gVGhpcyBzdXBwb3J0cyB0aGUgcmVsZXZhbmNlIG9mIENBTUVPIGNvZGVzIFx0ZXh0YmZ7MDYxIChDb29wZXJhdGUgZWNvbm9taWNhbGx5KX0gYW5kIFx0ZXh0YmZ7MDM2IChFeHByZXNzIGludGVudCB0byBtZWV0IG9yIG5lZ290aWF0ZSl9LlxcCiAgICAzLiBcdGV4dGJme0NvbmNlcm5zIGFuZCBUZW5zaW9uc306IEFydGljbGVzIG1lbnRpb24gY29uY2VybnMgYWJvdXQgQ2hpbmEicyBhZ2dyZXNzaW9uIGluIHRoZSBJbmRvLVBhY2lmaWMgYW5kIGh1bWFuIHJpZ2h0cyBpc3N1ZXMsIHN1Z2dlc3RpbmcgdW5kZXJseWluZyB0ZW5zaW9ucy4gVGhpcyBpcyByZWZsZWN0ZWQgaW4gdGhlIG9jY2FzaW9uYWwgb2NjdXJyZW5jZSBvZiBDQU1FTyBjb2RlIFx0ZXh0YmZ7MTczIChBcnJlc3Qgb3IgZGV0YWluKX0uCgogICAgR2l2ZW4gdGhlIGhpc3RvcmljYWwgZGF0YSBhbmQgcmVjZW50IG5ld3MgY29udGV4dCwgdGhlIG1vc3QgbGlrZWx5IHJlbGF0aW9ucyB0aGF0IEF1c3RyYWxpYSB3aWxsIHRha2UgdG93YXJkcyBDaGluYSBvbiBOb3ZlbWJlciAwMywgMjAyMywgaW5jbHVkZSBkaXBsb21hdGljIHZpc2l0cywgZWNvbm9taWMgY29vcGVyYXRpb24sIGFuZCBuZWdvdGlhdGlvbnMsIHdpdGggYSBwb3NzaWJpbGl0eSBvZiBhZGRyZXNzaW5nIHVuZGVybHlpbmcgdGVuc2lvbnMuCgogICAgRmluYWwgQW5zd2VyOgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KewogICIwMyI6IFsiMDMxIiwgIjAzNiJdLAogICIwNCI6IFsiMDQwIiwgIjA0MiIsICIwNDMiLCAiMDQ2Il0sCiAgIjA2IjogWyIwNjEiXSwKICAiMTciOiBbIjE3MyJdCn1cZW5ke2xzdGxpc3Rpbmd9CgogICAgXHRleHRiZntBY3Rpb259OgogICAgRmluYWwgQW5zd2VyOgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KewogICIwMyI6IFsiMDMxIiwgIjAzNiJdLAogICIwNCI6IFsiMDQwIiwgIjA0MiIsICIwNDMiLCAiMDQ2Il0sCiAgIjA2IjogWyIwNjEiXSwKICAiMTciOiBbIjE3MyJdCn1cZW5ke2xzdGxpc3Rpbmd9ClxlbmR7ZW51bWVyYXRlfQoKClxzdWJzdWJzZWN0aW9ue0FnZW50IEZpbmFsIFN0YXR1c30KXGJlZ2lue2l0ZW1pemV9CiAgICBcaXRlbSBcdGV4dGJme0VuZCBTdGF0ZX06IEZpbmFsIEFuc3dlcgogICAgXGl0ZW0gXHRleHRiZntOdW1iZXIgb2YgU3RlcHMgVGFrZW59OiA1CiAgICBcaXRlbSBcdGV4dGJme0ZpbmFsIEFuc3dlcn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQp7CiAgIjAzIjogWyIwMzEiLCAiMDM2Il0sCiAgIjA0IjogWyIwNDAiLCAiMDQyIiwgIjA0MyIsICIwNDYiXSwKICAiMDYiOiBbIjA2MSJdLAogICIxNyI6IFsiMTczIl0KfVxlbmR7bHN0bGlzdGluZ30KV2Ugc2hvdyB0aGUgY29ycmVzcG9uZGluZyByZWxhdGlvbiBuYW1lcyBvZiB0aGUgcHJlZGljdGVkIGNvZGVzIGhlcmUgZm9yIGEgYmV0dGVyIHJldmlldzoKICAgICAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQp7CiAgIkV4cHJlc3MgaW50ZW50IHRvIGNvb3BlcmF0ZSI6IFsiRXhwcmVzcyBpbnRlbnQgdG8gZW5nYWdlIGluIG1hdGVyaWFsIGNvb3BlcmF0aW9uIiwgIkV4cHJlc3MgaW50ZW50IHRvIG1lZXQgb3IgbmVnb3RpYXRlIl0sCiAgIkNvbnN1bHQiOiBbIkNvbnN1bHQsIG5vdCBzcGVjaWZpZWQiLCAiTWFrZSBhIHZpc2l0IiwgIkhvc3QgYSB2aXNpdCIsICJFbmdhZ2UgaW4gbmVnb3RpYXRpb24iXSwKICAiRW5nYWdlIGluIG1hdGVyaWFsIGNvb3BlcmF0aW9uIjogWyJDb29wZXJhdGUgZWNvbm9taWNhbGx5Il0sCiAgIkNvZXJjZSI6IFsiQXJyZXN0IG9yIGRldGFpbiJdCn1cZW5ke2xzdGxpc3Rpbmd9CiAgICBcaXRlbSBcdGV4dGJme0dyb3VuZCBUcnV0aCBBbnN3ZXJ9OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KewogICIwMyI6IFsiMDM2Il0sCiAgIjA0IjogWyIwNDIiXSwKICAiMTciOiBbIjE3MiJdCn1cZW5ke2xzdGxpc3Rpbmd9CldlIHNob3cgdGhlIGNvcnJlc3BvbmRpbmcgcmVsYXRpb24gbmFtZXMgb2YgdGhlIGdyb3VuZC10cnV0aCBjb2RlcyBoZXJlIGZvciBhIGJldHRlciByZXZpZXc6CiAgICAgICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KewogICJFeHByZXNzIGludGVudCB0byBjb29wZXJhdGUiOiBbIkV4cHJlc3MgaW50ZW50IHRvIG1lZXQgb3IgbmVnb3RpYXRlIl0sCiAgIkNvbnN1bHQiOiBbIk1ha2UgYSB2aXNpdCJdLAogICJDb2VyY2UiOiBbIkltcG9zZSBhZG1pbmlzdHJhdGl2ZSBzYW5jdGlvbnMiXQp9XGVuZHtsc3RsaXN0aW5nfQpcZW5ke2l0ZW1pemV9CgoKCgpcc3Vic2VjdGlvbntHUFQtNG8tYmFzZWQgQWdlbnQgd2l0aCBSZUFjdCBhbmQgYGBcaGxjW3VjbGFibHVlITIwXXtTaW5nbGUgRnVuY3Rpb259JycgQWN0aW9ufQoKXHN1YnN1YnNlY3Rpb257UXVlcnkgRGV0YWlsc30KXGJlZ2lue2l0ZW1pemV9CiAgICBcaXRlbSBcdGV4dGJme1F1ZXJ5IFF1YWRydXBsZXR9OiAoMjAyMy0xMS0wMywgQVVTLCA/LCBDSE4pCiAgICBcaXRlbSBcdGV4dGJme1RlbXBvcmFsIERpc3RhbmNlfTogMTsgdGhlcmVmb3JlLCB0aGUgY3VycmVudCBkYXRlIGlzIDIwMjMtMTEtMDIKICAgIFxpdGVtIFx0ZXh0YmZ7QWdlbnQgTWF4IFN0ZXBzfTogMjAKXGVuZHtpdGVtaXplfQoKXHN1YnN1YnNlY3Rpb257UXVlcnkgUHJvbXB0fQpQbGVhc2UgZm9yZWNhc3QgdGhlIHJlbGF0aW9ucyB0aGF0IFxobGNbeWVsbG93ITMwXXtBdXN0cmFsaWF9IHdpbGwgdGFrZSB0b3dhcmRzIFxobGNbeWVsbG93ITMwXXtDaGluYX0gb24gXGhsY1t5ZWxsb3chMzBde05vdmVtYmVyIDAzLCAyMDIzfSBiYXNlZCBvbiBoaXN0b3JpY2FsIGluZm9ybWF0aW9uIHVwIHRvIFxobGNbeWVsbG93ITMwXXtOb3ZlbWJlciAwMiwgMjAyM30uIEkuZS4gZm9yZWNhc3QgdGhlIHJlbGF0aW9uIENBTUVPIGNvZGVzIGluIHF1ZXJ5IGV2ZW50IFxobGNbeWVsbG93ITMwXXtFdmVudChkYXRlPTIwMjMtMTEtMDMsIGhlYWRcX2VudGl0eT1JU09Db2RlKEFVUyksIHJlbGF0aW9uPUNBTUVPQ29kZSg/KSwgdGFpbFxfZW50aXR5PUlTT0NvZGUoQ0hOKSl9LgoKXHN1YnN1YnNlY3Rpb257U3lzdGVtIFByb21wdH0KWW91IGFyZSBhbiBleHBlcnQgaW4gZm9yZWNhc3RpbmcgZnV0dXJlIGV2ZW50cyBiYXNlZCBvbiBoaXN0b3JpY2FsIGRhdGEuIFRoZSBkYXRhYmFzZSBjb250YWlucyBuZXdzIGFydGljbGVzIGZyb20gSmFudWFyeSAxLCAyMDIzIHRvIHRoZSBjdXJyZW50IGRhdGUgXGhsY1t5ZWxsb3chMzBde05vdmVtYmVyIDAyLCAyMDIzfSBhbmQgdGhlIGV2ZW50cyBleHRyYWN0ZWQgZnJvbSB0aGVzZSBhcnRpY2xlcy4gVGhlIGV2ZW50cyBhcmUgaW4gdGhlIGZvcm0gb2YgKGRhdGUsIHN1YmplY3QgY291bnRyeSwgcmVsYXRpb24sIG9iamVjdCBjb3VudHJ5KSwgd2hlcmUgdGhlIGNvdW50cmllcyBhcmUgcmVwcmVzZW50ZWQgYnkgSVNPIDMxNjYtMSBhbHBoYS0zIGNvZGVzIGFuZCB0aGUgcmVsYXRpb25zIGFyZSByZXByZXNlbnRlZCBieSB0aGUgQ0FNRU8gY29kZXMgZGVmaW5lZCBpbiB0aGUgIkNvbmZsaWN0IGFuZCBNZWRpYXRpb24gRXZlbnQgT2JzZXJ2YXRpb25zIiBvbnRvbG9neS4gVGhlIHJlbGF0aW9ucyBhcmUgaGllcmFyY2hpY2FsOiBmaXJzdC1sZXZlbCByZWxhdGlvbnMgYXJlIGdlbmVyYWwgcGFyZW50IHJlbGF0aW9ucyByZXByZXNlbnRlZCBieSB0d28tZGlnaXQgQ0FNRU8gY29kZXMsIHdoaWxlIHNlY29uZC1sZXZlbCByZWxhdGlvbnMgYXJlIG1vcmUgc3BlY2lmaWMgY2hpbGQgcmVsYXRpb25zIHJlcHJlc2VudGVkIGJ5IHRocmVlLWRpZ2l0IENBTUVPIGNvZGVzLiBDaGlsZCByZWxhdGlvbnMgaGF2ZSB0aGUgc2FtZSBmaXJzdCB0d28gZGlnaXRzIGFzIHRoZWlyIHBhcmVudCByZWxhdGlvbnMuIEZvciBleGFtcGxlLCAiMDEiIGlzIGEgZmlyc3QtbGV2ZWwgcmVsYXRpb24sIGFuZCAiMDEwIiBhbmQgIjAxMSIgYXJlIHNvbWUgb2YgaXRzIHNlY29uZC1sZXZlbCByZWxhdGlvbnMuIFRoZSByZWxhdGlvbnMgaW4gdGhlIGRhdGFiYXNlIGFyZSByZXByZXNlbnRlZCBpbiB0aGUgc2Vjb25kLWxldmVsIGZvcm0uClxcXFwKWW91ciB0YXNrIGlzIHRvIGZvcmVjYXN0IHRoZSBmdXR1cmUgcmVsYXRpb25zIGJldHdlZW4gdHdvIGVudGl0aWVzIGluIGEgZ2l2ZW4gcXVlcnkuIFlvdSBoYXZlIGFjY2VzcyB0byBhIGRlZmluZWQgUHl0aG9uIEFQSSB0aGF0IGFsbG93cyB5b3UgdG8gcXVlcnkgdGhlIGRhdGFiYXNlIGZvciBoaXN0b3JpY2FsIGV2ZW50cyBhbmQgc3RhdGlzdGljcywgYW5kIHRvIGdldCBwcmVjaXNlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBJU08gY291bnRyeSBjb2RlcyBhbmQgQ0FNRU8gcmVsYXRpb24gY29kZXMuClxcXFwKVGhlIGRlZmluZWQgQVBJIGlzIGRlc2NyaWJlZCBhcyBmb2xsb3dzOlxcCntcdGV4dGFzY2lpZ3JhdmV9e1x0ZXh0YXNjaWlncmF2ZX17XHRleHRhc2NpaWdyYXZlfSBweXRob25cXApcdGV4dHR0e1x7YXBpXF9kZXNjcmlwdGlvblx9fVxcCntcdGV4dGFzY2lpZ3JhdmV9e1x0ZXh0YXNjaWlncmF2ZX17XHRleHRhc2NpaWdyYXZlfQpcXFxcCllvdSB3aWxsIHVzZSBhbiBpdGVyYXRpdmUgYXBwcm9hY2gsIGludGVybGVhdmluZyAiVGhvdWdodCIsICJBY3Rpb24iLCBhbmQgIk9ic2VydmF0aW9uIiBzdGVwcyB0byBjb2xsZWN0IGluZm9ybWF0aW9uIGFuZCBwZXJmb3JtIHRoZSBmb3JlY2FzdC4gWW91IG1heSBwZXJmb3JtIHVwIHRvIFxobGNbeWVsbG93ITMwXXsyMH0gaXRlcmF0aW9ucy4gVGhlIHN0ZXBzIGFyZSBhcyBmb2xsb3dzOgpcXFxcCi0gIlRob3VnaHQiOiBBbmFseXplIHRoZSBjdXJyZW50IGluZm9ybWF0aW9uIGFuZCByZWFzb24gYWJvdXQgdGhlIGN1cnJlbnQgc2l0dWF0aW9uLCBhbmQgcHJlZGljdHMgd2hpY2ggQVBJIHlvdSB3YW50IHRvIHVzZSAodHJ5IHRvIHVzZSBkaWZmZXJlbnQgQVBJcyB0byBjb2xsZWN0IGRpdmVyc2UgaW5mb3JtYXRpb24pIG9yIG1ha2UgYSBkZWNpc2lvbiB0aGF0IHlvdSB3YW50IHRvIG1ha2UgYSBmaW5hbCBhbnN3ZXIuXFwKLSAiQWN0aW9uIjogVXNlIHRoZSBBUEkgdG8gZ2F0aGVyIG1vcmUgaW5mb3JtYXRpb24gb3IgcHJvdmlkZSB0aGUgZmluYWwgZm9yZWNhc3QuXFwKICAgIFxoc3BhY2UqezZtbX0tIElmIHVzaW5nIHRoZSBBUEk6IFxobGNbdWNsYWJsdWUhMjBde3RoZSBhY3Rpb24gbXVzdCBiZSBvbmx5IG9uZSBzaW5nbGUgbGluZSBvZiBleGFjdGx5IG9uZSBmdW5jdGlvbiBjYWxsIGZyb20gdGhlIEFQSSB3aXRoIGFwcHJvcHJpYXRlIGlucHV0cywgd2l0aG91dCBhZGRpdGlvbmFsIGNvZGUsIGV4cGxhbmF0aW9ucywgb3IgbmF0dXJhbCBsYW5ndWFnZSBkZXNjcmlwdGlvbnN9LlxcCiAgICBcaHNwYWNlKns2bW19LSBJZiBtYWtpbmcgdGhlIGZpbmFsIGZvcmVjYXN0OiB0aGUgYWN0aW9uIG11c3Qgc3RhcnQgaW1tZWRpYXRlbHkgd2l0aCAiRmluYWwgQW5zd2VyOiIsIGFuZCBmb2xsb3cgd2l0aCB0aGUgcmVzdWx0cyBpbiB0aGUgZXhwZWN0ZWQgSlNPTiBmb3JtYXQuXFwKLSAiT2JzZXJ2YXRpb24iOiBSZXR1cm4gdGhlIG91dHB1dCBvZiB0aGUgY2FsbGVkIGZ1bmN0aW9uLgpcXFxcClRvIG1ha2UgYSByZWFzb25hYmxlIGZvcmVjYXN0LCB5b3Ugc2hvdWxkIGNvbGxlY3QgYm90aCBuZXdzIGFuZCByZWxhdGlvbmFsIGV2aWRlbmNlIHRvIHN1cHBvcnQgeW91ciBwcmVkaWN0aW9uLiBXaGVuIHlvdSBhcmUgZnVsbHkgY29uZmlkZW50IHRoYXQgeW91IGFjY3VtdWxhdGUgZW5vdWdoIGluZm9ybWF0aW9uIHRvIG1ha2UgdGhlIGZpbmFsIGZvcmVjYXN0LCB5b3Ugc2hvdWxkIHN0YXJ0IHRoZSAiVGhvdWdodCIgd2l0aCB5b3VyIHJlYXNvbmluZyB1c2luZyB0aGUgbmV3cyBhbmQgc3RydWN0dXJhbCBpbmZvcm1hdGlvbiB0byBtYWtlIHRoZSBwcmVkaWN0aW9uLCBhbmQgdGhlbiBzdGFydCB0aGUgIkFjdGlvbiIgc3RlcCB3aXRoICJGaW5hbCBBbnN3ZXI6IiBmb2xsb3dlZCBieSB0aGUgYW5zd2VyIGluIHRoZSBleHBlY3RlZCBKU09OIGZvcm1hdC4gVGhlIGFuc3dlciBzaG91bGQgYmUgYSBKU09OIGRpY3Rpb25hcnkgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBmb3JlY2FzdGVkIHR3by1kaWdpdCBmaXJzdC1sZXZlbCBDQU1FTyBjb2RlcyBhbmQgdGhlIHZhbHVlcyBhcmUgbGlzdHMgb2YgZm9yZWNhc3RlZCB0aHJlZS1kaWdpdCBzZWNvbmQtbGV2ZWwgQ0FNRU8gY29kZXMgdGhhdCBhcmUgY2hpbGQgcmVsYXRpb25zIG9mIHRoZSBrZXkuIEZvciBleGFtcGxlLCAiQWN0aW9uOiBGaW5hbCBBbnN3ZXI6IFx7IjAxIjogWyIwMTAiLCAiMDExIiwgIjAxMiJdLCAiMDIiOiBbIjAyMCIsICIwMjMiXVx9Ii4KXFxcXApUaGUgZmluYWwgYW5zd2VyIHdpbGwgYmUgZXZhbHVhdGVkIGJhc2VkIG9uIHRoZSBwcmVjaXNpb24gYW5kIHJlY2FsbCBvZiB0aGUgZm9yZWNhc3RlZCBmaXJzdC1sZXZlbCBhbmQgc2Vjb25kLWxldmVsIHJlbGF0aW9ucywgc28gb25seSBpbmNsdWRlIGNvbmZpZGVudCBmaXJzdC1sZXZlbCBhbmQgc2Vjb25kLWxldmVsIENBTUVPIGNvZGVzIGluIHlvdXIgZmluYWwgZm9yZWNhc3QuClxcXFwKVHJ5IHRvIHVzZSBkaWZmZXJlbnQgQVBJcyB0byBjb2xsZWN0IGRpdmVyc2UgaW5mb3JtYXRpb24gKGluY2x1ZGluZyBtdWx0aS1ob3AgcmVsYXRpb25zKSwgc3VjaCBhcyB0aGUgcHJlY2lzZSBtZWFuaW5nIG9mIENBTUVPIGNvZGVzLCBpbnNpZ2h0cyBmcm9tIG5ld3MgY29udGVudCwgcmVsYXRpb25hbCBkYXRhLCBhbmQgc3RhdGlzdGljYWwgYW5hbHlzZXMgdG8gc3VwcG9ydCB5b3VyIGZvcmVjYXN0cy4gQ29uc2lkZXIgbm90IG9ubHkgdGhlIGZyZXF1ZW5jeSBvZiB0aGUgcmVsYXRpb25zIGJ1dCBhbHNvIHRoZSB0ZW1wb3JhbCBhc3BlY3RzIG9mIHRoZSBkYXRhIHdoZW4gbWFraW5nIHlvdXIgZm9yZWNhc3QuCgpcc3Vic3Vic2VjdGlvbntBZ2VudCBSZUFjdCBQcm9jZXNzfQpcYmVnaW57ZW51bWVyYXRlfQogICAgXGl0ZW0gXHRleHRiZntUaG91Z2h0fToKICAgIFRvIGZvcmVjYXN0IHRoZSByZWxhdGlvbnMgdGhhdCBBdXN0cmFsaWEgKEFVUykgd2lsbCB0YWtlIHRvd2FyZHMgQ2hpbmEgKENITikgb24gTm92ZW1iZXIgMDMsIDIwMjMsIEkgd2lsbCBzdGFydCBieSBnYXRoZXJpbmcgaGlzdG9yaWNhbCBkYXRhIG9uIHRoZSBpbnRlcmFjdGlvbnMgYmV0d2VlbiB0aGVzZSB0d28gY291bnRyaWVzLiBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgdHlwZXMgb2YgcmVsYXRpb25zLCB0aGVpciBmcmVxdWVuY2llcywgYW5kIHRoZSBjb250ZXh0IGluIHdoaWNoIHRoZXkgb2NjdXJyZWQuIEkgd2lsbCB1c2UgdGhlIGZvbGxvd2luZyBzdGVwczoKCiAgICBcYmVnaW57ZW51bWVyYXRlfQogICAgICAgIFxpdGVtIFJldHJpZXZlIHRoZSBkaXN0cmlidXRpb24gb2Ygc2Vjb25kLWxldmVsIHJlbGF0aW9ucyBiZXR3ZWVuIEF1c3RyYWxpYSBhbmQgQ2hpbmEuCiAgICAgICAgXGl0ZW0gQW5hbHl6ZSB0aGUgZGlzdHJpYnV0aW9uIHRvIGlkZW50aWZ5IHRoZSBtb3N0IGNvbW1vbiB0eXBlcyBvZiBpbnRlcmFjdGlvbnMuCiAgICAgICAgXGl0ZW0gRXhhbWluZSByZWNlbnQgbmV3cyBhcnRpY2xlcyB0byB1bmRlcnN0YW5kIHRoZSBjb250ZXh0IGFuZCBhbnkgb25nb2luZyB0cmVuZHMgb3IgZXZlbnRzIHRoYXQgbWlnaHQgaW5mbHVlbmNlIGZ1dHVyZSByZWxhdGlvbnMuCiAgICBcZW5ke2VudW1lcmF0ZX0KCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQpnZXRfcmVsYXRpb25fZGlzdHJpYnV0aW9uKGhlYWRfZW50aXRpZXM9W0lTT0NvZGUoIkFVUyIpXSwgdGFpbF9lbnRpdGllcz1bSVNPQ29kZSgiQ0hOIildKVxlbmR7bHN0bGlzdGluZ30KICAgIFx0ZXh0YmZ7T2JzZXJ2YXRpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0Ke0NBTUVPQ29kZShjb2RlPSIwNDIiKTogMzIsCiBDQU1FT0NvZGUoY29kZT0iMDM2Iik6IDMwLAogQ0FNRU9Db2RlKGNvZGU9IjA0MCIpOiAxNywKQ0FNRU9Db2RlKGNvZGU9IjA2MSIpOiAxNiwKQ0FNRU9Db2RlKGNvZGU9IjA0NiIpOiAxMiwKQ0FNRU9Db2RlKGNvZGU9IjA0MyIpOiAxMSwKQ0FNRU9Db2RlKGNvZGU9IjAxMCIpOiA2LApDQU1FT0NvZGUoY29kZT0iMDIwIik6IDUsCkNBTUVPQ29kZShjb2RlPSIxNzMiKTogNSwKQ0FNRU9Db2RlKGNvZGU9IjAxMiIpOiA1LApDQU1FT0NvZGUoY29kZT0iMDUxIik6IDQsCkNBTUVPQ29kZShjb2RlPSIxNjMiKTogMywKQ0FNRU9Db2RlKGNvZGU9IjEyOCIpOiAyLApDQU1FT0NvZGUoY29kZT0iMDUwIik6IDIsCkNBTUVPQ29kZShjb2RlPSIwODQiKTogMiwKQ0FNRU9Db2RlKGNvZGU9IjA5MCIpOiAyLApDQU1FT0NvZGUoY29kZT0iMTc0Iik6IDEsCkNBTUVPQ29kZShjb2RlPSIxMTIiKTogMSwKQ0FNRU9Db2RlKGNvZGU9IjEzMCIpOiAxLApDQU1FT0NvZGUoY29kZT0iMTYwIik6IDEsCkNBTUVPQ29kZShjb2RlPSIxNzIiKTogMSwKQ0FNRU9Db2RlKGNvZGU9IjE5MiIpOiAxLApDQU1FT0NvZGUoY29kZT0iMTkwIik6IDEsCkNBTUVPQ29kZShjb2RlPSIwNjAiKTogMSwKQ0FNRU9Db2RlKGNvZGU9IjAzMCIpOiAxLApDQU1FT0NvZGUoY29kZT0iMDM1Iik6IDEsCkNBTUVPQ29kZShjb2RlPSIxMzgiKTogMSwKQ0FNRU9Db2RlKGNvZGU9IjA3MSIpOiAxLApDQU1FT0NvZGUoY29kZT0iMDMxIik6IDF9XGVuZHtsc3RsaXN0aW5nfQogICAgXGl0ZW0gXHRleHRiZntUaG91Z2h0fToKICAgIFRoZSBkaXN0cmlidXRpb24gb2Ygc2Vjb25kLWxldmVsIHJlbGF0aW9ucyBiZXR3ZWVuIEF1c3RyYWxpYSBhbmQgQ2hpbmEgc2hvd3MgYSB2YXJpZXR5IG9mIGludGVyYWN0aW9ucywgd2l0aCBzb21lIHJlbGF0aW9ucyBiZWluZyBtb3JlIGZyZXF1ZW50IHRoYW4gb3RoZXJzLiBUaGUgbW9zdCBjb21tb24gaW50ZXJhY3Rpb25zIGluY2x1ZGU6CgogICAgLSAiMDQyIiAoQ29uc3VsdCk6IDMyIG9jY3VycmVuY2VzXFwKICAgIC0gIjAzNiIgKEV4cHJlc3MgaW50ZW50IHRvIGNvb3BlcmF0ZSk6IDMwIG9jY3VycmVuY2VzXFwKICAgIC0gIjA0MCIgKEFzc3VyZSk6IDE3IG9jY3VycmVuY2VzXFwKICAgIC0gIjA2MSIgKENvb3BlcmF0ZSBlY29ub21pY2FsbHkpOiAxNiBvY2N1cnJlbmNlc1xcCiAgICAtICIwNDYiIChQcmFpc2Ugb3IgZW5kb3JzZSk6IDEyIG9jY3VycmVuY2VzXFwKICAgIC0gIjA0MyIgKEFwb2xvZ2l6ZSk6IDExIG9jY3VycmVuY2VzXFwKCiAgICBUaGVzZSBmcmVxdWVudCBpbnRlcmFjdGlvbnMgc3VnZ2VzdCBhIHRyZW5kIHRvd2FyZHMgZGlwbG9tYXRpYyBhbmQgY29vcGVyYXRpdmUgZW5nYWdlbWVudHMuIEhvd2V2ZXIsIHRvIG1ha2UgYSBtb3JlIGluZm9ybWVkIGZvcmVjYXN0LCBpdCBpcyBlc3NlbnRpYWwgdG8gdW5kZXJzdGFuZCB0aGUgY29udGV4dCBhbmQgYW55IHJlY2VudCBkZXZlbG9wbWVudHMgdGhhdCBtaWdodCBpbmZsdWVuY2UgZnV0dXJlIHJlbGF0aW9ucy4KCiAgICBOZXh0LCBJIHdpbGwgcmV0cmlldmUgcmVjZW50IG5ld3MgYXJ0aWNsZXMgaW52b2x2aW5nIEF1c3RyYWxpYSBhbmQgQ2hpbmEgdG8gZ2F0aGVyIGluc2lnaHRzIG9uIHRoZSBjdXJyZW50IGNvbnRleHQgYW5kIGFueSBvbmdvaW5nIHRyZW5kcyBvciBldmVudHMuCgogICAgXHRleHRiZntBY3Rpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KZ2V0X25ld3NfYXJ0aWNsZXMoZGF0ZV9yYW5nZT1EYXRlUmFuZ2Uoc3RhcnRfZGF0ZT1EYXRlKCIyMDIzLTEwLTAxIiksIGVuZF9kYXRlPURhdGUoIjIwMjMtMTEtMDIiKSksIGhlYWRfZW50aXRpZXM9W0lTT0NvZGUoIkFVUyIpXSwgdGFpbF9lbnRpdGllcz1bSVNPQ29kZSgiQ0hOIildKVxlbmR7bHN0bGlzdGluZ30KICAgIFx0ZXh0YmZ7T2JzZXJ2YXRpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KWyhEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIk5vIHF1aWNrIGZpeCB0byByZW1haW5pbmcgdGFyaWZmcyBhaGVhZCBvZiBDaGluYSB2aXNpdCIpLAogKERhdGUoZGF0ZT0iMjAyMy0xMS0wMiIpLCAiQ2hpbmEicyBhZ2dyZXNzaW9uIGluIEluZG8tUGFjaWZpYyBsZWFkcyB0byAiY29uY2VybiBhbmQgYW5nc3QiOiBQZXRlciBEdXR0b24sIEF1c3RyYWxpYSJzIGxlYWRlciBvZiBvcHBvc2l0aW9uIiksCiAoRGF0ZShkYXRlPSIyMDIzLTExLTAyIiksICJBdXN0cmFsaWEgYW5kIENoaW5hIGV5ZSBuZXcgd2F5cyB0byBoZWFsIG9sZCB3b3VuZHMiKSwKIChEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIkFsYmFuZXNlIG11c3QgYWltIGJleW9uZCBiaWxhdGVyYWwgb3V0Y29tZXMgb24gQmVpamluZyB2aXNpdCIpLAogKERhdGUoZGF0ZT0iMjAyMy0xMS0wMiIpLCAiV2VzdGVybiBBdXN0cmFsaWFuIFByZW1pZXIgQW5ub3VuY2VzIFZpc2l0IHRvIENoaW5hIiksCiAoRGF0ZShkYXRlPSIyMDIzLTExLTAyIiksICJBdXN0cmFsaWFuIFBNInMgQ2hpbmEgdmlzaXQgd2lsbCBoZWxwIG5vcm1hbGl6ZSByZWxhdGlvbnMsIHNheXMgZXgtdHJhZGUgbWluaXN0ZXIiKSwKIChEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIk5pY2hvbGFzIE1vb3JlIG9uIGhvdyB0byBnZXQgaW4gZWFybHkgb24gdGhlIG5leHQgYmlnIGdyb3d0aCBzdG9yeSIpLAogKERhdGUoZGF0ZT0iMjAyMy0xMS0wMiIpLCAiUE0icyBDaGluYSB0cmlwIGNlbWVudHMgbmV3IGVyYSBmb3IgdGllcyIpLAogKERhdGUoZGF0ZT0iMjAyMy0xMS0wMiIpLCAiUE0gdG8gdGFrZSBhIGhhcmQgbGluZSBvbiB0cmFkZSB3aXRoIENoaW5hIiksCiAoRGF0ZShkYXRlPSIyMDIzLTExLTAxIiksICJBdXN0cmFsaWFuIFByaW1lIE1pbmlzdGVyIEFudGhvbnkgQWxiYW5lc2UgdG8gcmFpc2UgaW1wcmlzb25lZCBkZW1vY3JhY3kgYmxvZ2dlciBkdXJpbmcgQ2hpbmEgdmlzaXQiKV1cZW5ke2xzdGxpc3Rpbmd9CiAgICBcaXRlbSBcdGV4dGJme1Rob3VnaHR9OgogICAgVGhlIHJlY2VudCBuZXdzIGFydGljbGVzIGluZGljYXRlIGEgbWl4IG9mIGRpcGxvbWF0aWMsIGVjb25vbWljLCBhbmQgc2VjdXJpdHktcmVsYXRlZCBpbnRlcmFjdGlvbnMgYmV0d2VlbiBBdXN0cmFsaWEgYW5kIENoaW5hLiBLZXkgdGhlbWVzIGluY2x1ZGU6CgogICAgLSBEaXBsb21hdGljIGVuZ2FnZW1lbnRzIGFuZCBlZmZvcnRzIHRvIG5vcm1hbGl6ZSByZWxhdGlvbnMsIGFzIHNlZW4gaW4gYXJ0aWNsZXMgYWJvdXQgdGhlIEF1c3RyYWxpYW4gUHJpbWUgTWluaXN0ZXIicyB2aXNpdCB0byBDaGluYSBhbmQgZWZmb3J0cyB0byBoZWFsIG9sZCB3b3VuZHMuXFwKICAgIC0gRWNvbm9taWMgY29vcGVyYXRpb24gYW5kIHRyYWRlIGRpc2N1c3Npb25zLCBpbmNsdWRpbmcgYWRkcmVzc2luZyB0YXJpZmZzIGFuZCB0cmFkZSBpc3N1ZXMuXFwKICAgIC0gU2VjdXJpdHkgY29uY2VybnMgYW5kIGNyaXRpY2lzbXMsIHBhcnRpY3VsYXJseSByZWxhdGVkIHRvIENoaW5hInMgYWN0aW9ucyBpbiB0aGUgSW5kby1QYWNpZmljIHJlZ2lvbiBhbmQgaHVtYW4gcmlnaHRzIGlzc3Vlcy5cXAoKICAgIEdpdmVuIHRoZXNlIHRoZW1lcywgaXQgaXMgbGlrZWx5IHRoYXQgdGhlIGZ1dHVyZSByZWxhdGlvbnMgYmV0d2VlbiBBdXN0cmFsaWEgYW5kIENoaW5hIHdpbGwgaW52b2x2ZSBhIGNvbWJpbmF0aW9uIG9mIGRpcGxvbWF0aWMgYXNzdXJhbmNlcywgZWNvbm9taWMgY29vcGVyYXRpb24sIGFuZCBzb21lIGNyaXRpY2FsIHN0YXRlbWVudHMgb3IgYWN0aW9ucyByZWxhdGVkIHRvIHNlY3VyaXR5IGFuZCBodW1hbiByaWdodHMuCgogICAgTmV4dCwgSSB3aWxsIHJldHJpZXZlIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBvZiB0aGUgbW9zdCBmcmVxdWVudCBzZWNvbmQtbGV2ZWwgcmVsYXRpb25zIHRvIGVuc3VyZSBhY2N1cmF0ZSBtYXBwaW5nIGFuZCB1bmRlcnN0YW5kaW5nIG9mIHRoZXNlIGludGVyYWN0aW9ucy4KCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQptYXBfY2FtZW9fdG9fcmVsYXRpb24oQ0FNRU9Db2RlKCIwNDIiKSlcZW5ke2xzdGxpc3Rpbmd9CiAgICBcdGV4dGJme09ic2VydmF0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dClJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIwNDIiKSwgbmFtZT0iTWFrZSBhIHZpc2l0IiwgZGVzY3JpcHRpb249IlRyYXZlbCB0byBhbm90aGVyIGxvY2F0aW9uIGZvciBhIG1lZXRpbmcgb3Igb3RoZXIgZXZlbnQuIilcZW5ke2xzdGxpc3Rpbmd9CiAgICBcaXRlbSBcdGV4dGJme1Rob3VnaHR9OgogICAgVGhlIHJlbGF0aW9uICIwNDIiIChNYWtlIGEgdmlzaXQpIGludm9sdmVzIHRyYXZlbGluZyB0byBhbm90aGVyIGxvY2F0aW9uIGZvciBhIG1lZXRpbmcgb3Igb3RoZXIgZXZlbnQsIHdoaWNoIGFsaWducyB3aXRoIHRoZSByZWNlbnQgbmV3cyBhYm91dCB0aGUgQXVzdHJhbGlhbiBQcmltZSBNaW5pc3RlciJzIHZpc2l0IHRvIENoaW5hLiBUaGlzIHN1Z2dlc3RzIHRoYXQgZGlwbG9tYXRpYyB2aXNpdHMgYXJlIGEgc2lnbmlmaWNhbnQgYXNwZWN0IG9mIHRoZSBpbnRlcmFjdGlvbnMgYmV0d2VlbiBBdXN0cmFsaWEgYW5kIENoaW5hLgoKICAgIFRvIGZ1cnRoZXIgcmVmaW5lIHRoZSBmb3JlY2FzdCwgSSB3aWxsIHJldHJpZXZlIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBmb3IgdGhlIG90aGVyIG1vc3QgZnJlcXVlbnQgc2Vjb25kLWxldmVsIHJlbGF0aW9uczogIjAzNiIsICIwNDAiLCAiMDYxIiwgIjA0NiIsIGFuZCAiMDQzIi4KCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQptYXBfY2FtZW9fdG9fcmVsYXRpb24oQ0FNRU9Db2RlKCIwMzYiKSlcZW5ke2xzdGxpc3Rpbmd9CiAgICBcdGV4dGJme09ic2VydmF0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dClJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIwMzYiKSwgbmFtZT0iRXhwcmVzcyBpbnRlbnQgdG8gbWVldCBvciBuZWdvdGlhdGUiLCBkZXNjcmlwdGlvbj0iT2ZmZXIsIHByb21pc2UsIGFncmVlIHRvLCBvciBvdGhlcndpc2UgaW5kaWNhdGUgd2lsbGluZ25lc3Mgb3IgY29tbWl0bWVudCB0byBtZWV0LCB2aXNpdCwgb3IgZW5nYWdlIGluIHRhbGtzIG9yIG5lZ290aWF0aW9ucy4iKVxlbmR7bHN0bGlzdGluZ30KICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBUaGUgcmVsYXRpb24gIjAzNiIgKEV4cHJlc3MgaW50ZW50IHRvIG1lZXQgb3IgbmVnb3RpYXRlKSBpbnZvbHZlcyBpbmRpY2F0aW5nIGEgd2lsbGluZ25lc3Mgb3IgY29tbWl0bWVudCB0byBtZWV0LCB2aXNpdCwgb3IgZW5nYWdlIGluIHRhbGtzIG9yIG5lZ290aWF0aW9ucy4gVGhpcyBhbGlnbnMgd2l0aCB0aGUgb25nb2luZyBkaXBsb21hdGljIGVmZm9ydHMgYW5kIGRpc2N1c3Npb25zIG1lbnRpb25lZCBpbiB0aGUgcmVjZW50IG5ld3MgYXJ0aWNsZXMuCgogICAgTmV4dCwgSSB3aWxsIHJldHJpZXZlIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBmb3IgdGhlIHJlbGF0aW9ucyAiMDQwIiwgIjA2MSIsICIwNDYiLCBhbmQgIjA0MyIgdG8gZnVydGhlciB1bmRlcnN0YW5kIHRoZSBjb250ZXh0IG9mIHRoZXNlIGludGVyYWN0aW9ucy4KCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQpnZXRfcGFyZW50X3JlbGF0aW9uKENBTUVPQ29kZSgiMDQwIikpXGVuZHtsc3RsaXN0aW5nfQogICAgXHRleHRiZntPYnNlcnZhdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQpSZWxhdGlvbihjYW1lb19jb2RlPUNBTUVPQ29kZSgiMDQiKSwgbmFtZT0iQ29uc3VsdCIsIGRlc2NyaXB0aW9uPSJBbGwgY29uc3VsdGF0aW9ucyBhbmQgbWVldGluZ3MuIilcZW5ke2xzdGxpc3Rpbmd9CiAgICBcaXRlbSBcdGV4dGJme1Rob3VnaHR9OgogICAgVGhlIHBhcmVudCByZWxhdGlvbiBgMDRgIChDb25zdWx0KSBlbmNvbXBhc3NlcyBhbGwgY29uc3VsdGF0aW9ucyBhbmQgbWVldGluZ3MsIHdoaWNoIGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgZnJlcXVlbnQgZGlwbG9tYXRpYyBpbnRlcmFjdGlvbnMgYmV0d2VlbiBBdXN0cmFsaWEgYW5kIENoaW5hLiBUaGUgc3BlY2lmaWMgcmVsYXRpb24gIjA0MCIgKEFzc3VyZSkgbGlrZWx5IGludm9sdmVzIHByb3ZpZGluZyBhc3N1cmFuY2VzIGR1cmluZyB0aGVzZSBjb25zdWx0YXRpb25zLgoKICAgIFRvIGZ1cnRoZXIgcmVmaW5lIHRoZSBmb3JlY2FzdCwgSSB3aWxsIHJldHJpZXZlIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBmb3IgdGhlIHJlbGF0aW9ucyAiMDYxIiwgIjA0NiIsIGFuZCAiMDQzIi4KCiAgICBcdGV4dGJme0FjdGlvbn06IiIKCiAgICBcdGV4dGJme09ic2VydmF0aW9ufTogTm8gZmVlZGJhY2sgZnJvbSB0aGUgZW52aXJvbm1lbnQgZHVlIHRvIHRoZSBudWxsIGFjdGlvbi4KICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBJIHdpbGwgY29udGludWUgcmV0cmlldmluZyBkZXRhaWxlZCBkZXNjcmlwdGlvbnMgZm9yIHRoZSByZWxhdGlvbnMgIjA2MSIsICIwNDYiLCBhbmQgIjA0MyIgdG8gZnVydGhlciB1bmRlcnN0YW5kIHRoZSBjb250ZXh0IG9mIHRoZXNlIGludGVyYWN0aW9ucy4KCiAgICBcdGV4dGJme0FjdGlvbn06IiIKCiAgICBcdGV4dGJme09ic2VydmF0aW9ufTogTm8gZmVlZGJhY2sgZnJvbSB0aGUgZW52aXJvbm1lbnQgZHVlIHRvIHRoZSBudWxsIGFjdGlvbi4KICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBJdCBzZWVtcyB0aGVyZSB3YXMgYW4gaXNzdWUgd2l0aCBteSBwcmV2aW91cyBhY3Rpb25zLiBJIHdpbGwgbm93IHByb2NlZWQgdG8gcmV0cmlldmUgdGhlIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBmb3IgdGhlIHJlbWFpbmluZyBmcmVxdWVudCBzZWNvbmQtbGV2ZWwgcmVsYXRpb25zOiAiMDYxIiwgIjA0NiIsIGFuZCAiMDQzIi4KICAgIFx0ZXh0YmZ7QWN0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dCm1hcF9jYW1lb190b19yZWxhdGlvbihDQU1FT0NvZGUoIjA2MSIpKVxlbmR7bHN0bGlzdGluZ30KICAgIFx0ZXh0YmZ7T2JzZXJ2YXRpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoIjA2MSIpLCBuYW1lPSJDb29wZXJhdGUgZWNvbm9taWNhbGx5IiwgZGVzY3JpcHRpb249IkluaXRpYXRlLCByZXN1bWUsIGltcHJvdmUsIG9yIGV4cGFuZCBlY29ub21pYyBleGNoYW5nZSBvciBjb29wZXJhdGlvbi4iKVxlbmR7bHN0bGlzdGluZ30KICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBUaGUgcmVsYXRpb24gIjA2MSIgKENvb3BlcmF0ZSBlY29ub21pY2FsbHkpIGludm9sdmVzIGluaXRpYXRpbmcsIHJlc3VtaW5nLCBpbXByb3ZpbmcsIG9yIGV4cGFuZGluZyBlY29ub21pYyBleGNoYW5nZSBvciBjb29wZXJhdGlvbi4gVGhpcyBhbGlnbnMgd2l0aCB0aGUgcmVjZW50IG5ld3MgYXJ0aWNsZXMgZGlzY3Vzc2luZyB0cmFkZSBpc3N1ZXMgYW5kIGVjb25vbWljIGNvb3BlcmF0aW9uIGJldHdlZW4gQXVzdHJhbGlhIGFuZCBDaGluYS4KCiAgICBOZXh0LCBJIHdpbGwgcmV0cmlldmUgZGV0YWlsZWQgZGVzY3JpcHRpb25zIGZvciB0aGUgcmVsYXRpb25zICIwNDYiIGFuZCAiMDQzIi4KCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQptYXBfY2FtZW9fdG9fcmVsYXRpb24oQ0FNRU9Db2RlKCIwNDYiKSlcZW5ke2xzdGxpc3Rpbmd9CiAgICBcdGV4dGJme09ic2VydmF0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dClJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIwNDYiKSwgbmFtZT0iRW5nYWdlIGluIG5lZ290aWF0aW9uIiwgZGVzY3JpcHRpb249Ik5lZ290aWF0ZSBvciBiYXJnYWluIHdpdGggb3RoZXJzLiIpXGVuZHtsc3RsaXN0aW5nfQoKICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBUaGUgcmVsYXRpb24gIjA0NiIgKEVuZ2FnZSBpbiBuZWdvdGlhdGlvbikgaW52b2x2ZXMgbmVnb3RpYXRpbmcgb3IgYmFyZ2FpbmluZyB3aXRoIG90aGVycy4gVGhpcyBpcyBjb25zaXN0ZW50IHdpdGggdGhlIG9uZ29pbmcgZGlzY3Vzc2lvbnMgYW5kIG5lZ290aWF0aW9ucyBtZW50aW9uZWQgaW4gdGhlIG5ld3MgYXJ0aWNsZXMsIHBhcnRpY3VsYXJseSByZWdhcmRpbmcgdHJhZGUgYW5kIGRpcGxvbWF0aWMgaXNzdWVzLgoKICAgIE5leHQsIEkgd2lsbCByZXRyaWV2ZSB0aGUgZGV0YWlsZWQgZGVzY3JpcHRpb24gZm9yIHRoZSByZWxhdGlvbiAiMDQzIi4KCiAgICBcdGV4dGJme0FjdGlvbn06IiIKCiAgICBcdGV4dGJme09ic2VydmF0aW9ufTogTm8gZmVlZGJhY2sgZnJvbSB0aGUgZW52aXJvbm1lbnQgZHVlIHRvIHRoZSBudWxsIGFjdGlvbi4KCiAgICBcaXRlbSBcdGV4dGJme1Rob3VnaHR9OgogICAgSXQgc2VlbXMgdGhlcmUgd2FzIGFuIGlzc3VlIHdpdGggbXkgcHJldmlvdXMgYWN0aW9ucy4gSSB3aWxsIG5vdyBwcm9jZWVkIHRvIHJldHJpZXZlIHRoZSBkZXRhaWxlZCBkZXNjcmlwdGlvbiBmb3IgdGhlIHJlbGF0aW9uICIwNDMiIHRvIGNvbXBsZXRlIHRoZSB1bmRlcnN0YW5kaW5nIG9mIHRoZSBtb3N0IGZyZXF1ZW50IGludGVyYWN0aW9ucyBiZXR3ZWVuIEF1c3RyYWxpYSBhbmQgQ2hpbmEuCgogICAgXHRleHRiZntBY3Rpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KbWFwX2NhbWVvX3RvX3JlbGF0aW9uKENBTUVPQ29kZSgiMDQzIikpXGVuZHtsc3RsaXN0aW5nfQogICAgXHRleHRiZntPYnNlcnZhdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQpSZWxhdGlvbihjYW1lb19jb2RlPUNBTUVPQ29kZSgiMDQzIiksIG5hbWU9Ikhvc3QgYSB2aXNpdCIsIGRlc2NyaXB0aW9uPSJIb3N0IG9yIHJlY2VpdmUgYSB2aXNpdG9yIGF0IHJlc2lkZW5jZSwgb2ZmaWNlIG9yIGhvbWUgY291bnRyeS4iKVxlbmR7bHN0bGlzdGluZ30KCiAgICBcaXRlbSBcdGV4dGJme1Rob3VnaHR9OgogICAgVGhlIHJlbGF0aW9uICIwNDMiIChIb3N0IGEgdmlzaXQpIGludm9sdmVzIGhvc3Rpbmcgb3IgcmVjZWl2aW5nIGEgdmlzaXRvciBhdCBhIHJlc2lkZW5jZSwgb2ZmaWNlLCBvciBob21lIGNvdW50cnkuIFRoaXMgYWxpZ25zIHdpdGggdGhlIGRpcGxvbWF0aWMgdmlzaXRzIGFuZCBlbmdhZ2VtZW50cyBtZW50aW9uZWQgaW4gdGhlIHJlY2VudCBuZXdzIGFydGljbGVzLgoKICAgIEJhc2VkIG9uIHRoZSBkZXRhaWxlZCBkZXNjcmlwdGlvbnMgYW5kIHRoZSByZWNlbnQgbmV3cyBjb250ZXh0LCB0aGUgbW9zdCBmcmVxdWVudCBpbnRlcmFjdGlvbnMgYmV0d2VlbiBBdXN0cmFsaWEgYW5kIENoaW5hIGludm9sdmUgZGlwbG9tYXRpYyB2aXNpdHMsIGVjb25vbWljIGNvb3BlcmF0aW9uLCBuZWdvdGlhdGlvbnMsIGFuZCBhc3N1cmFuY2VzLiBUaGVzZSBpbnRlcmFjdGlvbnMgc3VnZ2VzdCBhIHRyZW5kIHRvd2FyZHMgZGlwbG9tYXRpYyBhbmQgY29vcGVyYXRpdmUgZW5nYWdlbWVudHMsIHdpdGggc29tZSBjcml0aWNhbCBzdGF0ZW1lbnRzIG9yIGFjdGlvbnMgcmVsYXRlZCB0byBzZWN1cml0eSBhbmQgaHVtYW4gcmlnaHRzLgoKICAgIEdpdmVuIHRoaXMgaW5mb3JtYXRpb24sIEkgYW0gY29uZmlkZW50IGluIGZvcmVjYXN0aW5nIHRoZSBmb2xsb3dpbmcgcmVsYXRpb25zIGJldHdlZW4gQXVzdHJhbGlhIGFuZCBDaGluYSBvbiBOb3ZlbWJlciAwMywgMjAyMzoKCiAgICAtIERpcGxvbWF0aWMgdmlzaXRzIGFuZCBlbmdhZ2VtZW50cyAoIjA0MiIsICIwNDMiLCAiMDM2IikKICAgIC0gRWNvbm9taWMgY29vcGVyYXRpb24gKCIwNjEiKQogICAgLSBOZWdvdGlhdGlvbnMgKCIwNDYiKQogICAgLSBBc3N1cmFuY2VzICgiMDQwIikKCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBGaW5hbCBBbnN3ZXI6IFx7IjA0IjogWyIwNDAiLCAiMDQyIiwgIjA0MyIsICIwNDYiXSwgIjAzIjogWyIwMzYiXSwgIjA2IjogWyIwNjEiXVx9ClxlbmR7ZW51bWVyYXRlfQoKCgpcc3Vic3Vic2VjdGlvbntBZ2VudCBGaW5hbCBTdGF0dXN9ClxiZWdpbntpdGVtaXplfQogICAgXGl0ZW0gXHRleHRiZntFbmQgU3RhdGV9OiBGaW5hbCBBbnN3ZXIKICAgIFxpdGVtIFx0ZXh0YmZ7TnVtYmVyIG9mIFN0ZXBzIFRha2VufTogMTIKICAgIFxpdGVtIFx0ZXh0YmZ7RmluYWwgQW5zd2VyfToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dCnsKICAiMDMiOiBbIjAzNiJdLAogICIwNCI6IFsiMDQwIiwgIjA0MiIsICIwNDMiLCAiMDQ2Il0sCiAgIjA2IjogWyIwNjEiXQp9XGVuZHtsc3RsaXN0aW5nfQpXZSBzaG93IHRoZSBjb3JyZXNwb25kaW5nIHJlbGF0aW9uIG5hbWVzIG9mIHRoZSBwcmVkaWN0ZWQgY29kZXMgaGVyZSBmb3IgYSBiZXR0ZXIgcmV2aWV3OgogICAgICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dCnsKICAiRXhwcmVzcyBpbnRlbnQgdG8gY29vcGVyYXRlIjogWyJFeHByZXNzIGludGVudCB0byBtZWV0IG9yIG5lZ290aWF0ZSJdLAogICJDb25zdWx0IjogWyJDb25zdWx0LCBub3Qgc3BlY2lmaWVkIiwgIk1ha2UgYSB2aXNpdCIsICJIb3N0IGEgdmlzaXQiLCAiRW5nYWdlIGluIG5lZ290aWF0aW9uIl0sCiAgIkVuZ2FnZSBpbiBtYXRlcmlhbCBjb29wZXJhdGlvbiI6IFsiQ29vcGVyYXRlIGVjb25vbWljYWxseSJdCn1cZW5ke2xzdGxpc3Rpbmd9CiAgICBcaXRlbSBcdGV4dGJme0dyb3VuZCBUcnV0aCBBbnN3ZXJ9OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KewogICIwMyI6IFsiMDM2Il0sCiAgIjA0IjogWyIwNDIiXSwKICAiMTciOiBbIjE3MiJdCn1cZW5ke2xzdGxpc3Rpbmd9CldlIHNob3cgdGhlIGNvcnJlc3BvbmRpbmcgcmVsYXRpb24gbmFtZXMgb2YgdGhlIGdyb3VuZC10cnV0aCBjb2RlcyBoZXJlIGZvciBhIGJldHRlciByZXZpZXc6CiAgICAgICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KewogICJFeHByZXNzIGludGVudCB0byBjb29wZXJhdGUiOiBbIkV4cHJlc3MgaW50ZW50IHRvIG1lZXQgb3IgbmVnb3RpYXRlIl0sCiAgIkNvbnN1bHQiOiBbIk1ha2UgYSB2aXNpdCJdLAogICJDb2VyY2UiOiBbIkltcG9zZSBhZG1pbmlzdHJhdGl2ZSBzYW5jdGlvbnMiXQp9XGVuZHtsc3RsaXN0aW5nfQpcZW5ke2l0ZW1pemV9)1from  datetime  import  datetime23#  Define  the  date  range  for  the  historical  data  collection4start_date  =  Date("2023-01-01")5end_date  =  Date("2023-11-02")6date_range  =  DateRange(start_date=start_date,  end_date=end_date)78#  Define  the  ISO  codes  for  Australia  and  China9aus_code  =  ISOCode("AUS")10chn_code  =  ISOCode("CHN")1112#  Retrieve  historical  events  involving  Australia  and  China13events  =  get_events(date_range=date_range,  head_entities=[aus_code],  tail_entities=[chn_code])1415#  Print  the  retrieved  events16for  event  in  events:17  print(event)\end{lstlisting}18  \textbf{Observation}:19  \begin{lstlisting}[language=python]20Event(date=Date("2023-11-02"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))21Event(date=Date("2023-11-02"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("040"),  tail_entity=ISOCode("CHN"))22Event(date=Date("2023-11-02"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))23Event(date=Date("2023-11-01"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))24Event(date=Date("2023-11-01"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("173"),  tail_entity=ISOCode("CHN"))25Event(date=Date("2023-11-01"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))26Event(date=Date("2023-10-31"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))27Event(date=Date("2023-10-31"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))28Event(date=Date("2023-10-31"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("046"),  tail_entity=ISOCode("CHN"))29Event(date=Date("2023-10-30"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))30Event(date=Date("2023-10-30"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))31Event(date=Date("2023-10-30"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("046"),  tail_entity=ISOCode("CHN"))32Event(date=Date("2023-10-29"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))33Event(date=Date("2023-10-27"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))34Event(date=Date("2023-10-27"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))35Event(date=Date("2023-10-26"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("173"),  tail_entity=ISOCode("CHN"))36Event(date=Date("2023-10-26"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("061"),  tail_entity=ISOCode("CHN"))37Event(date=Date("2023-10-26"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))38Event(date=Date("2023-10-25"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))39Event(date=Date("2023-10-23"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))40Event(date=Date("2023-10-23"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))41Event(date=Date("2023-10-23"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("031"),  tail_entity=ISOCode("CHN"))42Event(date=Date("2023-10-23"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("061"),  tail_entity=ISOCode("CHN"))43Event(date=Date("2023-10-22"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("040"),  tail_entity=ISOCode("CHN"))44Event(date=Date("2023-10-22"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("061"),  tail_entity=ISOCode("CHN"))45Event(date=Date("2023-10-22"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))46Event(date=Date("2023-10-22"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("043"),  tail_entity=ISOCode("CHN"))47Event(date=Date("2023-10-22"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))48Event(date=Date("2023-10-21"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))49Event(date=Date("2023-10-21"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("040"),  tail_entity=ISOCode("CHN"))\end{lstlisting}50  \item  \textbf{Thought}:51  The  retrieved  events  indicate  a  variety  of  relations  between  Australia  and  China.  To  forecast  the  future  relations,  we  need  to  analyze  the  distribution  of  these  relations  to  identify  the  most  common  types  and  any  recent  trends.5253  Next,  we  will  analyze  the  distribution  of  the  different  CAMEO  codes  in  these  events  to  identify  the  most  frequent  interactions.  This  will  help  us  understand  the  dominant  types  of  relations  and  any  emerging  patterns.5455  \textbf{Action}:56  \begin{lstlisting}[language=python]57from  collections  import  Counter5859#  Extract  the  CAMEO  codes  from  the  retrieved  events60cameo_codes  =  [event.relation.code  for  event  in  events]6162#  Count  the  frequency  of  each  CAMEO  code63cameo_code_counts  =  Counter(cameo_codes)6465#  Print  the  distribution  of  CAMEO  codes66for  code,  count  in  cameo_code_counts.items():67  print(f"CAMEO  Code:  {code},  Count:  {count}")\end{lstlisting}68  \textbf{Observation}:69  \begin{lstlisting}[language=python]70CAMEO  Code:  042,  Count:  1071CAMEO  Code:  040,  Count:  372CAMEO  Code:  036,  Count:  873CAMEO  Code:  173,  Count:  274CAMEO  Code:  046,  Count:  275CAMEO  Code:  061,  Count:  376CAMEO  Code:  031,  Count:  177CAMEO  Code:  043,  Count:  1\end{lstlisting}78  \item  \textbf{Thought}:79  The  distribution  of  CAMEO  codes  from  the  historical  events  between  Australia  and  China  reveals  that  certain  types  of  interactions  are  more  frequent  than  others.  Specifically,  the  most  common  relations  are:8081  -  \textbf{042}:  10  occurrences\\82  -  \textbf{036}:  8  occurrences\\83  -  \textbf{040}:  3  occurrences\\84  -  \textbf{061}:  3  occurrences\\85  -  \textbf{046}:  2  occurrences\\86  -  \textbf{173}:  2  occurrences\\87  -  \textbf{031}:  1  occurrence\\88  -  \textbf{043}:  1  occurrence\\89  To  make  a  more  informed  forecast,  we  should  understand  what  these  CAMEO  codes  represent.  We  will  map  these  codes  to  their  descriptions  to  gain  insights  into  the  nature  of  these  interactions.9091  \textbf{Action}:92  \begin{lstlisting}[language=python]93#  Define  the  CAMEO  codes  to  map94cameo_codes_to_map  =  ["042",  "036",  "040",  "061",  "046",  "173",  "031",  "043"]9596#  Map  the  CAMEO  codes  to  their  descriptions97relations  =  [map_cameo_to_relation(CAMEOCode(code))  for  code  in  cameo_codes_to_map]9899#  Print  the  descriptions  of  the  CAMEO  codes100for  relation  in  relations:101  print(f"CAMEO  Code:  {relation.cameo_code.code},  Name:  {relation.name},  Description:  {relation.description}")\end{lstlisting}102  \textbf{Observation}:103  \begin{lstlisting}[language=python]104CAMEO  Code:  042,  Name:  Make  a  visit,  Description:  Travel  to  another  location  for  a  meeting  or  other  event.105CAMEO  Code:  036,  Name:  Express  intent  to  meet  or  negotiate,  Description:  Offer,  promise,  agree  to,  or  otherwise  indicate  willingness  or  commitment  to  meet,  visit,  or  engage  in  talks  or  negotiations.106CAMEO  Code:  040,  Name:  Consult,  not  specified,  Description:  All  consultations  and  meetings,  not  otherwise  specified.107CAMEO  Code:  061,  Name:  Cooperate  economically,  Description:  Initiate,  resume,  improve,  or  expand  economic  exchange  or  cooperation.108CAMEO  Code:  046,  Name:  Engage  in  negotiation,  Description:  Negotiate  or  bargain  with  others.109CAMEO  Code:  173,  Name:  Arrest  or  detain,  Description:  Legal  or  extrajudicial  arrests,  detentions,  or  imprisonments.110CAMEO  Code:  031,  Name:  Express  intent  to  engage  in  material  cooperation,  Description:  Offer,  promise,  agree  to,  or  otherwise  indicate  willingness  or  commitment  to  engage  in  or  expand  material  cooperative  exchange,  such  as  express  intent  to  cooperate  economically,  militarily,  on  judicial  matters,  and  on  intelligence.111CAMEO  Code:  043,  Name:  Host  a  visit,  Description:  Host  or  receive  a  visitor  at  residence,  office  or  home  country.\end{lstlisting}112  \item  \textbf{Thought}:113  The  mapped  CAMEO  codes  and  their  descriptions  provide  valuable  insights  into  the  nature  of  interactions  between  Australia  and  China.  Here  are  the  key  relations  observed:114115  -  \textbf{042  (Make  a  visit)}:  10  occurrences  –  Indicates  frequent  travel  for  meetings  or  events.\\116  -  \textbf{036  (Express  intent  to  meet  or  negotiate)}:  8  occurrences  –  Shows  a  strong  intent  to  engage  in  talks  or  negotiations.\\117  -  \textbf{040  (Consult,  not  specified)}:  3  occurrences  –  General  consultations  and  meetings.\\118  -  \textbf{061  (Cooperate  economically)}:  3  occurrences  –  Economic  cooperation  initiatives.\\119  -  \textbf{046  (Engage  in  negotiation)}:  2  occurrences  –  Actual  negotiations  or  bargaining.\\120  -  \textbf{173  (Arrest  or  detain)}:  2  occurrences  –  Legal  or  extrajudicial  arrests  or  detentions.\\121  -  \textbf{031  (Express  intent  to  engage  in  material  cooperation)}:  1  occurrence  –  Intent  to  cooperate  materially.\\122  -  \textbf{043  (Host  a  visit)}:  1  occurrence  –  Hosting  visitors.\\123124  Given  this  data,  we  can  see  that  the  most  frequent  interactions  involve  visits,  expressions  of  intent  to  meet  or  negotiate,  and  economic  cooperation.  These  interactions  suggest  a  pattern  of  diplomatic  engagement  and  economic  collaboration,  with  occasional  legal  actions.125126  To  further  solidify  our  forecast,  we  should  examine  recent  news  articles  to  understand  the  context  and  any  underlying  reasons  for  these  interactions.  This  will  help  us  identify  any  emerging  trends  or  significant  events  that  might  influence  future  relations.127128  Next,  we  will  retrieve  recent  news  articles  involving  Australia  and  China  to  gain  contextual  insights.129130  \textbf{Action}:131  \begin{lstlisting}[language=python]132#  Define  the  date  range  for  recent  news  articles133recent_start_date  =  Date("2023-10-01")134recent_end_date  =  Date("2023-11-02")135recent_date_range  =  DateRange(start_date=recent_start_date,  end_date=recent_end_date)136137#  Retrieve  recent  news  articles  involving  Australia  and  China138news_articles  =  get_news_articles(date_range=recent_date_range,  head_entities=[aus_code],  tail_entities=[chn_code])139140#  Print  the  retrieved  news  articles141for  article  in  news_articles:142  print(article)\end{lstlisting}143  \textbf{Observation}:144  \begin{lstlisting}[language=python]145(Date(date="2023-11-02"),  "No  quick  fix  to  remaining  tariffs  ahead  of  China  visit")146(Date(date="2023-11-02"),  "China"s  aggression  in  Indo-Pacific  leads  to  "concern  and  angst":  Peter  Dutton,  Australia"s  leader  of  opposition")147(Date(date="2023-11-02"),  "Australia  and  China  eye  new  ways  to  heal  old  wounds")148(Date(date="2023-11-02"),  "Albanese  must  aim  beyond  bilateral  outcomes  on  Beijing  visit")149(Date(date="2023-11-02"),  "Western  Australian  Premier  Announces  Visit  to  China")150(Date(date="2023-11-02"),  "Australian  PM"s  China  visit  will  help  normalize  relations,  says  ex-trade  minister")151(Date(date="2023-11-02"),  "Nicholas  Moore  on  how  to  get  in  early  on  the  next  big  growth  story")152(Date(date="2023-11-02"),  "PM"s  China  trip  cements  new  era  for  ties")153(Date(date="2023-11-02"),  "PM  to  take  a  hard  line  on  trade  with  China")154(Date(date="2023-11-01"),  "Australian  Prime  Minister  Anthony  Albanese  to  raise  imprisoned  democracy  blogger  during  China  visit")\end{lstlisting}155  \item  \textbf{Thought}:156  The  recent  news  articles  provide  valuable  context  for  the  relations  between  Australia  and  China.  Key  themes  include:\\157158  1.  \textbf{Diplomatic  Visits  and  Engagements}:  Multiple  articles  highlight  the  upcoming  visit  of  Australian  Prime  Minister  Anthony  Albanese  to  China.  This  aligns  with  the  frequent  occurrence  of  CAMEO  code  \textbf{042  (Make  a  visit)}.\\159  2.  \textbf{Economic  Cooperation  and  Trade}:  Discussions  around  trade  and  economic  cooperation  are  prominent,  indicating  ongoing  efforts  to  improve  economic  ties.  This  supports  the  relevance  of  CAMEO  codes  \textbf{061  (Cooperate  economically)}  and  \textbf{036  (Express  intent  to  meet  or  negotiate)}.\\160  3.  \textbf{Concerns  and  Tensions}:  Articles  mention  concerns  about  China"s  aggression  in  the  Indo-Pacific  and  human  rights  issues,  suggesting  underlying  tensions.  This  is  reflected  in  the  occasional  occurrence  of  CAMEO  code  \textbf{173  (Arrest  or  detain)}.161162  Given  the  historical  data  and  recent  news  context,  the  most  likely  relations  that  Australia  will  take  towards  China  on  November  03,  2023,  include  diplomatic  visits,  economic  cooperation,  and  negotiations,  with  a  possibility  of  addressing  underlying  tensions.163164  Final  Answer:165  \begin{lstlisting}[language=python]166{167  "03":  ["031",  "036"],168  "04":  ["040",  "042",  "043",  "046"],169  "06":  ["061"],170  "17":  ["173"]171}\end{lstlisting}172173  \textbf{Action}:174  Final  Answer:175  \begin{lstlisting}[language=python]176{177  "03":  ["031",  "036"],178  "04":  ["040",  "042",  "043",  "046"],179  "06":  ["061"],180  "17":  ["173"]181}\end{lstlisting}182\end{enumerate}183184185\subsubsection{Agent  Final  Status}186\begin{itemize}187  \item  \textbf{End  State}:  Final  Answer188  \item  \textbf{Number  of  Steps  Taken}:  5189  \item  \textbf{Final  Answer}:190  \begin{lstlisting}[language=python]191{192  "03":  ["031",  "036"],193  "04":  ["040",  "042",  "043",  "046"],194  "06":  ["061"],195  "17":  ["173"]196}\end{lstlisting}197We  show  the  corresponding  relation  names  of  the  predicted  codes  here  for  a  better  review:198  \begin{lstlisting}[language=python]199{200  "Express  intent  to  cooperate":  ["Express  intent  to  engage  in  material  cooperation",  "Express  intent  to  meet  or  negotiate"],201  "Consult":  ["Consult,  not  specified",  "Make  a  visit",  "Host  a  visit",  "Engage  in  negotiation"],202  "Engage  in  material  cooperation":  ["Cooperate  economically"],203  "Coerce":  ["Arrest  or  detain"]204}\end{lstlisting}205  \item  \textbf{Ground  Truth  Answer}:206  \begin{lstlisting}[language=python]207{208  "03":  ["036"],209  "04":  ["042"],210  "17":  ["172"]211}\end{lstlisting}212We  show  the  corresponding  relation  names  of  the  ground-truth  codes  here  for  a  better  review:213  \begin{lstlisting}[language=python]214{215  "Express  intent  to  cooperate":  ["Express  intent  to  meet  or  negotiate"],216  "Consult":  ["Make  a  visit"],217  "Coerce":  ["Impose  administrative  sanctions"]218}\end{lstlisting}219\end{itemize}220221222223224\subsection{GPT-4o-based  Agent  with  ReAct  and  ‘‘\hlc[uclablue!20]{Single  Function}’’  Action}225226\subsubsection{Query  Details}227\begin{itemize}228  \item  \textbf{Query  Quadruplet}:  (2023-11-03,  AUS,  ?,  CHN)229  \item  \textbf{Temporal  Distance}:  1;  therefore,  the  current  date  is  2023-11-02230  \item  \textbf{Agent  Max  Steps}:  20231\end{itemize}232233\subsubsection{Query  Prompt}234Please  forecast  the  relations  that  \hlc[yellow!30]{Australia}  will  take  towards  \hlc[yellow!30]{China}  on  \hlc[yellow!30]{November  03,  2023}  based  on  historical  information  up  to  \hlc[yellow!30]{November  02,  2023}.  I.e.  forecast  the  relation  CAMEO  codes  in  query  event  \hlc[yellow!30]{Event(date=2023-11-03,  head\_entity=ISOCode(AUS),  relation=CAMEOCode(?),  tail\_entity=ISOCode(CHN))}.235236\subsubsection{System  Prompt}237You  are  an  expert  in  forecasting  future  events  based  on  historical  data.  The  database  contains  news  articles  from  January  1,  2023  to  the  current  date  \hlc[yellow!30]{November  02,  2023}  and  the  events  extracted  from  these  articles.  The  events  are  in  the  form  of  (date,  subject  country,  relation,  object  country),  where  the  countries  are  represented  by  ISO  3166-1  alpha-3  codes  and  the  relations  are  represented  by  the  CAMEO  codes  defined  in  the  "Conflict  and  Mediation  Event  Observations"  ontology.  The  relations  are  hierarchical:  first-level  relations  are  general  parent  relations  represented  by  two-digit  CAMEO  codes,  while  second-level  relations  are  more  specific  child  relations  represented  by  three-digit  CAMEO  codes.  Child  relations  have  the  same  first  two  digits  as  their  parent  relations.  For  example,  "01"  is  a  first-level  relation,  and  "010"  and  "011"  are  some  of  its  second-level  relations.  The  relations  in  the  database  are  represented  in  the  second-level  form.238\\\\239Your  task  is  to  forecast  the  future  relations  between  two  entities  in  a  given  query.  You  have  access  to  a  defined  Python  API  that  allows  you  to  query  the  database  for  historical  events  and  statistics,  and  to  get  precise  information  about  the  ISO  country  codes  and  CAMEO  relation  codes.240\\\\241The  defined  API  is  described  as  follows:\\242{\textasciigrave}{\textasciigrave}{\textasciigrave}  python\\243\texttt{\{api\_description\}}\\244{\textasciigrave}{\textasciigrave}{\textasciigrave}245\\\\246You  will  use  an  iterative  approach,  interleaving  "Thought",  "Action",  and  "Observation"  steps  to  collect  information  and  perform  the  forecast.  You  may  perform  up  to  \hlc[yellow!30]{20}  iterations.  The  steps  are  as  follows:247\\\\248-  "Thought":  Analyze  the  current  information  and  reason  about  the  current  situation,  and  predicts  which  API  you  want  to  use  (try  to  use  different  APIs  to  collect  diverse  information)  or  make  a  decision  that  you  want  to  make  a  final  answer.\\249-  "Action":  Use  the  API  to  gather  more  information  or  provide  the  final  forecast.\\250  \hspace*{6mm}-  If  using  the  API:  \hlc[uclablue!20]{the  action  must  be  only  one  single  line  of  exactly  one  function  call  from  the  API  with  appropriate  inputs,  without  additional  code,  explanations,  or  natural  language  descriptions}.\\251  \hspace*{6mm}-  If  making  the  final  forecast:  the  action  must  start  immediately  with  "Final  Answer:",  and  follow  with  the  results  in  the  expected  JSON  format.\\252-  "Observation":  Return  the  output  of  the  called  function.253\\\\254To  make  a  reasonable  forecast,  you  should  collect  both  news  and  relational  evidence  to  support  your  prediction.  When  you  are  fully  confident  that  you  accumulate  enough  information  to  make  the  final  forecast,  you  should  start  the  "Thought"  with  your  reasoning  using  the  news  and  structural  information  to  make  the  prediction,  and  then  start  the  "Action"  step  with  "Final  Answer:"  followed  by  the  answer  in  the  expected  JSON  format.  The  answer  should  be  a  JSON  dictionary  where  the  keys  are  the  forecasted  two-digit  first-level  CAMEO  codes  and  the  values  are  lists  of  forecasted  three-digit  second-level  CAMEO  codes  that  are  child  relations  of  the  key.  For  example,  "Action:  Final  Answer:  \{"01":  ["010",  "011",  "012"],  "02":  ["020",  "023"]\}".255\\\\256The  final  answer  will  be  evaluated  based  on  the  precision  and  recall  of  the  forecasted  first-level  and  second-level  relations,  so  only  include  confident  first-level  and  second-level  CAMEO  codes  in  your  final  forecast.257\\\\258Try  to  use  different  APIs  to  collect  diverse  information  (including  multi-hop  relations),  such  as  the  precise  meaning  of  CAMEO  codes,  insights  from  news  content,  relational  data,  and  statistical  analyses  to  support  your  forecasts.  Consider  not  only  the  frequency  of  the  relations  but  also  the  temporal  aspects  of  the  data  when  making  your  forecast.259260\subsubsection{Agent  ReAct  Process}261\begin{enumerate}262  \item  \textbf{Thought}:263  To  forecast  the  relations  that  Australia  (AUS)  will  take  towards  China  (CHN)  on  November  03,  2023,  I  will  start  by  gathering  historical  data  on  the  interactions  between  these  two  countries.  This  will  include  the  types  of  relations,  their  frequencies,  and  the  context  in  which  they  occurred.  I  will  use  the  following  steps:264265  \begin{enumerate}266  \item  Retrieve  the  distribution  of  second-level  relations  between  Australia  and  China.267  \item  Analyze  the  distribution  to  identify  the  most  common  types  of  interactions.268  \item  Examine  recent  news  articles  to  understand  the  context  and  any  ongoing  trends  or  events  that  might  influence  future  relations.269  \end{enumerate}270271  \textbf{Action}:272  \begin{lstlisting}[language=python]273get_relation_distribution(head_entities=[ISOCode("AUS")],  tail_entities=[ISOCode("CHN")])\end{lstlisting}274  \textbf{Observation}:275  \begin{lstlisting}[language=python]276{CAMEOCode(code="042"):  32,277  CAMEOCode(code="036"):  30,278  CAMEOCode(code="040"):  17,279CAMEOCode(code="061"):  16,280CAMEOCode(code="046"):  12,281CAMEOCode(code="043"):  11,282CAMEOCode(code="010"):  6,283CAMEOCode(code="020"):  5,284CAMEOCode(code="173"):  5,285CAMEOCode(code="012"):  5,286CAMEOCode(code="051"):  4,287CAMEOCode(code="163"):  3,288CAMEOCode(code="128"):  2,289CAMEOCode(code="050"):  2,290CAMEOCode(code="084"):  2,291CAMEOCode(code="090"):  2,292CAMEOCode(code="174"):  1,293CAMEOCode(code="112"):  1,294CAMEOCode(code="130"):  1,295CAMEOCode(code="160"):  1,296CAMEOCode(code="172"):  1,297CAMEOCode(code="192"):  1,298CAMEOCode(code="190"):  1,299CAMEOCode(code="060"):  1,300CAMEOCode(code="030"):  1,301CAMEOCode(code="035"):  1,302CAMEOCode(code="138"):  1,303CAMEOCode(code="071"):  1,304CAMEOCode(code="031"):  1}\end{lstlisting}305  \item  \textbf{Thought}:306  The  distribution  of  second-level  relations  between  Australia  and  China  shows  a  variety  of  interactions,  with  some  relations  being  more  frequent  than  others.  The  most  common  interactions  include:307308  -  "042"  (Consult):  32  occurrences\\309  -  "036"  (Express  intent  to  cooperate):  30  occurrences\\310  -  "040"  (Assure):  17  occurrences\\311  -  "061"  (Cooperate  economically):  16  occurrences\\312  -  "046"  (Praise  or  endorse):  12  occurrences\\313  -  "043"  (Apologize):  11  occurrences\\314315  These  frequent  interactions  suggest  a  trend  towards  diplomatic  and  cooperative  engagements.  However,  to  make  a  more  informed  forecast,  it  is  essential  to  understand  the  context  and  any  recent  developments  that  might  influence  future  relations.316317  Next,  I  will  retrieve  recent  news  articles  involving  Australia  and  China  to  gather  insights  on  the  current  context  and  any  ongoing  trends  or  events.318319  \textbf{Action}:320  \begin{lstlisting}[language=python]321get_news_articles(date_range=DateRange(start_date=Date("2023-10-01"),  end_date=Date("2023-11-02")),  head_entities=[ISOCode("AUS")],  tail_entities=[ISOCode("CHN")])\end{lstlisting}322  \textbf{Observation}:323  \begin{lstlisting}[language=python]324[(Date(date="2023-11-02"),  "No  quick  fix  to  remaining  tariffs  ahead  of  China  visit"),325  (Date(date="2023-11-02"),  "China"s  aggression  in  Indo-Pacific  leads  to  "concern  and  angst":  Peter  Dutton,  Australia"s  leader  of  opposition"),326  (Date(date="2023-11-02"),  "Australia  and  China  eye  new  ways  to  heal  old  wounds"),327  (Date(date="2023-11-02"),  "Albanese  must  aim  beyond  bilateral  outcomes  on  Beijing  visit"),328  (Date(date="2023-11-02"),  "Western  Australian  Premier  Announces  Visit  to  China"),329  (Date(date="2023-11-02"),  "Australian  PM"s  China  visit  will  help  normalize  relations,  says  ex-trade  minister"),330  (Date(date="2023-11-02"),  "Nicholas  Moore  on  how  to  get  in  early  on  the  next  big  growth  story"),331  (Date(date="2023-11-02"),  "PM"s  China  trip  cements  new  era  for  ties"),332  (Date(date="2023-11-02"),  "PM  to  take  a  hard  line  on  trade  with  China"),333  (Date(date="2023-11-01"),  "Australian  Prime  Minister  Anthony  Albanese  to  raise  imprisoned  democracy  blogger  during  China  visit")]\end{lstlisting}334  \item  \textbf{Thought}:335  The  recent  news  articles  indicate  a  mix  of  diplomatic,  economic,  and  security-related  interactions  between  Australia  and  China.  Key  themes  include:336337  -  Diplomatic  engagements  and  efforts  to  normalize  relations,  as  seen  in  articles  about  the  Australian  Prime  Minister"s  visit  to  China  and  efforts  to  heal  old  wounds.\\338  -  Economic  cooperation  and  trade  discussions,  including  addressing  tariffs  and  trade  issues.\\339  -  Security  concerns  and  criticisms,  particularly  related  to  China"s  actions  in  the  Indo-Pacific  region  and  human  rights  issues.\\340341  Given  these  themes,  it  is  likely  that  the  future  relations  between  Australia  and  China  will  involve  a  combination  of  diplomatic  assurances,  economic  cooperation,  and  some  critical  statements  or  actions  related  to  security  and  human  rights.342343  Next,  I  will  retrieve  detailed  descriptions  of  the  most  frequent  second-level  relations  to  ensure  accurate  mapping  and  understanding  of  these  interactions.344345  \textbf{Action}:346  \begin{lstlisting}[language=python]347map_cameo_to_relation(CAMEOCode("042"))\end{lstlisting}348  \textbf{Observation}:349  \begin{lstlisting}[language=python]350Relation(cameo_code=CAMEOCode("042"),  name="Make  a  visit",  description="Travel  to  another  location  for  a  meeting  or  other  event.")\end{lstlisting}351  \item  \textbf{Thought}:352  The  relation  "042"  (Make  a  visit)  involves  traveling  to  another  location  for  a  meeting  or  other  event,  which  aligns  with  the  recent  news  about  the  Australian  Prime  Minister"s  visit  to  China.  This  suggests  that  diplomatic  visits  are  a  significant  aspect  of  the  interactions  between  Australia  and  China.353354  To  further  refine  the  forecast,  I  will  retrieve  detailed  descriptions  for  the  other  most  frequent  second-level  relations:  "036",  "040",  "061",  "046",  and  "043".355356  \textbf{Action}:357  \begin{lstlisting}[language=python]358map_cameo_to_relation(CAMEOCode("036"))\end{lstlisting}359  \textbf{Observation}:360  \begin{lstlisting}[language=python]361Relation(cameo_code=CAMEOCode("036"),  name="Express  intent  to  meet  or  negotiate",  description="Offer,  promise,  agree  to,  or  otherwise  indicate  willingness  or  commitment  to  meet,  visit,  or  engage  in  talks  or  negotiations.")\end{lstlisting}362  \item  \textbf{Thought}:363  The  relation  "036"  (Express  intent  to  meet  or  negotiate)  involves  indicating  a  willingness  or  commitment  to  meet,  visit,  or  engage  in  talks  or  negotiations.  This  aligns  with  the  ongoing  diplomatic  efforts  and  discussions  mentioned  in  the  recent  news  articles.364365  Next,  I  will  retrieve  detailed  descriptions  for  the  relations  "040",  "061",  "046",  and  "043"  to  further  understand  the  context  of  these  interactions.366367  \textbf{Action}:368  \begin{lstlisting}[language=python]369get_parent_relation(CAMEOCode("040"))\end{lstlisting}370  \textbf{Observation}:371  \begin{lstlisting}[language=python]372Relation(cameo_code=CAMEOCode("04"),  name="Consult",  description="All  consultations  and  meetings.")\end{lstlisting}373  \item  \textbf{Thought}:374  The  parent  relation  ‘04‘  (Consult)  encompasses  all  consultations  and  meetings,  which  is  consistent  with  the  frequent  diplomatic  interactions  between  Australia  and  China.  The  specific  relation  "040"  (Assure)  likely  involves  providing  assurances  during  these  consultations.375376  To  further  refine  the  forecast,  I  will  retrieve  detailed  descriptions  for  the  relations  "061",  "046",  and  "043".377378  \textbf{Action}:""379380  \textbf{Observation}:  No  feedback  from  the  environment  due  to  the  null  action.381  \item  \textbf{Thought}:382  I  will  continue  retrieving  detailed  descriptions  for  the  relations  "061",  "046",  and  "043"  to  further  understand  the  context  of  these  interactions.383384  \textbf{Action}:""385386  \textbf{Observation}:  No  feedback  from  the  environment  due  to  the  null  action.387  \item  \textbf{Thought}:388  It  seems  there  was  an  issue  with  my  previous  actions.  I  will  now  proceed  to  retrieve  the  detailed  descriptions  for  the  remaining  frequent  second-level  relations:  "061",  "046",  and  "043".389  \textbf{Action}:390  \begin{lstlisting}[language=python]391map_cameo_to_relation(CAMEOCode("061"))\end{lstlisting}392  \textbf{Observation}:393  \begin{lstlisting}[language=python]394Relation(cameo_code=CAMEOCode("061"),  name="Cooperate  economically",  description="Initiate,  resume,  improve,  or  expand  economic  exchange  or  cooperation.")\end{lstlisting}395  \item  \textbf{Thought}:396  The  relation  "061"  (Cooperate  economically)  involves  initiating,  resuming,  improving,  or  expanding  economic  exchange  or  cooperation.  This  aligns  with  the  recent  news  articles  discussing  trade  issues  and  economic  cooperation  between  Australia  and  China.397398  Next,  I  will  retrieve  detailed  descriptions  for  the  relations  "046"  and  "043".399400  \textbf{Action}:401  \begin{lstlisting}[language=python]402map_cameo_to_relation(CAMEOCode("046"))\end{lstlisting}403  \textbf{Observation}:404  \begin{lstlisting}[language=python]405Relation(cameo_code=CAMEOCode("046"),  name="Engage  in  negotiation",  description="Negotiate  or  bargain  with  others.")\end{lstlisting}406407  \item  \textbf{Thought}:408  The  relation  "046"  (Engage  in  negotiation)  involves  negotiating  or  bargaining  with  others.  This  is  consistent  with  the  ongoing  discussions  and  negotiations  mentioned  in  the  news  articles,  particularly  regarding  trade  and  diplomatic  issues.409410  Next,  I  will  retrieve  the  detailed  description  for  the  relation  "043".411412  \textbf{Action}:""413414  \textbf{Observation}:  No  feedback  from  the  environment  due  to  the  null  action.415416  \item  \textbf{Thought}:417  It  seems  there  was  an  issue  with  my  previous  actions.  I  will  now  proceed  to  retrieve  the  detailed  description  for  the  relation  "043"  to  complete  the  understanding  of  the  most  frequent  interactions  between  Australia  and  China.418419  \textbf{Action}:420  \begin{lstlisting}[language=python]421map_cameo_to_relation(CAMEOCode("043"))\end{lstlisting}422  \textbf{Observation}:423  \begin{lstlisting}[language=python]424Relation(cameo_code=CAMEOCode("043"),  name="Host  a  visit",  description="Host  or  receive  a  visitor  at  residence,  office  or  home  country.")\end{lstlisting}425426  \item  \textbf{Thought}:427  The  relation  "043"  (Host  a  visit)  involves  hosting  or  receiving  a  visitor  at  a  residence,  office,  or  home  country.  This  aligns  with  the  diplomatic  visits  and  engagements  mentioned  in  the  recent  news  articles.428429  Based  on  the  detailed  descriptions  and  the  recent  news  context,  the  most  frequent  interactions  between  Australia  and  China  involve  diplomatic  visits,  economic  cooperation,  negotiations,  and  assurances.  These  interactions  suggest  a  trend  towards  diplomatic  and  cooperative  engagements,  with  some  critical  statements  or  actions  related  to  security  and  human  rights.430431  Given  this  information,  I  am  confident  in  forecasting  the  following  relations  between  Australia  and  China  on  November  03,  2023:432433  -  Diplomatic  visits  and  engagements  ("042",  "043",  "036")434  -  Economic  cooperation  ("061")435  -  Negotiations  ("046")436  -  Assurances  ("040")437438  \textbf{Action}:439  Final  Answer:  \{"04":  ["040",  "042",  "043",  "046"],  "03":  ["036"],  "06":  ["061"]\}440\end{enumerate}441442443444\subsubsection{Agent  Final  Status}445\begin{itemize}446  \item  \textbf{End  State}:  Final  Answer447  \item  \textbf{Number  of  Steps  Taken}:  12448  \item  \textbf{Final  Answer}:449  \begin{lstlisting}[language=python]450{451  "03":  ["036"],452  "04":  ["040",  "042",  "043",  "046"],453  "06":  ["061"]454}\end{lstlisting}455We  show  the  corresponding  relation  names  of  the  predicted  codes  here  for  a  better  review:456  \begin{lstlisting}[language=python]457{458  "Express  intent  to  cooperate":  ["Express  intent  to  meet  or  negotiate"],459  "Consult":  ["Consult,  not  specified",  "Make  a  visit",  "Host  a  visit",  "Engage  in  negotiation"],460  "Engage  in  material  cooperation":  ["Cooperate  economically"]461}\end{lstlisting}462  \item  \textbf{Ground  Truth  Answer}:463  \begin{lstlisting}[language=python]464{465  "03":  ["036"],466  "04":  ["042"],467  "17":  ["172"]468}\end{lstlisting}469We  show  the  corresponding  relation  names  of  the  ground-truth  codes  here  for  a  better  review:470  \begin{lstlisting}[language=python]471{472  "Express  intent  to  cooperate":  ["Express  intent  to  meet  or  negotiate"],473  "Consult":  ["Make  a  visit"],474  "Coerce":  ["Impose  administrative  sanctions"]475}\end{lstlisting}476\end{itemize}

    ## Appendix M Additional Information about API

    ### M.1 Overview of API Data Classes and Functions

    Table 7: API data classes and their attributes

     | Class Name | Attributes and Types |
    | Date | date:  str  #  ‘YYYY-MM-DD’ |
    | DateRange | start_date:  Optional[Date], end_date:  Optional[Date] |
    | ISOCode | code:  str  #  3-letter  ISO  code |
    | Country | iso_code:  ISOCode, name:  str |
    | CAMEOCode | code:  str  #  CAMEO  code |
    | Relation | cameo_code:  CAMEOCode, name:  str, description:  str |
    | Event | date:  Date, head_entity:  ISOCode, relation:  CAMEOCode, tail_entity:  ISOCode |
    | NewsArticle | date:  Date, title:  str, content:  str, events:  List[Event] | 

    Table 8: API functions categorized by functionality

    | Functions related to Countries and Relations |
    | map_country_name_to_iso(name:  str)  ->  List[Country] |
    | map_iso_to_country_name(iso_code:  ISOCode)  ->  str |
    | map_relation_description_to_cameo(description:  str)  ->  List[Relation] |
    | map_cameo_to_relation(cameo_code:  CAMEOCode)  ->  Relation |
    | get_parent_relation(cameo_code:  CAMEOCode)  ->  Relation |
    | get_child_relations(cameo_code:  CAMEOCode)  ->  List[Relation] |
    | get_sibling_relations(cameo_code:  CAMEOCode)  ->  List[Relation] |
    | Functions related to Events |
    | count_events(date_range:  Optional[DateRange],  head_entities:  Optional[List[ISO%Code]],  tail_entities:  Optional[List[ISOCode]],  relations:  Optional[List[CAMEO%Code]])  ->  int |
    | get_events(date_range:  Optional[DateRange],  head_entities:  Optional[List[ISOCo%de]],  tail_entities:  Optional[List[ISOCode]],  relations:  Optional[List[CAMEOCo%de]],  text_description:  Optional[str])  ->  List[Event] |
    | get_entity_distribution(date_range:  Optional[DateRange],  involved_relations:  O%ptional[List[CAMEOCode]],  interacted_entities:  Optional[List[ISOCode]],  entity%_role:  Optional[str])  ->  Dict[ISOCode,  int] |
    | get_relation_distribution(date_range:  Optional[DateRange],  head_entities:  Opti%onal[List[ISOCode]],  tail_entities:  Optional[List[ISOCode]])  ->  Dict[CAMEOCode%,  int] |
    | Functions related to News |
    | count_news_articles(date_range:  Optional[DateRange],  head_entities:  Optional[L%ist[ISOCode]],  tail_entities:  Optional[List[ISOCode]],  relations:  Optional[Lis%t[CAMEOCode]],  keywords:  Optional[List[str]])  ->  int |
    | get_news_articles(date_range:  Optional[DateRange],  head_entities:  Optional[Lis%t[ISOCode]],  tail_entities:  Optional[List[ISOCode]],  relations:  Optional[List[%CAMEOCode]],  keywords:  Optional[List[str]],  text_description:  Optional[str])  -%>  List[Tuple[Date,  str]] |
    | browse_news_article(date:  Date,  title:  str)  ->  str |

    ### M.2 API Specification

    In this section, we provide the API specification, which is part of the system prompt for the ReAct agent. It contains the definition of data classes and functions, with detailed Python docstring. For dataclass, the specification includes class definition and description, attributes and their description, and the example of initializing the class object. For functions, the specification includes the function definition and description, the parameter and description, the return and description, and the example of usage.

    [⬇](data:text/plain;base64,QGRhdGFjbGFzcwpjbGFzcyBEYXRlOgogICAgIiIiUmVwcmVzZW50cyBhIGRhdGUuIiIiCiAgICBkYXRlOiBzdHIgIyBEYXRlIGluIHRoZSBmb3JtYXQgJ1lZWVktTU0tREQnCiAgICAjIEV4YW1wbGU6IERhdGUoIjIwMjItMDEtMDEiKQoKQGRhdGFjbGFzcwpjbGFzcyBEYXRlUmFuZ2U6CiAgICAiIiJSZXByZXNlbnRzIGEgcmFuZ2Ugb2YgZGF0ZXMgKGluY2x1c2l2ZSkuIiIiCiAgICBzdGFydF9kYXRlOiBPcHRpb25hbFtEYXRlXSAjIElmIE5vbmUsIHRoZSBlYXJsaWVzdCBkYXRlIGlzIHVzZWQKICAgIGVuZF9kYXRlOiBPcHRpb25hbFtEYXRlXSAjIElmIE5vbmUsIHRoZSBjdXJyZW50IGRhdGUgaXMgdXNlZAogICAgIyBFeGFtcGxlOiBEYXRlUmFuZ2Uoc3RhcnRfZGF0ZT1EYXRlKCIyMDIyLTAxLTAxIiksIGVuZF9kYXRlPURhdGUoIjIwMjItMDEtMzEiKSkKCkBkYXRhY2xhc3MKY2xhc3MgSVNPQ29kZToKICAgICIiIlJlcHJlc2VudHMgYW4gSVNPIGFscGhhLTMgY291bnRyeSBjb2RlLiIiIgogICAgY29kZTogc3RyICMgMy1sZXR0ZXIgSVNPIGNvZGUKICAgICMgRXhhbXBsZTogSVNPQ29kZSgiVVNBIikKCkBkYXRhY2xhc3MKY2xhc3MgQ291bnRyeToKICAgICIiIlJlcHJlc2VudHMgYSBjb3VudHJ5IGVudGl0eS4iIiIKICAgIGlzb19jb2RlOiBJU09Db2RlCiAgICBuYW1lOiBzdHIKICAgICMgRXhhbXBsZTogQ291bnRyeShpc29fY29kZT1JU09Db2RlKCJVU0EiKSwgbmFtZT0iVW5pdGVkIFN0YXRlcyIpCgpAZGF0YWNsYXNzCmNsYXNzIENBTUVPQ29kZToKICAgICIiIlJlcHJlc2VudHMgYSBDQU1FTyB2ZXJiIGNvZGUuIiIiCiAgICBjb2RlOiBzdHIgIyAyLWRpZ2l0IENBTUVPIGNvZGUgZm9yIGZpcnN0IGxldmVsIHJlbGF0aW9ucywgMy1kaWdpdCBDQU1FTyBjb2RlIGZvciBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zCiAgICAjIEV4YW1wbGU6IENBTUVPQ29kZSgiMDEiKSwgQ0FNRU9Db2RlKCIwMTAiKQoKQGRhdGFjbGFzcwpjbGFzcyBSZWxhdGlvbjoKICAgICIiIlJlcHJlc2VudHMgYSByZWxhdGlvbi4iIiIKICAgIGNhbWVvX2NvZGU6IENBTUVPQ29kZQogICAgbmFtZTogc3RyCiAgICBkZXNjcmlwdGlvbjogc3RyICMgQSBicmllZiBkZXNjcmlwdGlvbiBvZiB3aGF0IGV2ZW50IHRoZSByZWxhdGlvbiByZXByZXNlbnRzCiAgICAjIEV4YW1wbGU6IFJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIwMTAiKSwgbmFtZT0iTWFrZSBzdGF0ZW1lbnQsIG5vdCBzcGVjaWZpZWQiLCBkZXNjcmlwdGlvbj0iQWxsIHB1YmxpYyBzdGF0ZW1lbnRzIGV4cHJlc3NlZCB2ZXJiYWxseSBvciBpbiBhY3Rpb24sIG5vdCBvdGhlcndpc2Ugc3BlY2lmaWVkLiIKCkBkYXRhY2xhc3MKY2xhc3MgRXZlbnQ6CiAgICAiIiJSZXByZXNlbnRzIGFuIGV2ZW50IGNoYXJhY3Rlcml6ZWQgYnkgZGF0ZSwgaGVhZCBlbnRpdHksIHJlbGF0aW9uLCBhbmQgdGFpbCBlbnRpdHkuIiIiCiAgICBkYXRlOiBEYXRlCiAgICBoZWFkX2VudGl0eTogSVNPQ29kZQogICAgcmVsYXRpb246IENBTUVPQ29kZQogICAgdGFpbF9lbnRpdHk6IElTT0NvZGUKICAgICMgRXhhbXBsZTogRXZlbnQoZGF0ZT1EYXRlKCIyMDIyLTAxLTAxIiksIGhlYWRfZW50aXR5PUlTT0NvZGUoIlVTQSIpLCByZWxhdGlvbj1DQU1FT0NvZGUoIjAxMCIpLCB0YWlsX2VudGl0eT1JU09Db2RlKCJDQU4iKSkKCkBkYXRhY2xhc3MKY2xhc3MgTmV3c0FydGljbGU6CiAgICAiIiJSZXByZXNlbnRzIGEgbmV3cyBhcnRpY2xlLCBpbmNsdWRpbmcgbWV0YWRhdGEgYW5kIGNvbnRlbnQuIiIiCiAgICBkYXRlOiBEYXRlCiAgICB0aXRsZTogc3RyCiAgICBjb250ZW50OiBzdHIgIyBGdWxsIHRleHQgY29udGVudCBvZiB0aGUgbmV3cyBhcnRpY2xlCiAgICBldmVudHM6IExpc3RbRXZlbnRdICMgTGlzdCBvZiBldmVudHMgbWVudGlvbmVkIGluIHRoZSBhcnRpY2xlCiAgICAjIEV4YW1wbGU6IE5ld3NBcnRpY2xlKGRhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCB0aXRsZT0iVHJhZGUgYWdyZWVtZW50IGJldHdlZW4gVVNBIGFuZCBDaGluYSIsIGNvbnRlbnQ9Ik9uIEphbnVhcnkgMSwgMjAyMiwgYSB0cmFkZSBhZ3JlZW1lbnQgd2FzIHNpZ25lZCBiZXR3ZWVuIHRoZSBVU0EgYW5kIENoaW5hLi4uIiwgZXZlbnRzPVtFdmVudChkYXRlPURhdGUoIjIwMjItMDEtMDEiKSwgaGVhZF9lbnRpdHk9SVNPQ29kZSgiVVNBIiksIHJlbGF0aW9uPUNBTUVPQ29kZSgiMDEwIiksIHRhaWxfZW50aXR5PUlTT0NvZGUoIkNITiIpXSkKCiAgICBkZWYgX19zdHJfXyhzZWxmKToKICAgICAgICByZXR1cm4gZiJ7c2VsZi5kYXRlfTpcbntzZWxmLnRpdGxlfVxue3NlbGYuY29udGVudH0iCgpkZWYgbWFwX2NvdW50cnlfbmFtZV90b19pc28obmFtZTogc3RyKSAtPiBMaXN0W0NvdW50cnldOgogICAgIiIiCiAgICBNYXBzIGEgY291bnRyeSBuYW1lIHRvIHRoZSBtb3N0IGxpa2VseSBjb3JyZXNwb25kaW5nIENvdW50cnkgb2JqZWN0cyB3aXRoIElTTyBjb2Rlcy4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIG5hbWUgKHN0cik6IFRoZSBjb3VudHJ5IG5hbWUgdG8gbWFwLgoKICAgIFJldHVybnM6CiAgICAgICAgTGlzdFtDb3VudHJ5XTogQSBsaXN0IG9mIDUgbW9zdCBsaWtlbHkgQ291bnRyeSBvYmplY3RzIHNvcnRlZCBieSByZWxldmFuY2UuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gbWFwX2NvdW50cnlfbmFtZV90b19pc28oIktvcmVhIikKICAgICAgICBbQ291bnRyeShpc29fY29kZT1JU09Db2RlKCJLT1IiKSwgbmFtZT0iUmVwdWJsaWMgb2YgS29yZWEiKSwgQ291bnRyeShpc29fY29kZT1JU09Db2RlKCJQUksiKSwgbmFtZT0iRGVtb2NyYXRpYyBQZW9wbGUncyBSZXB1YmxpYyBvZiBLb3JlYSIpXQogICAgIiIiCiAgICBwYXNzCgpkZWYgbWFwX2lzb190b19jb3VudHJ5X25hbWUoaXNvX2NvZGU6IElTT0NvZGUpIC0+IHN0cjoKICAgICIiIgogICAgTWFwcyBhbiBJU08gY29kZSB0byBhIGNvdW50cnkgbmFtZS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGlzb19jb2RlIChJU09Db2RlKTogVGhlIElTTyBjb2RlIHRvIG1hcC4KCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogVGhlIGNvcnJlc3BvbmRpbmcgY291bnRyeSBuYW1lLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IG1hcF9pc29fdG9fY291bnRyeV9uYW1lKElTT0NvZGUoIkNITiIpKQogICAgICAgICJDaGluYSIKICAgICIiIgogICAgcGFzcwoKZGVmIG1hcF9yZWxhdGlvbl9kZXNjcmlwdGlvbl90b19jYW1lbyhkZXNjcmlwdGlvbjogc3RyKSAtPiBMaXN0W1JlbGF0aW9uXToKICAgICIiIgogICAgTWFwcyBhIHJlbGF0aW9uIGRlc2NyaXB0aW9uIHRvIHRoZSBtb3N0IGxpa2VseSBSZWxhdGlvbiBvYmplY3RzLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgZGVzY3JpcHRpb24gKHN0cik6IFRoZSByZWxhdGlvbiBkZXNjcmlwdGlvbiB0byBtYXAuCgogICAgUmV0dXJuczoKICAgICAgICBMaXN0W1JlbGF0aW9uXTogQSBsaXN0IG9mIDUgbW9zdCBsaWtlbHkgUmVsYXRpb25zIHNvcnRlZCBieSByZWxldmFuY2UuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gbWFwX3JlbGF0aW9uX2Rlc2NyaXB0aW9uX3RvX2NhbWVvKCJGaWdodCB3aXRoIGd1bnMiKQogICAgICAgIFtSZWx0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIxOSIpLCBuYW1lPSJGaWdodCIsIGRlc2NyaXB0aW9uPSJBbGwgdXNlcyBvZiBjb252ZW50aW9uYWwgZm9yY2UgYW5kIGFjdHMgb2Ygd2FyIHR5cGljYWxseSBieSBvcmdhbml6ZWQgYXJtZWQgZ3JvdXBzLiIpLCBSZWxhdGlvbihjYW1lb19jb2RlPUNBTUVPQ29kZSgiMTkzIiksIG5hbWU9IkZpZ2h0IHdpdGggc21hbGwgYXJtcyBhbmQgbGlnaHQgd2VhcG9ucyIsIGRlc2NyaXB0aW9uPSJBdHRhY2sgdXNpbmcgc21hbGwgYXJtcyBhbmQgbGlnaHQgd2VhcG9ucyBzdWNoIGFzIHJpZmxlcywgbWFjaGluZS1ndW5zLCBhbmQgbW9ydGFyIHNoZWxscy4iKSwgUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoIjE5MCIpLCBuYW1lPSJVc2UgY29udmVudGlvbmFsIG1pbGl0YXJ5IGZvcmNlLCBub3Qgc3BlY2lmaWVkIiwgZGVzY3JpcHRpb249IkFsbCB1c2VzIG9mIGNvbnZlbnRpb25hbCBmb3JjZSBhbmQgYWN0cyBvZiB3YXIgdHlwaWNhbGx5IGJ5IG9yZ2FuaXplZCBhcm1lZCBncm91cHMsIG5vdCBvdGhlcndpc2Ugc3BlY2lmaWVkLiIpXQogICAgIiIiCiAgICBwYXNzCgpkZWYgbWFwX2NhbWVvX3RvX3JlbGF0aW9uKGNhbWVvX2NvZGU6IENBTUVPQ29kZSkgLT4gUmVsYXRpb246CiAgICAiIiIKICAgIE1hcHMgYSBDQU1FTyBjb2RlIHRvIGEgcmVsYXRpb24sIGluY2x1ZGluZyBpdHMgbmFtZSBhbmQgZGVzY3JpcHRpb24uCgogICAgUGFyYW1ldGVyczoKICAgICAgICBjYW1lb19jb2RlIChDQU1FT0NvZGUpOiBUaGUgQ0FNRU8gY29kZSB0byBtYXAuCgogICAgUmV0dXJuczoKICAgICAgICBSZWxhdGlvbjogVGhlIGNvcnJlc3BvbmRpbmcgcmVsYXRpb24uCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gbWFwX2NhbWVvX3RvX3JlbGF0aW9uKENBTUVPQ29kZSgiMTkwIikpCiAgICAgICAgUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoIjE5MCIpLCBuYW1lPSJVc2UgY29udmVudGlvbmFsIG1pbGl0YXJ5IGZvcmNlLCBub3Qgc3BlY2lmaWVkIiwgZGVzY3JpcHRpb249IkFsbCB1c2VzIG9mIGNvbnZlbnRpb25hbCBmb3JjZSBhbmQgYWN0cyBvZiB3YXIgdHlwaWNhbGx5IGJ5IG9yZ2FuaXplZCBhcm1lZCBncm91cHMsIG5vdCBvdGhlcndpc2Ugc3BlY2lmaWVkLiIpCiAgICAiIiIKICAgIHBhc3MKCmRlZiBnZXRfY2hpbGRfcmVsYXRpb25zKGNhbWVvX2NvZGU6IENBTUVPQ29kZSkgLT4gTGlzdFtSZWxhdGlvbl06CiAgICAiIiIKICAgIFJldHJpZXZlcyBjaGlsZCByZWxhdGlvbnMgb2YgYSBnaXZlbiByZWxhdGlvbiBpZGVudGlmaWVkIGJ5IENBTUVPIGNvZGUuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBjYW1lb19jb2RlIChDQU1FT0NvZGUpOiBUaGUgQ0FNRU8gY29kZSBvZiB0aGUgcmVsYXRpb24gd2hvc2UgY2hpbGRyZW4gYXJlIHNvdWdodC4gT25seSBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGFjY2VwdGVkLgoKICAgIFJldHVybnM6CiAgICAgICAgTGlzdFtSZWxhdGlvbl06IEEgbGlzdCBvZiBzZWNvbmQgbGV2ZWwgY2hpbGQgcmVsYXRpb25zLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9jaGlsZF9yZWxhdGlvbnMoQ0FNRU9Db2RlKCIxOSIpKQogICAgICAgIFtSZWxhdGlvbihjYWVtb19jb2RlPUNBTUVPQ29kZSgiMTkwIiksIG5hbWU9IlVzZSBjb252ZW50aW9uYWwgbWlsaXRhcnkgZm9yY2UsIG5vdCBzcGVjaWZpZWQiLCBkZXNjcmlwdGlvbj0iQWxsIHVzZXMgb2YgY29udmVudGlvbmFsIGZvcmNlIGFuZCBhY3RzIG9mIHdhciB0eXBpY2FsbHkgYnkgb3JnYW5pemVkIGFybWVkIGdyb3Vwcywgbm90IG90aGVyd2lzZSBzcGVjaWZpZWQuIiksIFJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIxOTEiKSwgbmFtZT0iSW1wb3NlIGJsb2NrYWRlIG9yIHJlc3RyaWN0IG1vdmVtZW50IiwgZGVzY3JpcHRpb249IlByZXZlbnQgZW50cnkgaW50byBhbmQvb3IgZXhpdCBmcm9tIGEgdGVycml0b3J5IHVzaW5nIGFybWVkIGZvcmNlcy4iKSwgLi4uXQogICAgIiIiCiAgICBwYXNzCgpkZWYgZ2V0X3NpYmxpbmdfcmVsYXRpb25zKGNhbWVvX2NvZGU6IENBTUVPQ29kZSkgLT4gTGlzdFtSZWxhdGlvbl06CiAgICAiIiIKICAgIFJldHJpZXZlcyBzaWJsaW5nIHJlbGF0aW9ucyBvZiBhIGdpdmVuIHJlbGF0aW9uIGlkZW50aWZpZWQgYnkgQ0FNRU8gY29kZS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGNhbWVvX2NvZGUgKENBTUVPQ29kZSk6IFRoZSBDQU1FTyBjb2RlIG9mIHRoZSByZWxhdGlvbiB3aG9zZSBzaWJsaW5ncyBhcmUgc291Z2h0LiBCb3RoIGZpcnN0IGFuZCBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zIGFyZSBhY2NlcHRlZC4KCiAgICBSZXR1cm5zOgogICAgICAgIExpc3RbUmVsYXRpb25dOiBBIGxpc3Qgb2Ygc2libGluZyByZWxhdGlvbnMgYXQgdGhlIHNhbWUgbGV2ZWwuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gZ2V0X3NpYmxpbmdfcmVsYXRpb25zKENBTUVPQ29kZSgiMTkzIikpCiAgICAgICAgW1JlbGF0aW9uKGNhZW1vX2NvZGU9Q0FNRU9Db2RlKCIxOTAiKSwgbmFtZT0iVXNlIGNvbnZlbnRpb25hbCBtaWxpdGFyeSBmb3JjZSwgbm90IHNwZWNpZmllZCIsIGRlc2NyaXB0aW9uPSJBbGwgdXNlcyBvZiBjb252ZW50aW9uYWwgZm9yY2UgYW5kIGFjdHMgb2Ygd2FyIHR5cGljYWxseSBieSBvcmdhbml6ZWQgYXJtZWQgZ3JvdXBzLCBub3Qgb3RoZXJ3aXNlIHNwZWNpZmllZC4iKSwgUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoIjE5MSIpLCBuYW1lPSJJbXBvc2UgYmxvY2thZGUgb3IgcmVzdHJpY3QgbW92ZW1lbnQiLCBkZXNjcmlwdGlvbj0iUHJldmVudCBlbnRyeSBpbnRvIGFuZC9vciBleGl0IGZyb20gYSB0ZXJyaXRvcnkgdXNpbmcgYXJtZWQgZm9yY2VzLiIpLCAuLi5dCiAgICAiIiIKICAgIHBhc3MKCmRlZiBjb3VudF9ldmVudHMoZGF0ZV9yYW5nZTogT3B0aW9uYWxbRGF0ZVJhbmdlXSA9IE5vbmUsIGhlYWRfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgdGFpbF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lLCByZWxhdGlvbnM6IE9wdGlvbmFsW0xpc3RbQ0FNRU9Db2RlXV0gPSBOb25lKSAtPiBpbnQ6CiAgICAiIiIKICAgIENvdW50cyB0aGUgbnVtYmVyIG9mIGV2ZW50cyBpbiB0aGUga25vd2xlZGdlIGdyYXBoIGJhc2VkIG9uIHNwZWNpZmllZCBjb25kaXRpb25zLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgZGF0ZV9yYW5nZSAoT3B0aW9uYWxbRGF0ZVJhbmdlXSk6IFJhbmdlIG9mIGRhdGVzIHRvIGZpbHRlciB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGhlYWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiBoZWFkIGVudGl0eSBJU08gY29kZXMgdG8gYmUgaW5jbHVkZWQuIElmIE5vbmUsIGFsbCBjb3VudHJpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHRhaWxfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiB0YWlsIGVudGl0eSBJU08gY29kZXMgdG8gYmUgaW5jbHVkZWQuIElmIE5vbmUsIGFsbCBjb3VudHJpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHJlbGF0aW9ucyAoT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSk6IExpc3Qgb2YgcmVsYXRpb24gQ0FNRU8gY29kZXMgdG8gYmUgaW5jbHVkZWQuIElmIGZpcnN0IGxldmVsIHJlbGF0aW9ucyBhcmUgbGlzdGVkLCBhbGwgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyB1bmRlciB0aGVtIGFyZSBpbmNsdWRlZC4gSWYgTm9uZSwgYWxsIHJlbGF0aW9ucyBhcmUgaW5jbHVkZWQuCgogICAgUmV0dXJuczoKICAgICAgICBpbnQ6IENvdW50IG9mIHVuaXF1ZSBldmVudHMgbWF0Y2hpbmcgdGhlIGNvbmRpdGlvbnMuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gY291bnRfZXZlbnRzKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBoZWFkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCB0YWlsX2VudGl0aWVzPU5vbmUsIHJlbGF0aW9ucz1bQ0FNRU9Db2RlKCIwMTAiKV0pCiAgICAgICAgNAogICAgIiIiCiAgICBwYXNzCgpkZWYgZ2V0X2V2ZW50cyhkYXRlX3JhbmdlOiBPcHRpb25hbFtEYXRlUmFuZ2VdID0gTm9uZSwgaGVhZF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lLCB0YWlsX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUsIHJlbGF0aW9uczogT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSA9IE5vbmUsIHRleHRfZGVzY3JpcHRpb246IE9wdGlvbmFsW3N0cl0gPSBOb25lKSAtPiBMaXN0W0V2ZW50XToKICAgICIiIgogICAgUmV0cmlldmVzIGV2ZW50cyBmcm9tIHRoZSBrbm93bGVkZ2UgZ3JhcGggYmFzZWQgb24gc3BlY2lmaWVkIGNvbmRpdGlvbnMuCiAgICBJbmhlcml0cyBjb21tb24gZmlsdGVyIHBhcmFtZXRlcnMgZnJvbSBjb3VudF9ldmVudHMuIFNlZSBjb3VudF9ldmVudHMgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGVzZSBwYXJhbWV0ZXJzLgoKICAgIEFkZGl0aW9uYWwgUGFyYW1ldGVyczoKICAgICAgICB0ZXh0X2Rlc2NyaXB0aW9uIChPcHRpb25hbFtzdHJdKTogVGV4dHVhbCBkZXNjcmlwdGlvbiB0byBtYXRjaCB3aXRoIHRoZSBzb3VyY2UgbmV3cyBhcnRpY2xlcyBvZiBldmVudHMuIElmIE5vbmUsIHRoZSByZXR1cm5lZCBldmVudHMgYXJlIHNvcnRlZCBieSBkYXRlIGluIGRlc2NlbmRpbmcgb3JkZXI7IG90aGVyd2lzZSwgc29ydGVkIGJ5IHJlbGV2YW5jZSBvZiB0aGUgc291cmNlIG5ld3MgYXJ0aWNsZSB0byB0aGUgZGVzY3JpcHRpb24uCgogICAgUmV0dXJuczoKICAgICAgICBMaXN0W0V2ZW50XTogQSBsaXN0IG9mIG1heGltdW0gMzAgZXZlbnRzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucy4KCiAgICBFeGFtcGxlOgogICAgICAgID4+PiBnZXRfZXZlbnRzKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBoZWFkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCB0YWlsX2VudGl0aWVzPU5vbmUsIHJlbGF0aW9ucz1bQ0FNRU9Db2RlKCIwMTAiKV0sIHRleHRfZGVzY3JpcHRpb249ImVjb25vbWljIHRyYWRlIikKICAgICAgICBbRXZlbnQoZGF0ZT1EYXRlKCIyMDIyLTAxLTE1IiksIGhlYWRfZW50aXR5PUlTT0NvZGUoIlVTQSIpLCByZWxhdGlvbj1DQU1FT0NvZGUoIjAxMCIpLCB0YWlsX2VudGl0eT1JU09Db2RlKCJDQU4iKSwgRXZlbnQoZGF0ZT1EYXRlKCIyMDIyLTAxLTEwIiksIGhlYWRfZW50aXR5PUlTT0NvZGUoIkNITiIpLCByZWxhdGlvbj1DQU1FT0NvZGUoIjAxMCIpLCB0YWlsX2VudGl0eT1JU09Db2RlKCJVU0EiKSwgLi4uXQogICAgIiIiCiAgICBwYXNzCgpkZWYgZ2V0X2VudGl0eV9kaXN0cmlidXRpb24oZGF0ZV9yYW5nZTogT3B0aW9uYWxbRGF0ZVJhbmdlXSA9IE5vbmUsIGludm9sdmVkX3JlbGF0aW9uczogT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSA9IE5vbmUsIGludGVyYWN0ZWRfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgZW50aXR5X3JvbGU6IE9wdGlvbmFsW3N0cl0gPSBOb25lKSAtPiBEaWN0W0lTT0NvZGUsIGludF06CiAgICAiIiIKICAgIEdldHMgdGhlIGRpc3RyaWJ1dGlvbiBvZiBlbnRpdGllcyBpbiB0aGUga25vd2xlZGdlIGdyYXBoIHVuZGVyIHNwZWNpZmllZCBjb25kaXRpb25zLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgZGF0ZV9yYW5nZSAoT3B0aW9uYWxbRGF0ZVJhbmdlXSk6IFJhbmdlIG9mIGRhdGVzIHRvIGZpbHRlciB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGludm9sdmVkX3JlbGF0aW9ucyAoT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSk6IExpc3Qgb2YgcmVsYXRpb25zIHRoYXQgdGhlIHJldHVybmVkIGVudGl0aWVzIG11c3QgYmUgaW52b2x2ZWQgaW4gYW55IG9mLiBJZiBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGxpc3RlZCwgYWxsIHNlY29uZCBsZXZlbCByZWxhdGlvbnMgdW5kZXIgdGhlbSBhcmUgaW5jbHVkZWQuIElmIE5vbmUsIGFsbCByZWxhdGlvbnMgYXJlIGluY2x1ZGVkLgogICAgICAgIGludGVyYWN0ZWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiBlbnRpdGllcyB0aGF0IHRoZSByZXR1cm5lZCBlbnRpdGllcyBtdXN0IGhhdmUgaW50ZXJhY3RlZCB3aXRoIGFueSBvZi4gSWYgTm9uZSwgYWxsIGVudGl0aWVzIGFyZSBpbmNsdWRlZC4KICAgICAgICBlbnRpdHlfcm9sZSAoT3B0aW9uYWxbRW50aXR5Um9sZV0pOiBTcGVjaWZpZXMgdGhlIHJvbGUgb2YgdGhlIHJldHVybmVkIGVudGl0eSBpbiB0aGUgZXZlbnRzLiBPcHRpb25zIGFyZSAnaGVhZCcsICd0YWlsJywgb3IgJ2JvdGgnLiBJZiAnYm90aCcgb3IgTm9uZSwgdGhlIHJldHVybmVkIGVudGl0eSBjYW4gYmUgZWl0aGVyIGhlYWQgb3IgdGFpbC4KCiAgICBSZXR1cm5zOgogICAgICAgIERpY3RbSVNPQ29kZSwgaW50XTogQSBkaWN0aW9uYXJ5IG1hcHBpbmcgcmV0dXJuZWQgZW50aXRpZXMnIElTTyBjb2RlcyB0byB0aGUgbnVtYmVyIG9mIGV2ZW50cyB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucyBpbiB3aGljaCB0aGV5IGFyZSBpbnZvbHZlZCwgc29ydGVkIGJ5IGNvdW50cyBpbiBkZXNjZW5kaW5nIG9yZGVyLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9lbnRpdHlfZGlzdHJpYnV0aW9uKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBpbnZvbHZlZF9yZWxhdGlvbnM9W0NBTUVPQ29kZSgiMDEwIildLCBpbnRlcmFjdGVkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCBlbnRpdHlfcm9sZT0idGFpbCIpCiAgICAgICAge0lTT0NvZGUoIlVTQSIpOiAzLCBJU09Db2RlKCJDSE4iKTogMX0KICAgICIiIgogICAgcGFzcwoKZGVmIGdldF9yZWxhdGlvbl9kaXN0cmlidXRpb24oZGF0ZV9yYW5nZTogT3B0aW9uYWxbRGF0ZVJhbmdlXSA9IE5vbmUsIGhlYWRfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgdGFpbF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lKSAtPiBEaWN0W0NBTUVPQ29kZSwgaW50XToKICAgICIiIgogICAgR2V0cyB0aGUgZGlzdHJpYnV0aW9uIG9mIHNlY29uZCBsZXZlbCByZWxhdGlvbnMgaW4gdGhlIGtub3dsZWRnZSBncmFwaCB1bmRlciBzcGVjaWZpZWQgY29uZGl0aW9ucy4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGRhdGVfcmFuZ2UgKE9wdGlvbmFsW0RhdGVSYW5nZV0pOiBSYW5nZSBvZiBkYXRlcyB0byBmaWx0ZXIgdGhlIGV2ZW50cy4gSWYgTm9uZSwgYWxsIGRhdGVzIGFyZSBpbmNsdWRlZC4KICAgICAgICBoZWFkX2VudGl0aWVzIChPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSk6IExpc3Qgb2YgaGVhZCBlbnRpdGllcyB0aGF0IHRoZSBldmVudHMgbXVzdCBpbnZvbHZlIGFueSBvZi4gSWYgTm9uZSwgYWxsIGhlYWQgZW50aXRpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHRhaWxfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiB0YWlsIGVudGl0aWVzIHRoYXQgdGhlIGV2ZW50cyBtdXN0IGludm9sdmUgYW55IG9mLiBJZiBOb25lLCBhbGwgdGFpbCBlbnRpdGllcyBhcmUgaW5jbHVkZWQuCgogICAgUmV0dXJuczoKICAgICAgICBEaWN0W0NBTUVPQ29kZSwgaW50XTogQSBkaWN0aW9uYXJ5IG1hcHBpbmcgc2Vjb25kIGxldmVsIHJlbGF0aW9ucycgQ0FNRU8gY29kZXMgdG8gdGhlIG51bWJlciBvZiBldmVudHMgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbnMgaW4gd2hpY2ggdGhleSBhcmUgaW52b2x2ZWQsIHNvcnRlZCBieSBjb3VudHMgaW4gZGVzY2VuZGluZyBvcmRlci4KCiAgICBFeGFtcGxlOgogICAgICAgID4+PiBnZXRfcmVsYXRpb25fZGlzdHJpYnV0aW9uKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBoZWFkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCB0YWlsX2VudGl0aWVzPU5vbmUpCiAgICAgICAge0NBTUVPQ29kZSgiMDEwIik6IDMsIENBTUVPQ29kZSgiMDExIik6IDF9CiAgICAiIiIKICAgIHBhc3MKCmRlZiBjb3VudF9uZXdzX2FydGljbGVzKGRhdGVfcmFuZ2U6IE9wdGlvbmFsW0RhdGVSYW5nZV0gPSBOb25lLCBoZWFkX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUsIHRhaWxfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgcmVsYXRpb25zOiBPcHRpb25hbFtMaXN0W0NBTUVPQ29kZV1dID0gTm9uZSwga2V5d29yZHM6IE9wdGlvbmFsW0xpc3Rbc3RyXV0gPSBOb25lKSAtPiBpbnQ6CiAgICAiIiIKICAgIENvdW50cyB0aGUgbnVtYmVyIG9mIG5ld3MgYXJ0aWNsZXMgYmFzZWQgb24gc3BlY2lmaWVkIGNvbmRpdGlvbnMuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBkYXRlX3JhbmdlIChPcHRpb25hbFtEYXRlUmFuZ2VdKTogUmFuZ2Ugb2YgZGF0ZXMgdG8gZmlsdGVyIHRoZSBuZXdzIGFydGljbGVzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGhlYWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogQXQgbGVhc3Qgb25lIG9mIHRoZSBlbnRpdGllcyBtdXN0IGJlIG1lbnRpb25lZCBpbiB0aGUgYXJ0aWNsZXMgYW5kIGJlIHRoZSBoZWFkIGVudGl0eSBpbiB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZW50aXRpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHRhaWxfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogQXQgbGVhc3Qgb25lIG9mIHRoZSBlbnRpdGllcyBtdXN0IGJlIG1lbnRpb25lZCBpbiB0aGUgYXJ0aWNsZXMgYW5kIGJlIHRoZSB0YWlsIGVudGl0eSBpbiB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZW50aXRpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHJlbGF0aW9ucyAoT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSk6IEF0IGxlYXN0IG9uZSBvZiB0aGUgcmVsYXRpb25zIG11c3QgYmUgbWVudGlvbmVkIGluIHRoZSBhcnRpY2xlcy4gSWYgZmlyc3QgbGV2ZWwgcmVsYXRpb25zIGFyZSBsaXN0ZWQsIGFsbCBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zIHVuZGVyIHRoZW0gYXJlIGluY2x1ZGVkLiBJZiBOb25lLCBhbGwgcmVsYXRpb25zIGFyZSBpbmNsdWRlZC4KICAgICAgICBrZXl3b3JkcyAoT3B0aW9uYWxbTGlzdFtzdHJdXSk6IEF0IGxlYXN0IG9uZSBvZiB0aGUga2V5d29yZHMgbXVzdCBiZSBwcmVzZW50IGluIHRoZSBhcnRpY2xlcy4gSWYgTm9uZSwgYWxsIGFydGljbGVzIGFyZSBpbmNsdWRlZC4KCiAgICBSZXR1cm5zOgogICAgICAgIGludDogVGhlIGNvdW50IG9mIG5ld3MgYXJ0aWNsZXMgbWF0Y2hpbmcgdGhlIGNvbmRpdGlvbnMuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gY291bnRfbmV3c19hcnRpY2xlcyhkYXRlX3JhbmdlPURhdGVSYW5nZShzdGFydF9kYXRlPURhdGUoIjIwMjItMDEtMDEiKSwgZW5kX2RhdGU9RGF0ZSgiMjAyMi0wMS0zMSIpKSwgaGVhZF9lbnRpdGllcz1bSVNPQ29kZSgiVVNBIiksIElTT0NvZGUoIkNITiIpXSwgdGFpbF9lbnRpdGllcz1bSVNPQ29kZSgiVVNBIiksIElTT0NvZGUoIkNITiIpXSwgcmVsYXRpb25zPVtDQU1FT0NvZGUoIjAxMCIpXSwga2V5d29yZHM9WyJ0cmFkZSJdKQogICAgICAgIDIKICAgICIiIgogICAgcGFzcwoKZGVmIGdldF9uZXdzX2FydGljbGVzKGRhdGVfcmFuZ2U6IE9wdGlvbmFsW0RhdGVSYW5nZV0gPSBOb25lLCBoZWFkX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUsIHRhaWxfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgcmVsYXRpb25zOiBPcHRpb25hbFtMaXN0W0NBTUVPQ29kZV1dID0gTm9uZSwga2V5d29yZHM6IE9wdGlvbmFsW0xpc3Rbc3RyXV0gPSBOb25lLCB0ZXh0X2Rlc2NyaXB0aW9uOiBPcHRpb25hbFtzdHJdID0gTm9uZSkgLT4gTGlzdFtUdXBsZVtEYXRlLCBzdHJdXToKICAgICIiIgogICAgUmV0cmlldmVzIG5ld3MgYXJ0aWNsZXMgYmFzZWQgb24gc3BlY2lmaWVkIGNvbmRpdGlvbnMuCiAgICBJbmhlcml0cyBjb21tb24gZmlsdGVyIHBhcmFtZXRlcnMgZnJvbSBjb3VudF9uZXdzX2FydGljbGVzLiBTZWUgY291bnRfbmV3c19hcnRpY2xlcyBmb3IgbW9yZSBkZXRhaWxzIG9uIHRoZXNlIHBhcmFtZXRlcnMuCgogICAgQWRkaXRpb25hbCBQYXJhbWV0ZXJzOgogICAgICAgIHRleHRfZGVzY3JpcHRpb24gKE9wdGlvbmFsW3N0cl0pOiBUZXh0dWFsIGRlc2NyaXB0aW9uIHRvIG1hdGNoIHdpdGggdGhlIG5ld3MgYXJ0aWNsZXMuIElmIE5vbmUsIHRoZSByZXR1cm5lZCBhcnRpY2xlcyBhcmUgc29ydGVkIGJ5IGRhdGUgaW4gZGVzY2VuZGluZyBvcmRlcjsgb3RoZXJ3aXNlLCBzb3J0ZWQgYnkgcmVsZXZhbmNlIHRvIHRoZSBkZXNjcmlwdGlvbi4KCiAgICBSZXR1cm5zOgogICAgICAgIExpc3RbVHVwbGVbRGF0ZSwgc3RyXV06IEEgbGlzdCBvZiBtYXhpbXVtIDE1IG5ld3MgYXJ0aWNsZXMgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBjb25kaXRpb25zLCBlYWNoIHJlcHJlc2VudGVkIGJ5IGEgdHVwbGUgb2YgZGF0ZSBhbmQgdGl0bGUuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gZ2V0X25ld3NfYXJ0aWNsZXMoZGF0ZV9yYW5nZT1EYXRlUmFuZ2Uoc3RhcnRfZGF0ZT1EYXRlKCIyMDIyLTAxLTAxIiksIGVuZF9kYXRlPURhdGUoIjIwMjItMDEtMzEiKSksIGhlYWRfZW50aXRpZXM9W0lTT0NvZGUoIlVTQSIpLCBJU09Db2RlKCJDSE4iKV0sIHRhaWxfZW50aXRpZXM9W0lTT0NvZGUoIlVTQSIpLCBJU09Db2RlKCJDSE4iKV0sIHJlbGF0aW9ucz1bQ0FNRU9Db2RlKCIwMTAiKV0sIGtleXdvcmRzPVsidHJhZGUiXSwgdGV4dF9kZXNjcmlwdGlvbj0iRWNvbm9taWMgdHJhZGUgaXMgZW5jb3VyYWdlZCBiZXR3ZWVuIFVTQSBhbmQgQ2hpbmEuIikKICAgICAgICBbKE5ld3NBcnRpY2xlLmRhdGU9RGF0ZSgiMjAyMi0wMS0xNSIpLCBOZXdzQXJ0aWNsZS50aXRsZT0iQ2hpbmEgYW5kIFVTQSBzaWduIHRyYWRlIGRlYWwiKSwgKE5ld3NBcnRpY2xlLmRhdGU9RGF0ZSgiMjAyMi0wMS0xMCIpLCBOZXdzQXJ0aWNsZS50aXRsZT0iVHJhZGUgYWdyZWVtZW50IGJldHdlZW4gVVNBIGFuZCBDaGluYSIpXQogICAgIiIiCiAgICBwYXNzCgpkZWYgYnJvd3NlX25ld3NfYXJ0aWNsZShkYXRlOiBEYXRlLCB0aXRsZTogc3RyKSAtPiBzdHI6CiAgICAiIiIKICAgIFJldHJpZXZlcyB0aGUgZnVsbCB0ZXh0IG9mIGEgbmV3cyBhcnRpY2xlIGJ5IGl0cyB0aXRsZS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGRhdGUgKERhdGUpOiBUaGUgZGF0ZSBvZiB0aGUgbmV3cyBhcnRpY2xlIHRvIHJldHJpZXZlLgogICAgICAgIHRpdGxlIChzdHIpOiBUaGUgdGl0bGUgb2YgdGhlIG5ld3MgYXJ0aWNsZSB0byByZXRyaWV2ZS4KCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogVGhlIGRhdGUsIHRoZSB0aXRsZSBhbmQgZnVsbCBjb250ZW50cyBvZiB0aGUgbmV3cyBhcnRpY2xlLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGJyb3dzZV9uZXdzX2FydGljbGUoRGF0ZSgiMjAyMi0wMS0xMCIpLCAiVHJhZGUgYWdyZWVtZW50IGJldHdlZW4gVVNBIGFuZCBDaGluYSIpCiAgICAgICAgMjAyMi0wMS0xMDoKICAgICAgICBUcmFkZSBhZ3JlZW1lbnQgYmV0d2VlbiBVU0EgYW5kIENoaW5hCiAgICAgICAgT24gSmFudWFyeSAxMCwgMjAyMiwgYSB0cmFkZSBhZ3JlZW1lbnQgd2FzIHNpZ25lZCBiZXR3ZWVuIHRoZSBVU0EgYW5kIENoaW5hIHRvIHByb21vdGUgZWNvbm9taWMgY29vcGVyYXRpb24uLi4KICAgICIiIgogICAgcGFzcw==)1@dataclass2class  Date:3  """Represents  a  date."""4  date:  str  #  Date  in  the  format  ’YYYY-MM-DD’5  #  Example:  Date("2022-01-01")67@dataclass8class  DateRange:9  """Represents  a  range  of  dates  (inclusive)."""10  start_date:  Optional[Date]  #  If  None,  the  earliest  date  is  used11  end_date:  Optional[Date]  #  If  None,  the  current  date  is  used12  #  Example:  DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31"))1314@dataclass15class  ISOCode:16  """Represents  an  ISO  alpha-3  country  code."""17  code:  str  #  3-letter  ISO  code18  #  Example:  ISOCode("USA")1920@dataclass21class  Country:22  """Represents  a  country  entity."""23  iso_code:  ISOCode24  name:  str25  #  Example:  Country(iso_code=ISOCode("USA"),  name="United  States")2627@dataclass28class  CAMEOCode:29  """Represents  a  CAMEO  verb  code."""30  code:  str  #  2-digit  CAMEO  code  for  first  level  relations,  3-digit  CAMEO  code  for  second  level  relations31  #  Example:  CAMEOCode("01"),  CAMEOCode("010")3233@dataclass34class  Relation:35  """Represents  a  relation."""36  cameo_code:  CAMEOCode37  name:  str38  description:  str  #  A  brief  description  of  what  event  the  relation  represents39  #  Example:  Relation(cameo_code=CAMEOCode("010"),  name="Make  statement,  not  specified",  description="All  public  statements  expressed  verbally  or  in  action,  not  otherwise  specified."4041@dataclass42class  Event:43  """Represents  an  event  characterized  by  date,  head  entity,  relation,  and  tail  entity."""44  date:  Date45  head_entity:  ISOCode46  relation:  CAMEOCode47  tail_entity:  ISOCode48  #  Example:  Event(date=Date("2022-01-01"),  head_entity=ISOCode("USA"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("CAN"))4950@dataclass51class  NewsArticle:52  """Represents  a  news  article,  including  metadata  and  content."""53  date:  Date54  title:  str55  content:  str  #  Full  text  content  of  the  news  article56  events:  List[Event]  #  List  of  events  mentioned  in  the  article57  #  Example:  NewsArticle(date=Date("2022-01-01"),  title="Trade  agreement  between  USA  and  China",  content="On  January  1,  2022,  a  trade  agreement  was  signed  between  the  USA  and  China...",  events=[Event(date=Date("2022-01-01"),  head_entity=ISOCode("USA"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("CHN")])5859  def  __str__(self):60  return  f"{self.date}:\n{self.title}\n{self.content}"6162def  map_country_name_to_iso(name:  str)  ->  List[Country]:63  """64  Maps  a  country  name  to  the  most  likely  corresponding  Country  objects  with  ISO  codes.6566  Parameters:67  name  (str):  The  country  name  to  map.6869  Returns:70  List[Country]:  A  list  of  5  most  likely  Country  objects  sorted  by  relevance.7172  Example:73  >>>  map_country_name_to_iso("Korea")74  [Country(iso_code=ISOCode("KOR"),  name="Republic  of  Korea"),  Country(iso_code=ISOCode("PRK"),  name="Democratic  People’s  Republic  of  Korea")]75  """76  pass7778def  map_iso_to_country_name(iso_code:  ISOCode)  ->  str:79  """80  Maps  an  ISO  code  to  a  country  name.8182  Parameters:83  iso_code  (ISOCode):  The  ISO  code  to  map.8485  Returns:86  str:  The  corresponding  country  name.8788  Example:89  >>>  map_iso_to_country_name(ISOCode("CHN"))90  "China"91  """92  pass9394def  map_relation_description_to_cameo(description:  str)  ->  List[Relation]:95  """96  Maps  a  relation  description  to  the  most  likely  Relation  objects.9798  Parameters:99  description  (str):  The  relation  description  to  map.100101  Returns:102  List[Relation]:  A  list  of  5  most  likely  Relations  sorted  by  relevance.103104  Example:105  >>>  map_relation_description_to_cameo("Fight  with  guns")106  [Reltion(cameo_code=CAMEOCode("19"),  name="Fight",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups."),  Relation(cameo_code=CAMEOCode("193"),  name="Fight  with  small  arms  and  light  weapons",  description="Attack  using  small  arms  and  light  weapons  such  as  rifles,  machine-guns,  and  mortar  shells."),  Relation(cameo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified.")]107  """108  pass109110def  map_cameo_to_relation(cameo_code:  CAMEOCode)  ->  Relation:111  """112  Maps  a  CAMEO  code  to  a  relation,  including  its  name  and  description.113114  Parameters:115  cameo_code  (CAMEOCode):  The  CAMEO  code  to  map.116117  Returns:118  Relation:  The  corresponding  relation.119120  Example:121  >>>  map_cameo_to_relation(CAMEOCode("190"))122  Relation(cameo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified.")123  """124  pass125126def  get_child_relations(cameo_code:  CAMEOCode)  ->  List[Relation]:127  """128  Retrieves  child  relations  of  a  given  relation  identified  by  CAMEO  code.129130  Parameters:131  cameo_code  (CAMEOCode):  The  CAMEO  code  of  the  relation  whose  children  are  sought.  Only  first  level  relations  are  accepted.132133  Returns:134  List[Relation]:  A  list  of  second  level  child  relations.135136  Example:137  >>>  get_child_relations(CAMEOCode("19"))138  [Relation(caemo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified."),  Relation(cameo_code=CAMEOCode("191"),  name="Impose  blockade  or  restrict  movement",  description="Prevent  entry  into  and/or  exit  from  a  territory  using  armed  forces."),  ...]139  """140  pass141142def  get_sibling_relations(cameo_code:  CAMEOCode)  ->  List[Relation]:143  """144  Retrieves  sibling  relations  of  a  given  relation  identified  by  CAMEO  code.145146  Parameters:147  cameo_code  (CAMEOCode):  The  CAMEO  code  of  the  relation  whose  siblings  are  sought.  Both  first  and  second  level  relations  are  accepted.148149  Returns:150  List[Relation]:  A  list  of  sibling  relations  at  the  same  level.151152  Example:153  >>>  get_sibling_relations(CAMEOCode("193"))154  [Relation(caemo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified."),  Relation(cameo_code=CAMEOCode("191"),  name="Impose  blockade  or  restrict  movement",  description="Prevent  entry  into  and/or  exit  from  a  territory  using  armed  forces."),  ...]155  """156  pass157158def  count_events(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None)  ->  int:159  """160  Counts  the  number  of  events  in  the  knowledge  graph  based  on  specified  conditions.161162  Parameters:163  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  events.  If  None,  all  dates  are  included.164  head_entities  (Optional[List[ISOCode]]):  List  of  head  entity  ISO  codes  to  be  included.  If  None,  all  countries  are  included.165  tail_entities  (Optional[List[ISOCode]]):  List  of  tail  entity  ISO  codes  to  be  included.  If  None,  all  countries  are  included.166  relations  (Optional[List[CAMEOCode]]):  List  of  relation  CAMEO  codes  to  be  included.  If  first  level  relations  are  listed,  all  second  level  relations  under  them  are  included.  If  None,  all  relations  are  included.167168  Returns:169  int:  Count  of  unique  events  matching  the  conditions.170171  Example:172  >>>  count_events(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=None,  relations=[CAMEOCode("010")])173  4174  """175  pass176177def  get_events(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None,  text_description:  Optional[str]  =  None)  ->  List[Event]:178  """179  Retrieves  events  from  the  knowledge  graph  based  on  specified  conditions.180  Inherits  common  filter  parameters  from  count_events.  See  count_events  for  more  details  on  these  parameters.181182  Additional  Parameters:183  text_description  (Optional[str]):  Textual  description  to  match  with  the  source  news  articles  of  events.  If  None,  the  returned  events  are  sorted  by  date  in  descending  order;  otherwise,  sorted  by  relevance  of  the  source  news  article  to  the  description.184185  Returns:186  List[Event]:  A  list  of  maximum  30  events  matching  the  specified  conditions.187188  Example:189  >>>  get_events(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=None,  relations=[CAMEOCode("010")],  text_description="economic  trade")190  [Event(date=Date("2022-01-15"),  head_entity=ISOCode("USA"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("CAN"),  Event(date=Date("2022-01-10"),  head_entity=ISOCode("CHN"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("USA"),  ...]191  """192  pass193194def  get_entity_distribution(date_range:  Optional[DateRange]  =  None,  involved_relations:  Optional[List[CAMEOCode]]  =  None,  interacted_entities:  Optional[List[ISOCode]]  =  None,  entity_role:  Optional[str]  =  None)  ->  Dict[ISOCode,  int]:195  """196  Gets  the  distribution  of  entities  in  the  knowledge  graph  under  specified  conditions.197198  Parameters:199  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  events.  If  None,  all  dates  are  included.200  involved_relations  (Optional[List[CAMEOCode]]):  List  of  relations  that  the  returned  entities  must  be  involved  in  any  of.  If  first  level  relations  are  listed,  all  second  level  relations  under  them  are  included.  If  None,  all  relations  are  included.201  interacted_entities  (Optional[List[ISOCode]]):  List  of  entities  that  the  returned  entities  must  have  interacted  with  any  of.  If  None,  all  entities  are  included.202  entity_role  (Optional[EntityRole]):  Specifies  the  role  of  the  returned  entity  in  the  events.  Options  are  ’head’,  ’tail’,  or  ’both’.  If  ’both’  or  None,  the  returned  entity  can  be  either  head  or  tail.203204  Returns:205  Dict[ISOCode,  int]:  A  dictionary  mapping  returned  entities’  ISO  codes  to  the  number  of  events  with  the  specified  conditions  in  which  they  are  involved,  sorted  by  counts  in  descending  order.206207  Example:208  >>>  get_entity_distribution(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  involved_relations=[CAMEOCode("010")],  interacted_entities=[ISOCode("USA"),  ISOCode("CHN")],  entity_role="tail")209  {ISOCode("USA"):  3,  ISOCode("CHN"):  1}210  """211  pass212213def  get_relation_distribution(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None)  ->  Dict[CAMEOCode,  int]:214  """215  Gets  the  distribution  of  second  level  relations  in  the  knowledge  graph  under  specified  conditions.216217  Parameters:218  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  events.  If  None,  all  dates  are  included.219  head_entities  (Optional[List[ISOCode]]):  List  of  head  entities  that  the  events  must  involve  any  of.  If  None,  all  head  entities  are  included.220  tail_entities  (Optional[List[ISOCode]]):  List  of  tail  entities  that  the  events  must  involve  any  of.  If  None,  all  tail  entities  are  included.221222  Returns:223  Dict[CAMEOCode,  int]:  A  dictionary  mapping  second  level  relations’  CAMEO  codes  to  the  number  of  events  with  the  specified  conditions  in  which  they  are  involved,  sorted  by  counts  in  descending  order.224225  Example:226  >>>  get_relation_distribution(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=None)227  {CAMEOCode("010"):  3,  CAMEOCode("011"):  1}228  """229  pass230231def  count_news_articles(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None,  keywords:  Optional[List[str]]  =  None)  ->  int:232  """233  Counts  the  number  of  news  articles  based  on  specified  conditions.234235  Parameters:236  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  news  articles.  If  None,  all  dates  are  included.237  head_entities  (Optional[List[ISOCode]]):  At  least  one  of  the  entities  must  be  mentioned  in  the  articles  and  be  the  head  entity  in  the  events.  If  None,  all  entities  are  included.238  tail_entities  (Optional[List[ISOCode]]):  At  least  one  of  the  entities  must  be  mentioned  in  the  articles  and  be  the  tail  entity  in  the  events.  If  None,  all  entities  are  included.239  relations  (Optional[List[CAMEOCode]]):  At  least  one  of  the  relations  must  be  mentioned  in  the  articles.  If  first  level  relations  are  listed,  all  second  level  relations  under  them  are  included.  If  None,  all  relations  are  included.240  keywords  (Optional[List[str]]):  At  least  one  of  the  keywords  must  be  present  in  the  articles.  If  None,  all  articles  are  included.241242  Returns:243  int:  The  count  of  news  articles  matching  the  conditions.244245  Example:246  >>>  count_news_articles(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=[ISOCode("USA"),  ISOCode("CHN")],  relations=[CAMEOCode("010")],  keywords=["trade"])247  2248  """249  pass250251def  get_news_articles(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None,  keywords:  Optional[List[str]]  =  None,  text_description:  Optional[str]  =  None)  ->  List[Tuple[Date,  str]]:252  """253  Retrieves  news  articles  based  on  specified  conditions.254  Inherits  common  filter  parameters  from  count_news_articles.  See  count_news_articles  for  more  details  on  these  parameters.255256  Additional  Parameters:257  text_description  (Optional[str]):  Textual  description  to  match  with  the  news  articles.  If  None,  the  returned  articles  are  sorted  by  date  in  descending  order;  otherwise,  sorted  by  relevance  to  the  description.258259  Returns:260  List[Tuple[Date,  str]]:  A  list  of  maximum  15  news  articles  matching  the  specified  conditions,  each  represented  by  a  tuple  of  date  and  title.261262  Example:263  >>>  get_news_articles(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=[ISOCode("USA"),  ISOCode("CHN")],  relations=[CAMEOCode("010")],  keywords=["trade"],  text_description="Economic  trade  is  encouraged  between  USA  and  China.")264  [(NewsArticle.date=Date("2022-01-15"),  NewsArticle.title="China  and  USA  sign  trade  deal"),  (NewsArticle.date=Date("2022-01-10"),  NewsArticle.title="Trade  agreement  between  USA  and  China")]265  """266  pass267268def  browse_news_article(date:  Date,  title:  str)  ->  str:269  """270  Retrieves  the  full  text  of  a  news  article  by  its  title.271272  Parameters:273  date  (Date):  The  date  of  the  news  article  to  retrieve.274  title  (str):  The  title  of  the  news  article  to  retrieve.275276  Returns:277  str:  The  date,  the  title  and  full  contents  of  the  news  article.278279  Example:280  >>>  browse_news_article(Date("2022-01-10"),  "Trade  agreement  between  USA  and  China")281  2022-01-10:282  Trade  agreement  between  USA  and  China283  On  January  10,  2022,  a  trade  agreement  was  signed  between  the  USA  and  China  to  promote  economic  cooperation...284  """285  pass’

    ### M.3 API Implementation

    In this section, we provide the full implementation of the API, which is part of the environment and is accessible to the Python executor.

    [⬇](data:text/plain;base64,QGRhdGFjbGFzcwpjbGFzcyBEYXRlOgogICAgIiIiUmVwcmVzZW50cyBhIGRhdGUuIiIiCiAgICBkYXRlOiBzdHIgIyBEYXRlIGluIHRoZSBmb3JtYXQgJ1lZWVktTU0tREQnCiAgICAjIEV4YW1wbGU6IERhdGUoIjIwMjItMDEtMDEiKQoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBkYXRlOiBzdHIpOgogICAgICAgICMgY2hlY2sgdHlwZQogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGRhdGUsIHN0cik6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJBdHRyaWJ1dGUgJ2RhdGUnIG9mIGNsYXNzIERhdGUgbXVzdCBiZSBhIHN0cmluZyBpbiB0aGUgZm9ybWF0ICdZWVlZLU1NLUREJywgYnV0IHJlY2VpdmVkOiB7ZGF0ZX0gaW4gdHlwZSB7dHlwZShkYXRlKX0iKQoKICAgICAgICAjIGNoZWNrIGlmIGRhdGUgaXMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0IGJ5IHRyeWluZyB0byBjb252ZXJ0IGl0IHRvIGEgZGF0ZSBvYmplY3QKICAgICAgICB0cnk6CiAgICAgICAgICAgIGRhdGV0aW1lLmRhdGV0aW1lLnN0cnB0aW1lKGRhdGUsICclWS0lbS0lZCcpCiAgICAgICAgZXhjZXB0IFZhbHVlRXJyb3I6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJEYXRlIG11c3QgYmUgaW4gdGhlIGZvcm1hdCAnWVlZWS1NTS1ERCcsIGJ1dCByZWNlaXZlZDoge2RhdGV9IikKICAgICAgICBpZiBkYXRlIDwgREVGQVVMVF9TVEFSVF9EQVRFOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiRGF0ZSBtdXN0IGJlIG9uIG9yIGFmdGVyIHtERUZBVUxUX1NUQVJUX0RBVEV9LCBidXQgcmVjZWl2ZWQ6IHtkYXRlfSIpCiAgICAgICAgaWYgREVGQVVMVF9FTkRfREFURSBhbmQgZGF0ZSA+IERFRkFVTFRfRU5EX0RBVEU6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJEYXRlIG11c3QgYmUgb24gb3IgYmVmb3JlIHRoZSBjdXJyZW50IGRhdGUge0RFRkFVTFRfRU5EX0RBVEV9LCBidXQgcmVjZWl2ZWQ6IHtkYXRlfSIpCgogICAgICAgIHNlbGYuZGF0ZSA9IGRhdGUKCiAgICBkZWYgX19zdHJfXyhzZWxmKToKICAgICAgICByZXR1cm4gZiJEYXRlKCd7c2VsZi5kYXRlfScpIgoKICAgIGRlZiBfX2hhc2hfXyhzZWxmKToKICAgICAgICByZXR1cm4gaGFzaChzZWxmLmRhdGUpCgogICAgZGVmIF9fZXFfXyhzZWxmLCBvdGhlcik6CiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgRGF0ZSk6CiAgICAgICAgICAgIHJldHVybiBzZWxmLmRhdGUgPT0gb3RoZXIuZGF0ZQogICAgICAgIHJldHVybiBGYWxzZQoKQGRhdGFjbGFzcwpjbGFzcyBEYXRlUmFuZ2U6CiAgICAiIiJSZXByZXNlbnRzIGEgcmFuZ2Ugb2YgZGF0ZXMgKGluY2x1c2l2ZSkuIiIiCiAgICBzdGFydF9kYXRlOiBPcHRpb25hbFtEYXRlXSAjIElmIE5vbmUsIHRoZSBlYXJsaWVzdCBkYXRlIGlzIHVzZWQKICAgIGVuZF9kYXRlOiBPcHRpb25hbFtEYXRlXSAjIElmIE5vbmUsIHRoZSBjdXJyZW50IGRhdGUgaXMgdXNlZAogICAgIyBFeGFtcGxlOiBEYXRlUmFuZ2Uoc3RhcnRfZGF0ZT1EYXRlKCIyMDIyLTAxLTAxIiksIGVuZF9kYXRlPURhdGUoIjIwMjItMDEtMzEiKSkKCiAgICBkZWYgX19pbml0X18oc2VsZiwgc3RhcnRfZGF0ZTogT3B0aW9uYWxbRGF0ZV0gPSBOb25lLCBlbmRfZGF0ZTogT3B0aW9uYWxbRGF0ZV0gPSBOb25lKToKICAgICAgICAjIGNoZWNrIHR5cGUKICAgICAgICBpZiBzdGFydF9kYXRlIGFuZCBub3QgaXNpbnN0YW5jZShzdGFydF9kYXRlLCBEYXRlKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnc3RhcnRfZGF0ZScgb2YgY2xhc3MgRGF0ZVJhbmdlIG11c3QgYmUgYSBEYXRlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoc3RhcnRfZGF0ZSl9IikKICAgICAgICBpZiBlbmRfZGF0ZSBhbmQgbm90IGlzaW5zdGFuY2UoZW5kX2RhdGUsIERhdGUpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICdlbmRfZGF0ZScgb2YgY2xhc3MgRGF0ZVJhbmdlIG11c3QgYmUgYSBEYXRlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoZW5kX2RhdGUpfSIpCgogICAgICAgIHNlbGYuc3RhcnRfZGF0ZSA9IHN0YXJ0X2RhdGUgaWYgc3RhcnRfZGF0ZSBlbHNlIERhdGUoREVGQVVMVF9TVEFSVF9EQVRFKQogICAgICAgIHNlbGYuZW5kX2RhdGUgPSBlbmRfZGF0ZSBpZiBlbmRfZGF0ZSBlbHNlIERhdGUoREVGQVVMVF9FTkRfREFURSkKICAgICAgICBpZiBzdGFydF9kYXRlIGFuZCBlbmRfZGF0ZSBhbmQgc3RhcnRfZGF0ZS5kYXRlID4gZW5kX2RhdGUuZGF0ZToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcigiU3RhcnQgZGF0ZSBtdXN0IGJlIGJlZm9yZSBvciBlcXVhbCB0byBlbmQgZGF0ZSwgYnV0IHJlY2VpdmVkOiBzdGFydF9kYXRlPXt9LCBlbmRfZGF0ZT17fSIuZm9ybWF0KHN0YXJ0X2RhdGUuZGF0ZSwgZW5kX2RhdGUuZGF0ZSkpCgogICAgZGVmIF9fc3RyX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGYiRGF0ZVJhbmdlKHN0YXJ0X2RhdGU9e3NlbGYuc3RhcnRfZGF0ZX0sIGVuZF9kYXRlPXtzZWxmLmVuZF9kYXRlfSkiCgogICAgZGVmIF9faGFzaF9fKHNlbGYpOgogICAgICAgIHJldHVybiBoYXNoKChzZWxmLnN0YXJ0X2RhdGUsIHNlbGYuZW5kX2RhdGUpKQoKICAgIGRlZiBfX2VxX18oc2VsZiwgb3RoZXIpOgogICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIERhdGVSYW5nZSk6CiAgICAgICAgICAgIHJldHVybiBzZWxmLnN0YXJ0X2RhdGUgPT0gb3RoZXIuc3RhcnRfZGF0ZSBhbmQgc2VsZi5lbmRfZGF0ZSA9PSBvdGhlci5lbmRfZGF0ZQogICAgICAgIHJldHVybiBGYWxzZQoKQGRhdGFjbGFzcwpjbGFzcyBJU09Db2RlOgogICAgIiIiUmVwcmVzZW50cyBhbiBJU08gYWxwaGEtMyBjb3VudHJ5IGNvZGUuIiIiCiAgICBjb2RlOiBzdHIgIyAzLWxldHRlciBJU08gY29kZQogICAgIyBFeGFtcGxlOiBJU09Db2RlKCJVU0EiKQoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBjb2RlOiBzdHIpOgogICAgICAgICMgY2hlY2sgdHlwZQogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGNvZGUsIHN0cik6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJBdHRyaWJ1dGUgJ2NvZGUnIG9mIGNsYXNzIElTT0NvZGUgbXVzdCBiZSBhIHN0cmluZywgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY29kZSl9IikKCiAgICAgICAgaWYgbGVuKGNvZGUpICE9IDM6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJU08gY29kZSBtdXN0IGJlIGEgMy1sZXR0ZXIgc3RyaW5nLCBidXQgcmVjZWl2ZWQ6IHtjb2RlfSIpCiAgICAgICAgaWYgY29kZSBub3QgaW4gZGljdF9pc28yYWx0ZXJuYW1lczoKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklTTyBjb2RlIG11c3QgYmUgYSB2YWxpZCBJU08gYWxwaGEtMyBjb3VudHJ5IGNvZGUsIGJ1dCByZWNlaXZlZDoge2NvZGV9IikKICAgICAgICBzZWxmLmNvZGUgPSBjb2RlCgogICAgZGVmIF9fc3RyX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGYiSVNPQ29kZSgne3NlbGYuY29kZX0nKSIKCiAgICBkZWYgX19oYXNoX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGhhc2goc2VsZi5jb2RlKQoKICAgIGRlZiBfX2VxX18oc2VsZiwgb3RoZXIpOgogICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIElTT0NvZGUpOgogICAgICAgICAgICByZXR1cm4gc2VsZi5jb2RlID09IG90aGVyLmNvZGUKICAgICAgICByZXR1cm4gRmFsc2UKCkBkYXRhY2xhc3MKY2xhc3MgQ291bnRyeToKICAgICIiIlJlcHJlc2VudHMgYSBjb3VudHJ5IGVudGl0eS4iIiIKICAgIGlzb19jb2RlOiBJU09Db2RlCiAgICBuYW1lOiBzdHIKICAgICMgRXhhbXBsZTogQ291bnRyeShpc29fY29kZT1JU09Db2RlKCJVU0EiKSwgbmFtZT0iVW5pdGVkIFN0YXRlcyIpCgogICAgZGVmIF9faW5pdF9fKHNlbGYsIGlzb19jb2RlOiBJU09Db2RlLCBuYW1lOiBzdHIpOgogICAgICAgICMgY2hlY2sgdHlwZQogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGlzb19jb2RlLCBJU09Db2RlKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnaXNvX2NvZGUnIG9mIGNsYXNzIENvdW50cnkgbXVzdCBiZSBhbiBJU09Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoaXNvX2NvZGUpfSIpCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UobmFtZSwgc3RyKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnbmFtZScgb2YgY2xhc3MgQ291bnRyeSBtdXN0IGJlIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShuYW1lKX0iKQoKICAgICAgICBpZiBkaWN0X2lzbzJhbHRlcm5hbWVzW2lzb19jb2RlLmNvZGVdWzBdICE9IG5hbWU6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJDb3VudHJ5IG5hbWUgbXVzdCBtYXRjaCB0aGUgbmFtZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBJU08gY29kZSwgYnV0IHJlY2VpdmVkOiB7bmFtZX0gZm9yIElTTyBjb2RlOiB7aXNvX2NvZGUuY29kZX0iKQogICAgICAgIHNlbGYuaXNvX2NvZGUgPSBpc29fY29kZQogICAgICAgIHNlbGYubmFtZSA9IG5hbWUKCiAgICBkZWYgX19zdHJfXyhzZWxmKToKICAgICAgICByZXR1cm4gZiJDb3VudHJ5KGlzb19jb2RlPXtzZWxmLmlzb19jb2RlfSwgbmFtZT0ne3NlbGYubmFtZX0nKSIKCiAgICBkZWYgX19oYXNoX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGhhc2goKHNlbGYuaXNvX2NvZGUsIHNlbGYubmFtZSkpCgogICAgZGVmIF9fZXFfXyhzZWxmLCBvdGhlcik6CiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgQ291bnRyeSk6CiAgICAgICAgICAgIHJldHVybiBzZWxmLmlzb19jb2RlID09IG90aGVyLmlzb19jb2RlIGFuZCBzZWxmLm5hbWUgPT0gb3RoZXIubmFtZQogICAgICAgIHJldHVybiBGYWxzZQoKQGRhdGFjbGFzcwpjbGFzcyBDQU1FT0NvZGU6CiAgICAiIiJSZXByZXNlbnRzIGEgQ0FNRU8gdmVyYiBjb2RlLiIiIgogICAgY29kZTogc3RyICMgMi1kaWdpdCBDQU1FTyBjb2RlIGZvciBmaXJzdCBsZXZlbCByZWxhdGlvbnMsIDMtZGlnaXQgQ0FNRU8gY29kZSBmb3Igc2Vjb25kIGxldmVsIHJlbGF0aW9ucwogICAgIyBFeGFtcGxlOiBDQU1FT0NvZGUoIjAxIiksIENBTUVPQ29kZSgiMDEwIikKCiAgICBkZWYgX19pbml0X18oc2VsZiwgY29kZTogc3RyKToKICAgICAgICAjIGNoZWNrIHR5cGUKICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShjb2RlLCBzdHIpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICdjb2RlJyBvZiBjbGFzcyBDQU1FT0NvZGUgbXVzdCBiZSBhIHN0cmluZywgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY29kZSl9IikKCiAgICAgICAgaWYgbGVuKGNvZGUpIG5vdCBpbiBbMiwgM106CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJDQU1FTyBjb2RlIG11c3QgYmUgYSB2YWxpZCAyIG9yIDMtZGlnaXQgc3RyaW5nIGRlZmluZWQgaW4gdGhlICdDb25mbGljdCBhbmQgTWVkaWF0aW9uIEV2ZW50IE9ic2VydmF0aW9ucycgQ29kZWJvb2ssIGJ1dCByZWNlaXZlZDoge2NvZGV9IikKICAgICAgICBpZiBjb2RlIG5vdCBpbiBkaWN0X2NvZGUycmVsYXRpb246CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJDQU1FTyBjb2RlIG11c3QgYmUgYSB2YWxpZCBDQU1FTyBjb2RlIGRlZmluZWQgaW4gdGhlICdDb25mbGljdCBhbmQgTWVkaWF0aW9uIEV2ZW50IE9ic2VydmF0aW9ucycgQ29kZWJvb2ssIGJ1dCByZWNlaXZlZDoge2NvZGV9IikKICAgICAgICBzZWxmLmNvZGUgPSBjb2RlCgogICAgZGVmIF9fc3RyX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGYiQ0FNRU9Db2RlKCd7c2VsZi5jb2RlfScpIgoKICAgIGRlZiBfX2hhc2hfXyhzZWxmKToKICAgICAgICByZXR1cm4gaGFzaChzZWxmLmNvZGUpCgogICAgZGVmIF9fZXFfXyhzZWxmLCBvdGhlcik6CiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgQ0FNRU9Db2RlKToKICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29kZSA9PSBvdGhlci5jb2RlCiAgICAgICAgcmV0dXJuIEZhbHNlCgpAZGF0YWNsYXNzCmNsYXNzIFJlbGF0aW9uOgogICAgIiIiUmVwcmVzZW50cyBhIHJlbGF0aW9uLiIiIgogICAgY2FtZW9fY29kZTogQ0FNRU9Db2RlCiAgICBuYW1lOiBzdHIKICAgIGRlc2NyaXB0aW9uOiBzdHIgIyBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHdoYXQgZXZlbnQgdGhlIHJlbGF0aW9uIHJlcHJlc2VudHMKICAgICMgRXhhbXBsZTogUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoIjAxMCIpLCBuYW1lPSJNYWtlIHN0YXRlbWVudCwgbm90IHNwZWNpZmllZCIsIGRlc2NyaXB0aW9uPSJBbGwgcHVibGljIHN0YXRlbWVudHMgZXhwcmVzc2VkIHZlcmJhbGx5IG9yIGluIGFjdGlvbiwgbm90IG90aGVyd2lzZSBzcGVjaWZpZWQuIgoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBjYW1lb19jb2RlOiBDQU1FT0NvZGUsIG5hbWU6IHN0ciwgZGVzY3JpcHRpb246IHN0cik6CiAgICAgICAgIyBjaGVjayB0eXBlCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UoY2FtZW9fY29kZSwgQ0FNRU9Db2RlKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnY2FtZW9fY29kZScgb2YgY2xhc3MgUmVsYXRpb24gbXVzdCBiZSBhIENBTUVPQ29kZSBvYmplY3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGNhbWVvX2NvZGUpfSIpCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UobmFtZSwgc3RyKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnbmFtZScgb2YgY2xhc3MgUmVsYXRpb24gbXVzdCBiZSBhIHN0cmluZywgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUobmFtZSl9IikKICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShkZXNjcmlwdGlvbiwgc3RyKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnZGVzY3JpcHRpb24nIG9mIGNsYXNzIFJlbGF0aW9uIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGRlc2NyaXB0aW9uKX0iKQoKICAgICAgICBpZiBkaWN0X2NvZGUycmVsYXRpb25bY2FtZW9fY29kZS5jb2RlXVsnTmFtZSddICE9IG5hbWU6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJSZWxhdGlvbiBuYW1lIG11c3QgbWF0Y2ggdGhlIG5hbWUgY29ycmVzcG9uZGluZyB0byB0aGUgQ0FNRU8gY29kZSwgYnV0IHJlY2VpdmVkOiB7bmFtZX0gZm9yIENBTUVPIGNvZGUge2NhbWVvX2NvZGUuY29kZX0iKQogICAgICAgIGlmIGRpY3RfY29kZTJyZWxhdGlvbltjYW1lb19jb2RlLmNvZGVdWydEZXNjcmlwdGlvbiddICE9IGRlc2NyaXB0aW9uOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiUmVsYXRpb24gZGVzY3JpcHRpb24gbXVzdCBtYXRjaCB0aGUgZGVzY3JpcHRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgQ0FNRU8gY29kZSwgYnV0IHJlY2VpdmVkOiB7ZGVzY3JpcHRpb259IGZvciBDQU1FTyBjb2RlIHtjYW1lb19jb2RlLmNvZGV9IikKICAgICAgICBzZWxmLmNhbWVvX2NvZGUgPSBjYW1lb19jb2RlCiAgICAgICAgc2VsZi5uYW1lID0gbmFtZQogICAgICAgIHNlbGYuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbgoKICAgIGRlZiBfX3N0cl9fKHNlbGYpOgogICAgICAgIHJldHVybiBmIlJlbGF0aW9uKGNhbWVvX2NvZGU9e3NlbGYuY2FtZW9fY29kZX0sIG5hbWU9J3tzZWxmLm5hbWV9JywgZGVzY3JpcHRpb249J3tzZWxmLmRlc2NyaXB0aW9ufScpIgoKICAgIGRlZiBfX2hhc2hfXyhzZWxmKToKICAgICAgICByZXR1cm4gaGFzaCgoc2VsZi5jYW1lb19jb2RlLCBzZWxmLm5hbWUsIHNlbGYuZGVzY3JpcHRpb24pKQoKICAgIGRlZiBfX2VxX18oc2VsZiwgb3RoZXIpOgogICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIFJlbGF0aW9uKToKICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FtZW9fY29kZSA9PSBvdGhlci5jYW1lb19jb2RlIGFuZCBzZWxmLm5hbWUgPT0gb3RoZXIubmFtZSBhbmQgc2VsZi5kZXNjcmlwdGlvbiA9PSBvdGhlci5kZXNjcmlwdGlvbgogICAgICAgIHJldHVybiBGYWxzZQoKQGRhdGFjbGFzcwpjbGFzcyBFdmVudDoKICAgICIiIlJlcHJlc2VudHMgYW4gZXZlbnQgY2hhcmFjdGVyaXplZCBieSBkYXRlLCBoZWFkIGVudGl0eSwgcmVsYXRpb24sIGFuZCB0YWlsIGVudGl0eS4iIiIKICAgIGRhdGU6IERhdGUKICAgIGhlYWRfZW50aXR5OiBJU09Db2RlCiAgICByZWxhdGlvbjogQ0FNRU9Db2RlCiAgICB0YWlsX2VudGl0eTogSVNPQ29kZQogICAgIyBFeGFtcGxlOiBFdmVudChkYXRlPURhdGUoIjIwMjItMDEtMDEiKSwgaGVhZF9lbnRpdHk9SVNPQ29kZSgiVVNBIiksIHJlbGF0aW9uPUNBTUVPQ29kZSgiMDEwIiksIHRhaWxfZW50aXR5PUlTT0NvZGUoIkNBTiIpKQoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBkYXRlOiBEYXRlLCBoZWFkX2VudGl0eTogSVNPQ29kZSwgcmVsYXRpb246IENBTUVPQ29kZSwgdGFpbF9lbnRpdHk6IElTT0NvZGUpOgogICAgICAgICMgY2hlY2sgdHlwZQogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGRhdGUsIERhdGUpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICdkYXRlJyBvZiBjbGFzcyBFdmVudCBtdXN0IGJlIGEgRGF0ZSBvYmplY3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGRhdGUpfSIpCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UoaGVhZF9lbnRpdHksIElTT0NvZGUpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICdoZWFkX2VudGl0eScgb2YgY2xhc3MgRXZlbnQgbXVzdCBiZSBhbiBJU09Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoaGVhZF9lbnRpdHkpfSIpCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UocmVsYXRpb24sIENBTUVPQ29kZSk6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJBdHRyaWJ1dGUgJ3JlbGF0aW9uJyBvZiBjbGFzcyBFdmVudCBtdXN0IGJlIGEgQ0FNRU9Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUocmVsYXRpb24pfSIpCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UodGFpbF9lbnRpdHksIElTT0NvZGUpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICd0YWlsX2VudGl0eScgb2YgY2xhc3MgRXZlbnQgbXVzdCBiZSBhbiBJU09Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUodGFpbF9lbnRpdHkpfSIpCgogICAgICAgIHNlbGYuZGF0ZSA9IGRhdGUKICAgICAgICBzZWxmLmhlYWRfZW50aXR5ID0gaGVhZF9lbnRpdHkKICAgICAgICBzZWxmLnJlbGF0aW9uID0gcmVsYXRpb24KICAgICAgICBzZWxmLnRhaWxfZW50aXR5ID0gdGFpbF9lbnRpdHkKCiAgICBkZWYgX19zdHJfXyhzZWxmKToKICAgICAgICByZXR1cm4gZiJFdmVudChkYXRlPXtzZWxmLmRhdGV9LCBoZWFkX2VudGl0eT17c2VsZi5oZWFkX2VudGl0eX0sIHJlbGF0aW9uPXtzZWxmLnJlbGF0aW9ufSwgdGFpbF9lbnRpdHk9e3NlbGYudGFpbF9lbnRpdHl9KSIKCiAgICBkZWYgX19oYXNoX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGhhc2goKHNlbGYuZGF0ZSwgc2VsZi5oZWFkX2VudGl0eSwgc2VsZi5yZWxhdGlvbiwgc2VsZi50YWlsX2VudGl0eSkpCgogICAgZGVmIF9fZXFfXyhzZWxmLCBvdGhlcik6CiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgRXZlbnQpOgogICAgICAgICAgICByZXR1cm4gc2VsZi5kYXRlID09IG90aGVyLmRhdGUgYW5kIHNlbGYuaGVhZF9lbnRpdHkgPT0gb3RoZXIuaGVhZF9lbnRpdHkgYW5kIHNlbGYucmVsYXRpb24gPT0gb3RoZXIucmVsYXRpb24gYW5kIHNlbGYudGFpbF9lbnRpdHkgPT0gb3RoZXIudGFpbF9lbnRpdHkKICAgICAgICByZXR1cm4gRmFsc2UKCkBkYXRhY2xhc3MKY2xhc3MgTmV3c0FydGljbGU6CiAgICAiIiJSZXByZXNlbnRzIGEgbmV3cyBhcnRpY2xlLCBpbmNsdWRpbmcgbWV0YWRhdGEgYW5kIGNvbnRlbnQuIiIiCiAgICBkYXRlOiBEYXRlCiAgICB0aXRsZTogc3RyCiAgICBjb250ZW50OiBzdHIgIyBGdWxsIHRleHQgY29udGVudCBvZiB0aGUgbmV3cyBhcnRpY2xlCiAgICBldmVudHM6IExpc3RbRXZlbnRdICMgTGlzdCBvZiBldmVudHMgbWVudGlvbmVkIGluIHRoZSBhcnRpY2xlCiAgICAjIEV4YW1wbGU6IE5ld3NBcnRpY2xlKGRhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCB0aXRsZT0iVHJhZGUgYWdyZWVtZW50IGJldHdlZW4gVVNBIGFuZCBDaGluYSIsIGNvbnRlbnQ9Ik9uIEphbnVhcnkgMSwgMjAyMiwgYSB0cmFkZSBhZ3JlZW1lbnQgd2FzIHNpZ25lZCBiZXR3ZWVuIHRoZSBVU0EgYW5kIENoaW5hLi4uIiwgZXZlbnRzPVtFdmVudChkYXRlPURhdGUoIjIwMjItMDEtMDEiKSwgaGVhZF9lbnRpdHk9SVNPQ29kZSgiVVNBIiksIHJlbGF0aW9uPUNBTUVPQ29kZSgiMDEwIiksIHRhaWxfZW50aXR5PUlTT0NvZGUoIkNITiIpXSkKCiAgICBkZWYgX19pbml0X18oc2VsZiwgZGF0ZTogRGF0ZSwgdGl0bGU6IHN0ciwgY29udGVudDogc3RyLCBldmVudHM6IExpc3RbRXZlbnRdKToKICAgICAgICAjIGNoZWNrIHR5cGUKICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShkYXRlLCBEYXRlKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnZGF0ZScgb2YgY2xhc3MgTmV3c0FydGljbGUgbXVzdCBiZSBhIERhdGUgb2JqZWN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShkYXRlKX0iKQogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKHRpdGxlLCBzdHIpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICd0aXRsZScgb2YgY2xhc3MgTmV3c0FydGljbGUgbXVzdCBiZSBhIHN0cmluZywgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUodGl0bGUpfSIpCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UoY29udGVudCwgc3RyKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnY29udGVudCcgb2YgY2xhc3MgTmV3c0FydGljbGUgbXVzdCBiZSBhIHN0cmluZywgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY29udGVudCl9IikKICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShldmVudHMsIGxpc3QpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICdldmVudHMnIG9mIGNsYXNzIE5ld3NBcnRpY2xlIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShldmVudHMpfSIpCgogICAgICAgIHNlbGYuZGF0ZSA9IGRhdGUKICAgICAgICBzZWxmLnRpdGxlID0gdGl0bGUKICAgICAgICBzZWxmLmNvbnRlbnQgPSBjb250ZW50CiAgICAgICAgc2VsZi5ldmVudHMgPSBldmVudHMKCiAgICBkZWYgX19zdHJfXyhzZWxmKToKICAgICAgICByZXR1cm4gZiJ7c2VsZi5kYXRlfTpcbntzZWxmLnRpdGxlfVxue3NlbGYuY29udGVudH0iCgogICAgZGVmIF9faGFzaF9fKHNlbGYpOgogICAgICAgIHJldHVybiBoYXNoKChzZWxmLmRhdGUsIHNlbGYudGl0bGUsIHNlbGYuY29udGVudCkpCgogICAgZGVmIF9fZXFfXyhzZWxmLCBvdGhlcik6CiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgTmV3c0FydGljbGUpOgogICAgICAgICAgICByZXR1cm4gc2VsZi5kYXRlID09IG90aGVyLmRhdGUgYW5kIHNlbGYudGl0bGUgPT0gb3RoZXIudGl0bGUgYW5kIHNlbGYuY29udGVudCA9PSBvdGhlci5jb250ZW50CiAgICAgICAgcmV0dXJuIEZhbHNlCgpkZWYgbWFwX2NvdW50cnlfbmFtZV90b19pc28obmFtZTogc3RyKSAtPiBMaXN0W0NvdW50cnldOgogICAgIiIiCiAgICBNYXBzIGEgY291bnRyeSBuYW1lIHRvIHRoZSBtb3N0IGxpa2VseSBjb3JyZXNwb25kaW5nIENvdW50cnkgb2JqZWN0cyB3aXRoIElTTyBjb2Rlcy4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIG5hbWUgKHN0cik6IFRoZSBjb3VudHJ5IG5hbWUgdG8gbWFwLgoKICAgIFJldHVybnM6CiAgICAgICAgTGlzdFtDb3VudHJ5XTogQSBsaXN0IG9mIDUgbW9zdCBsaWtlbHkgQ291bnRyeSBvYmplY3RzIHNvcnRlZCBieSByZWxldmFuY2UuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gbWFwX2NvdW50cnlfbmFtZV90b19pc28oIktvcmVhIikKICAgICAgICBbQ291bnRyeShpc29fY29kZT1JU09Db2RlKCJLT1IiKSwgbmFtZT0iUmVwdWJsaWMgb2YgS29yZWEiKSwgQ291bnRyeShpc29fY29kZT1JU09Db2RlKCJQUksiKSwgbmFtZT0iRGVtb2NyYXRpYyBQZW9wbGUncyBSZXB1YmxpYyBvZiBLb3JlYSIpXQogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIG5vdCBpc2luc3RhbmNlKG5hbWUsIHN0cik6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICduYW1lJyBtdXN0IGJlIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShuYW1lKX0iKQoKICAgIGlmIG5hbWUgaW4gZGljdF9jb3VudHJ5bmFtZTJpc286CiAgICAgICAgcmV0dXJuIFtDb3VudHJ5KGlzb19jb2RlPUlTT0NvZGUoZGljdF9jb3VudHJ5bmFtZTJpc29bbmFtZV0pLCBuYW1lPW5hbWUpXQogICAgZWxzZToKICAgICAgICAjIGdldCB0b3AgNSBJU08gY29kZXMgd2l0aCB0aGUgaGlnaGVzdCBjb3NpbmUgc2ltaWxhcml0eQogICAgICAgIG5hbWVfZW1iZWRkaW5ncyA9IGdldF9lbWJlZGRpbmcobmFtZSkKICAgICAgICBzaW1pbGFyaXRpZXMgPSBjb3NpbmVfc2ltaWxhcml0eShjb3VudHJ5X2VtYmVkZGluZ3MsIG5hbWVfZW1iZWRkaW5ncykKICAgICAgICB0b3BfaW5kaWNlcyA9IG5wLmFyZ3NvcnQoc2ltaWxhcml0aWVzKVs6Oi0xXVs6NV0KICAgICAgICBjb3VudHJpZXMgPSBbXQogICAgICAgIGZvciBpZHggaW4gdG9wX2luZGljZXM6CiAgICAgICAgICAgIGlzb19jb2RlID0gbGlzdChkaWN0X2lzbzJhbHRlcm5hbWVzLmtleXMoKSlbaWR4XQogICAgICAgICAgICBjdXJyX25hbWUgPSBkaWN0X2lzbzJhbHRlcm5hbWVzW2lzb19jb2RlXVswXQogICAgICAgICAgICBjb3VudHJpZXMuYXBwZW5kKENvdW50cnkoaXNvX2NvZGU9SVNPQ29kZShpc29fY29kZSksIG5hbWU9Y3Vycl9uYW1lKSkKICAgICAgICByZXR1cm4gY291bnRyaWVzCgpkZWYgbWFwX2lzb190b19jb3VudHJ5X25hbWUoaXNvX2NvZGU6IElTT0NvZGUpIC0+IHN0cjoKICAgICIiIgogICAgTWFwcyBhbiBJU08gY29kZSB0byBhIGNvdW50cnkgbmFtZS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGlzb19jb2RlIChJU09Db2RlKTogVGhlIElTTyBjb2RlIHRvIG1hcC4KCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogVGhlIGNvcnJlc3BvbmRpbmcgY291bnRyeSBuYW1lLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IG1hcF9pc29fdG9fY291bnRyeV9uYW1lKElTT0NvZGUoIkNITiIpKQogICAgICAgICJDaGluYSIKICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBub3QgaXNpbnN0YW5jZShpc29fY29kZSwgSVNPQ29kZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdpc29fY29kZScgbXVzdCBiZSBhbiBJU09Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoaXNvX2NvZGUpfSIpCgogICAgcmV0dXJuIGRpY3RfaXNvMmFsdGVybmFtZXNbaXNvX2NvZGUuY29kZV1bMF0KCmRlZiBtYXBfcmVsYXRpb25fZGVzY3JpcHRpb25fdG9fY2FtZW8oZGVzY3JpcHRpb246IHN0cikgLT4gTGlzdFtSZWxhdGlvbl06CiAgICAiIiIKICAgIE1hcHMgYSByZWxhdGlvbiBkZXNjcmlwdGlvbiB0byB0aGUgbW9zdCBsaWtlbHkgUmVsYXRpb24gb2JqZWN0cy4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGRlc2NyaXB0aW9uIChzdHIpOiBUaGUgcmVsYXRpb24gZGVzY3JpcHRpb24gdG8gbWFwLgoKICAgIFJldHVybnM6CiAgICAgICAgTGlzdFtSZWxhdGlvbl06IEEgbGlzdCBvZiA1IG1vc3QgbGlrZWx5IFJlbGF0aW9ucyBzb3J0ZWQgYnkgcmVsZXZhbmNlLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IG1hcF9yZWxhdGlvbl9kZXNjcmlwdGlvbl90b19jYW1lbygiRmlnaHQgd2l0aCBndW5zIikKICAgICAgICBbUmVsdGlvbihjYW1lb19jb2RlPUNBTUVPQ29kZSgiMTkiKSwgbmFtZT0iRmlnaHQiLCBkZXNjcmlwdGlvbj0iQWxsIHVzZXMgb2YgY29udmVudGlvbmFsIGZvcmNlIGFuZCBhY3RzIG9mIHdhciB0eXBpY2FsbHkgYnkgb3JnYW5pemVkIGFybWVkIGdyb3Vwcy4iKSwgUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoIjE5MyIpLCBuYW1lPSJGaWdodCB3aXRoIHNtYWxsIGFybXMgYW5kIGxpZ2h0IHdlYXBvbnMiLCBkZXNjcmlwdGlvbj0iQXR0YWNrIHVzaW5nIHNtYWxsIGFybXMgYW5kIGxpZ2h0IHdlYXBvbnMgc3VjaCBhcyByaWZsZXMsIG1hY2hpbmUtZ3VucywgYW5kIG1vcnRhciBzaGVsbHMuIiksIFJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIxOTAiKSwgbmFtZT0iVXNlIGNvbnZlbnRpb25hbCBtaWxpdGFyeSBmb3JjZSwgbm90IHNwZWNpZmllZCIsIGRlc2NyaXB0aW9uPSJBbGwgdXNlcyBvZiBjb252ZW50aW9uYWwgZm9yY2UgYW5kIGFjdHMgb2Ygd2FyIHR5cGljYWxseSBieSBvcmdhbml6ZWQgYXJtZWQgZ3JvdXBzLCBub3Qgb3RoZXJ3aXNlIHNwZWNpZmllZC4iKV0KICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBub3QgaXNpbnN0YW5jZShkZXNjcmlwdGlvbiwgc3RyKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ2Rlc2NyaXB0aW9uJyBtdXN0IGJlIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShkZXNjcmlwdGlvbil9IikKCiAgICBpZiBkZXNjcmlwdGlvbiBpbiBkaWN0X3JlbGF0aW9uMmNvZGU6CiAgICAgICAgY29kZSA9IGRpY3RfcmVsYXRpb24yY29kZVtkZXNjcmlwdGlvbl0KICAgICAgICByZXR1cm4gW1JlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKGNvZGUpLCBuYW1lPWRpY3RfY29kZTJyZWxhdGlvbltjb2RlXVsnTmFtZSddLCBkZXNjcmlwdGlvbj1kaWN0X2NvZGUycmVsYXRpb25bY29kZV1bJ0Rlc2NyaXB0aW9uJ10pXQogICAgZWxzZToKICAgICAgICAjIGdldCB0b3AgNSBDQU1FTyBjb2RlcyB3aXRoIHRoZSBoaWdoZXN0IGNvc2luZSBzaW1pbGFyaXR5CiAgICAgICAgZGVzY3JpcHRpb25fZW1iZWRkaW5nID0gZ2V0X2VtYmVkZGluZyhkZXNjcmlwdGlvbikKICAgICAgICBzaW1pbGFyaXRpZXMgPSBjb3NpbmVfc2ltaWxhcml0eShyZWxhdGlvbl9lbWJlZGRpbmdzLCBkZXNjcmlwdGlvbl9lbWJlZGRpbmcpCiAgICAgICAgdG9wX2luZGljZXMgPSBucC5hcmdzb3J0KHNpbWlsYXJpdGllcylbOjotMV1bOjVdCiAgICAgICAgcmVsYXRpb25zID0gW10KICAgICAgICBmb3IgaWR4IGluIHRvcF9pbmRpY2VzOgogICAgICAgICAgICBjb2RlID0gbGlzdChkaWN0X2NvZGUycmVsYXRpb24ua2V5cygpKVtpZHhdCiAgICAgICAgICAgIHJlbGF0aW9ucy5hcHBlbmQoUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoY29kZSksIG5hbWU9ZGljdF9jb2RlMnJlbGF0aW9uW2NvZGVdWydOYW1lJ10sIGRlc2NyaXB0aW9uPWRpY3RfY29kZTJyZWxhdGlvbltjb2RlXVsnRGVzY3JpcHRpb24nXSkpCiAgICAgICAgcmV0dXJuIHJlbGF0aW9ucwoKZGVmIG1hcF9jYW1lb190b19yZWxhdGlvbihjYW1lb19jb2RlOiBDQU1FT0NvZGUpIC0+IFJlbGF0aW9uOgogICAgIiIiCiAgICBNYXBzIGEgQ0FNRU8gY29kZSB0byBhIHJlbGF0aW9uLCBpbmNsdWRpbmcgaXRzIG5hbWUgYW5kIGRlc2NyaXB0aW9uLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgY2FtZW9fY29kZSAoQ0FNRU9Db2RlKTogVGhlIENBTUVPIGNvZGUgdG8gbWFwLgoKICAgIFJldHVybnM6CiAgICAgICAgUmVsYXRpb246IFRoZSBjb3JyZXNwb25kaW5nIHJlbGF0aW9uLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IG1hcF9jYW1lb190b19yZWxhdGlvbihDQU1FT0NvZGUoIjE5MCIpKQogICAgICAgIFJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIxOTAiKSwgbmFtZT0iVXNlIGNvbnZlbnRpb25hbCBtaWxpdGFyeSBmb3JjZSwgbm90IHNwZWNpZmllZCIsIGRlc2NyaXB0aW9uPSJBbGwgdXNlcyBvZiBjb252ZW50aW9uYWwgZm9yY2UgYW5kIGFjdHMgb2Ygd2FyIHR5cGljYWxseSBieSBvcmdhbml6ZWQgYXJtZWQgZ3JvdXBzLCBub3Qgb3RoZXJ3aXNlIHNwZWNpZmllZC4iKQogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIG5vdCBpc2luc3RhbmNlKGNhbWVvX2NvZGUsIENBTUVPQ29kZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdjYW1lb19jb2RlJyBtdXN0IGJlIGEgQ0FNRU9Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY2FtZW9fY29kZSl9IikKCiAgICBpbmZvID0gZGljdF9jb2RlMnJlbGF0aW9uW2NhbWVvX2NvZGUuY29kZV0KICAgIHJldHVybiBSZWxhdGlvbihjYW1lb19jb2RlPWNhbWVvX2NvZGUsIG5hbWU9aW5mb1snTmFtZSddLCBkZXNjcmlwdGlvbj1pbmZvWydEZXNjcmlwdGlvbiddKQoKZGVmIGdldF9wYXJlbnRfcmVsYXRpb24oY2FtZW9fY29kZTogQ0FNRU9Db2RlKSAtPiBSZWxhdGlvbjoKICAgICIiIgogICAgUmV0cmlldmVzIHRoZSBwYXJlbnQgcmVsYXRpb24gb2YgYSBnaXZlbiByZWxhdGlvbiBpZGVudGlmaWVkIGJ5IENBTUVPIGNvZGUuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBjYW1lb19jb2RlIChDQU1FT0NvZGUpOiBUaGUgQ0FNRU8gY29kZSBvZiB0aGUgcmVsYXRpb24gd2hvc2UgcGFyZW50IGlzIHNvdWdodC4gT25seSBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zIGFyZSBhY2NlcHRlZC4KCiAgICBSZXR1cm5zOgogICAgICAgIFJlbGF0aW9uOiBUaGUgZmlyc3QgbGV2ZWwgcGFyZW50IHJlbGF0aW9uLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9wYXJlbnRfcmVsYXRpb24oQ0FNRU9Db2RlKCIxOTMiKSkKICAgICAgICBSZWxhdGlvbihjYW1lb19jb2RlPUNBTUVPQ29kZSgiMTkiKSwgbmFtZT0iRmlnaHQiLCBkZXNjcmlwdGlvbj0iQWxsIHVzZXMgb2YgY29udmVudGlvbmFsIGZvcmNlIGFuZCBhY3RzIG9mIHdhciB0eXBpY2FsbHkgYnkgb3JnYW5pemVkIGFybWVkIGdyb3Vwcy4iKQogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIG5vdCBpc2luc3RhbmNlKGNhbWVvX2NvZGUsIENBTUVPQ29kZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdjYW1lb19jb2RlJyBtdXN0IGJlIGEgQ0FNRU9Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY2FtZW9fY29kZSl9IikKCiAgICBpZiBsZW4oY2FtZW9fY29kZS5jb2RlKSAhPSAzOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoIk9ubHkgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyBhcmUgYWNjZXB0ZWQsIGJ1dCByZWNlaXZlZDoge30iLmZvcm1hdChjYW1lb19jb2RlLmNvZGUpKQogICAgcGFyZW50X2NvZGUgPWNhbWVvX2NvZGUuY29kZVs6Ml0KICAgIHJldHVybiBtYXBfY2FtZW9fdG9fcmVsYXRpb24oQ0FNRU9Db2RlKHBhcmVudF9jb2RlKSkKCmRlZiBnZXRfY2hpbGRfcmVsYXRpb25zKGNhbWVvX2NvZGU6IENBTUVPQ29kZSkgLT4gTGlzdFtSZWxhdGlvbl06CiAgICAiIiIKICAgIFJldHJpZXZlcyBjaGlsZCByZWxhdGlvbnMgb2YgYSBnaXZlbiByZWxhdGlvbiBpZGVudGlmaWVkIGJ5IENBTUVPIGNvZGUuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBjYW1lb19jb2RlIChDQU1FT0NvZGUpOiBUaGUgQ0FNRU8gY29kZSBvZiB0aGUgcmVsYXRpb24gd2hvc2UgY2hpbGRyZW4gYXJlIHNvdWdodC4gT25seSBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGFjY2VwdGVkLgoKICAgIFJldHVybnM6CiAgICAgICAgTGlzdFtSZWxhdGlvbl06IEEgbGlzdCBvZiBzZWNvbmQgbGV2ZWwgY2hpbGQgcmVsYXRpb25zLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9jaGlsZF9yZWxhdGlvbnMoQ0FNRU9Db2RlKCIxOSIpKQogICAgICAgIFtSZWxhdGlvbihjYWVtb19jb2RlPUNBTUVPQ29kZSgiMTkwIiksIG5hbWU9IlVzZSBjb252ZW50aW9uYWwgbWlsaXRhcnkgZm9yY2UsIG5vdCBzcGVjaWZpZWQiLCBkZXNjcmlwdGlvbj0iQWxsIHVzZXMgb2YgY29udmVudGlvbmFsIGZvcmNlIGFuZCBhY3RzIG9mIHdhciB0eXBpY2FsbHkgYnkgb3JnYW5pemVkIGFybWVkIGdyb3Vwcywgbm90IG90aGVyd2lzZSBzcGVjaWZpZWQuIiksIFJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIxOTEiKSwgbmFtZT0iSW1wb3NlIGJsb2NrYWRlIG9yIHJlc3RyaWN0IG1vdmVtZW50IiwgZGVzY3JpcHRpb249IlByZXZlbnQgZW50cnkgaW50byBhbmQvb3IgZXhpdCBmcm9tIGEgdGVycml0b3J5IHVzaW5nIGFybWVkIGZvcmNlcy4iKSwgLi4uXQogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIG5vdCBpc2luc3RhbmNlKGNhbWVvX2NvZGUsIENBTUVPQ29kZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdjYW1lb19jb2RlJyBtdXN0IGJlIGEgQ0FNRU9Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY2FtZW9fY29kZSl9IikKCiAgICBpZiBsZW4oY2FtZW9fY29kZS5jb2RlKSAhPSAyOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoIk9ubHkgZmlyc3QgbGV2ZWwgcmVsYXRpb25zIGFyZSBhY2NlcHRlZCwgYnV0IHJlY2VpdmVkOiB7fSIuZm9ybWF0KGNhbWVvX2NvZGUuY29kZSkpCiAgICBjaGlsZHJlbiA9IFtdCiAgICBmb3IgY29kZSwgaW5mbyBpbiBkaWN0X2NvZGUycmVsYXRpb24uaXRlbXMoKToKICAgICAgICBpZiBjb2RlWzoyXSA9PSBjYW1lb19jb2RlLmNvZGUgYW5kIGxlbihjb2RlKSA9PSAzOgogICAgICAgICAgICBjaGlsZHJlbi5hcHBlbmQoUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoY29kZSksIG5hbWU9aW5mb1snTmFtZSddLCBkZXNjcmlwdGlvbj1pbmZvWydEZXNjcmlwdGlvbiddKSkKICAgIHJldHVybiBjaGlsZHJlbgoKZGVmIGdldF9zaWJsaW5nX3JlbGF0aW9ucyhjYW1lb19jb2RlOiBDQU1FT0NvZGUpIC0+IExpc3RbUmVsYXRpb25dOgogICAgIiIiCiAgICBSZXRyaWV2ZXMgc2libGluZyByZWxhdGlvbnMgb2YgYSBnaXZlbiByZWxhdGlvbiBpZGVudGlmaWVkIGJ5IENBTUVPIGNvZGUuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBjYW1lb19jb2RlIChDQU1FT0NvZGUpOiBUaGUgQ0FNRU8gY29kZSBvZiB0aGUgcmVsYXRpb24gd2hvc2Ugc2libGluZ3MgYXJlIHNvdWdodC4gQm90aCBmaXJzdCBhbmQgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyBhcmUgYWNjZXB0ZWQuCgogICAgUmV0dXJuczoKICAgICAgICBMaXN0W1JlbGF0aW9uXTogQSBsaXN0IG9mIHNpYmxpbmcgcmVsYXRpb25zIGF0IHRoZSBzYW1lIGxldmVsLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9zaWJsaW5nX3JlbGF0aW9ucyhDQU1FT0NvZGUoIjE5MyIpKQogICAgICAgIFtSZWxhdGlvbihjYWVtb19jb2RlPUNBTUVPQ29kZSgiMTkwIiksIG5hbWU9IlVzZSBjb252ZW50aW9uYWwgbWlsaXRhcnkgZm9yY2UsIG5vdCBzcGVjaWZpZWQiLCBkZXNjcmlwdGlvbj0iQWxsIHVzZXMgb2YgY29udmVudGlvbmFsIGZvcmNlIGFuZCBhY3RzIG9mIHdhciB0eXBpY2FsbHkgYnkgb3JnYW5pemVkIGFybWVkIGdyb3Vwcywgbm90IG90aGVyd2lzZSBzcGVjaWZpZWQuIiksIFJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIxOTEiKSwgbmFtZT0iSW1wb3NlIGJsb2NrYWRlIG9yIHJlc3RyaWN0IG1vdmVtZW50IiwgZGVzY3JpcHRpb249IlByZXZlbnQgZW50cnkgaW50byBhbmQvb3IgZXhpdCBmcm9tIGEgdGVycml0b3J5IHVzaW5nIGFybWVkIGZvcmNlcy4iKSwgLi4uXQogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIG5vdCBpc2luc3RhbmNlKGNhbWVvX2NvZGUsIENBTUVPQ29kZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdjYW1lb19jb2RlJyBtdXN0IGJlIGEgQ0FNRU9Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY2FtZW9fY29kZSl9IikKCiAgICBpZiBsZW4oY2FtZW9fY29kZS5jb2RlKSA9PSAzOgogICAgICAgIHJldHVybiBnZXRfY2hpbGRfcmVsYXRpb25zKGdldF9wYXJlbnRfcmVsYXRpb24oY2FtZW9fY29kZSkuY2FtZW9fY29kZSkKICAgIGVsaWYgbGVuKGNhbWVvX2NvZGUuY29kZSkgPT0gMjoKICAgICAgICAjIGdldCAnMDEnIHRvICcyMCcgcmVsYXRpb25zCiAgICAgICAgZmlyc3RfbGV2ZWxfY29kZXMgPSBbc3RyKGkpLnpmaWxsKDIpIGZvciBpIGluIHJhbmdlKDEsIDIxKV0KICAgICAgICByZWxhdGlvbnMgPSBbXQogICAgICAgIGZvciBjb2RlIGluIGZpcnN0X2xldmVsX2NvZGVzOgogICAgICAgICAgICByZWxhdGlvbnMuYXBwZW5kKG1hcF9jYW1lb190b19yZWxhdGlvbihDQU1FT0NvZGUoY29kZSkpKQogICAgICAgIHJldHVybiByZWxhdGlvbnMKCmRlZiBjb3VudF9ldmVudHMoZGF0ZV9yYW5nZTogT3B0aW9uYWxbRGF0ZVJhbmdlXSA9IE5vbmUsIGhlYWRfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgdGFpbF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lLCByZWxhdGlvbnM6IE9wdGlvbmFsW0xpc3RbQ0FNRU9Db2RlXV0gPSBOb25lKSAtPiBpbnQ6CiAgICAiIiIKICAgIENvdW50cyB0aGUgbnVtYmVyIG9mIGV2ZW50cyBpbiB0aGUga25vd2xlZGdlIGdyYXBoIGJhc2VkIG9uIHNwZWNpZmllZCBjb25kaXRpb25zLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgZGF0ZV9yYW5nZSAoT3B0aW9uYWxbRGF0ZVJhbmdlXSk6IFJhbmdlIG9mIGRhdGVzIHRvIGZpbHRlciB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGhlYWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiBoZWFkIGVudGl0eSBJU08gY29kZXMgdG8gYmUgaW5jbHVkZWQuIElmIE5vbmUsIGFsbCBjb3VudHJpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHRhaWxfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiB0YWlsIGVudGl0eSBJU08gY29kZXMgdG8gYmUgaW5jbHVkZWQuIElmIE5vbmUsIGFsbCBjb3VudHJpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHJlbGF0aW9ucyAoT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSk6IExpc3Qgb2YgcmVsYXRpb24gQ0FNRU8gY29kZXMgdG8gYmUgaW5jbHVkZWQuIElmIGZpcnN0IGxldmVsIHJlbGF0aW9ucyBhcmUgbGlzdGVkLCBhbGwgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyB1bmRlciB0aGVtIGFyZSBpbmNsdWRlZC4gSWYgTm9uZSwgYWxsIHJlbGF0aW9ucyBhcmUgaW5jbHVkZWQuCgogICAgUmV0dXJuczoKICAgICAgICBpbnQ6IENvdW50IG9mIHVuaXF1ZSBldmVudHMgbWF0Y2hpbmcgdGhlIGNvbmRpdGlvbnMuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gY291bnRfZXZlbnRzKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBoZWFkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCB0YWlsX2VudGl0aWVzPU5vbmUsIHJlbGF0aW9ucz1bQ0FNRU9Db2RlKCIwMTAiKV0pCiAgICAgICAgNAogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIGRhdGVfcmFuZ2UgYW5kIG5vdCBpc2luc3RhbmNlKGRhdGVfcmFuZ2UsIERhdGVSYW5nZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdkYXRlX3JhbmdlJyBtdXN0IGJlIGEgRGF0ZVJhbmdlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoZGF0ZV9yYW5nZSl9IikKICAgIGlmIGhlYWRfZW50aXRpZXMgYW5kIG5vdCBpc2luc3RhbmNlKGhlYWRfZW50aXRpZXMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAnaGVhZF9lbnRpdGllcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGhlYWRfZW50aXRpZXMpfSIpCiAgICBpZiBoZWFkX2VudGl0aWVzIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoaXNvLCBJU09Db2RlKSBmb3IgaXNvIGluIGhlYWRfZW50aXRpZXMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAnaGVhZF9lbnRpdGllcycgbXVzdCBiZSBJU09Db2RlIG9iamVjdHMiKQogICAgaWYgdGFpbF9lbnRpdGllcyBhbmQgbm90IGlzaW5zdGFuY2UodGFpbF9lbnRpdGllcywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICd0YWlsX2VudGl0aWVzJyBtdXN0IGJlIGEgbGlzdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUodGFpbF9lbnRpdGllcyl9IikKICAgIGlmIHRhaWxfZW50aXRpZXMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShpc28sIElTT0NvZGUpIGZvciBpc28gaW4gdGFpbF9lbnRpdGllcyk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkVsZW1lbnRzIGluICd0YWlsX2VudGl0aWVzJyBtdXN0IGJlIElTT0NvZGUgb2JqZWN0cyIpCiAgICBpZiByZWxhdGlvbnMgYW5kIG5vdCBpc2luc3RhbmNlKHJlbGF0aW9ucywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdyZWxhdGlvbnMnIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShyZWxhdGlvbnMpfSIpCiAgICBpZiByZWxhdGlvbnMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShjb2RlLCBDQU1FT0NvZGUpIGZvciBjb2RlIGluIHJlbGF0aW9ucyk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkVsZW1lbnRzIGluICdyZWxhdGlvbnMnIG11c3QgYmUgQ0FNRU9Db2RlIG9iamVjdHMiKQoKICAgICMgcHJvY2VzcyBkYXRhX2tnIGJ5IGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbnMKICAgIGN1cnJfZGF0YSA9IGRhdGFfa2cuY29weSgpCiAgICBjdXJyX2RhdGEuZHJvcF9kdXBsaWNhdGVzKHN1YnNldD1bJ1F1YWRFdmVudENvZGUnXSwgaW5wbGFjZT1UcnVlKQogICAgY3Vycl9kYXRhID0gY3Vycl9kYXRhW2N1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IERFRkFVTFRfRU5EX0RBVEVdCiAgICBpZiBkYXRlX3JhbmdlOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVsoY3Vycl9kYXRhWydEYXRlU3RyJ10gPj0gZGF0ZV9yYW5nZS5zdGFydF9kYXRlLmRhdGUpICYgKGN1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IGRhdGVfcmFuZ2UuZW5kX2RhdGUuZGF0ZSldCiAgICBpZiBoZWFkX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMUNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzXSldCiAgICBpZiB0YWlsX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiB0YWlsX2VudGl0aWVzXSldCiAgICBpZiByZWxhdGlvbnM6CiAgICAgICAgIyBpZiBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGxpc3RlZCwgaW5jbHVkZSBhbGwgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyB1bmRlciB0aGVtCiAgICAgICAgZm9yIGNvZGUgaW4gcmVsYXRpb25zOgogICAgICAgICAgICBpZiBsZW4oY29kZS5jb2RlKSA9PSAyOgogICAgICAgICAgICAgICAgcmVsYXRpb25zLmV4dGVuZChbQ0FNRU9Db2RlKGMpIGZvciBjIGluIGRpY3RfY29kZTJyZWxhdGlvbiBpZiBjWzoyXSA9PSBjb2RlLmNvZGUgYW5kIGxlbihjKSA9PSAzXSkKICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydFdmVudEJhc2VDb2RlJ10uaXNpbihbY29kZS5jb2RlIGZvciBjb2RlIGluIHJlbGF0aW9uc10pXQogICAgcmV0dXJuIGxlbihjdXJyX2RhdGEpCgpkZWYgZ2V0X2V2ZW50cyhkYXRlX3JhbmdlOiBPcHRpb25hbFtEYXRlUmFuZ2VdID0gTm9uZSwgaGVhZF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lLCB0YWlsX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUsIHJlbGF0aW9uczogT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSA9IE5vbmUsIHRleHRfZGVzY3JpcHRpb246IE9wdGlvbmFsW3N0cl0gPSBOb25lKSAtPiBMaXN0W0V2ZW50XToKICAgICIiIgogICAgUmV0cmlldmVzIGV2ZW50cyBmcm9tIHRoZSBrbm93bGVkZ2UgZ3JhcGggYmFzZWQgb24gc3BlY2lmaWVkIGNvbmRpdGlvbnMuCiAgICBJbmhlcml0cyBjb21tb24gZmlsdGVyIHBhcmFtZXRlcnMgZnJvbSBjb3VudF9ldmVudHMuIFNlZSBjb3VudF9ldmVudHMgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGVzZSBwYXJhbWV0ZXJzLgoKICAgIEFkZGl0aW9uYWwgUGFyYW1ldGVyczoKICAgICAgICB0ZXh0X2Rlc2NyaXB0aW9uIChPcHRpb25hbFtzdHJdKTogVGV4dHVhbCBkZXNjcmlwdGlvbiB0byBtYXRjaCB3aXRoIHRoZSBzb3VyY2UgbmV3cyBhcnRpY2xlcyBvZiBldmVudHMuIElmIE5vbmUsIHRoZSByZXR1cm5lZCBldmVudHMgYXJlIHNvcnRlZCBieSBkYXRlIGluIGRlc2NlbmRpbmcgb3JkZXI7IG90aGVyd2lzZSwgc29ydGVkIGJ5IHJlbGV2YW5jZSBvZiB0aGUgc291cmNlIG5ld3MgYXJ0aWNsZSB0byB0aGUgZGVzY3JpcHRpb24uCgogICAgUmV0dXJuczoKICAgICAgICBMaXN0W0V2ZW50XTogQSBsaXN0IG9mIG1heGltdW0gMzAgZXZlbnRzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucy4KCiAgICBFeGFtcGxlOgogICAgICAgID4+PiBnZXRfZXZlbnRzKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBoZWFkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCB0YWlsX2VudGl0aWVzPU5vbmUsIHJlbGF0aW9ucz1bQ0FNRU9Db2RlKCIwMTAiKV0sIHRleHRfZGVzY3JpcHRpb249ImVjb25vbWljIHRyYWRlIikKICAgICAgICBbRXZlbnQoZGF0ZT1EYXRlKCIyMDIyLTAxLTE1IiksIGhlYWRfZW50aXR5PUlTT0NvZGUoIlVTQSIpLCByZWxhdGlvbj1DQU1FT0NvZGUoIjAxMCIpLCB0YWlsX2VudGl0eT1JU09Db2RlKCJDQU4iKSwgRXZlbnQoZGF0ZT1EYXRlKCIyMDIyLTAxLTEwIiksIGhlYWRfZW50aXR5PUlTT0NvZGUoIkNITiIpLCByZWxhdGlvbj1DQU1FT0NvZGUoIjAxMCIpLCB0YWlsX2VudGl0eT1JU09Db2RlKCJVU0EiKSwgLi4uXQogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIGRhdGVfcmFuZ2UgYW5kIG5vdCBpc2luc3RhbmNlKGRhdGVfcmFuZ2UsIERhdGVSYW5nZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdkYXRlX3JhbmdlJyBtdXN0IGJlIGEgRGF0ZVJhbmdlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoZGF0ZV9yYW5nZSl9IikKICAgIGlmIGhlYWRfZW50aXRpZXMgYW5kIG5vdCBpc2luc3RhbmNlKGhlYWRfZW50aXRpZXMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAnaGVhZF9lbnRpdGllcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGhlYWRfZW50aXRpZXMpfSIpCiAgICBpZiBoZWFkX2VudGl0aWVzIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoaXNvLCBJU09Db2RlKSBmb3IgaXNvIGluIGhlYWRfZW50aXRpZXMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAnaGVhZF9lbnRpdGllcycgbXVzdCBiZSBJU09Db2RlIG9iamVjdHMiKQogICAgaWYgdGFpbF9lbnRpdGllcyBhbmQgbm90IGlzaW5zdGFuY2UodGFpbF9lbnRpdGllcywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICd0YWlsX2VudGl0aWVzJyBtdXN0IGJlIGEgbGlzdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUodGFpbF9lbnRpdGllcyl9IikKICAgIGlmIHRhaWxfZW50aXRpZXMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShpc28sIElTT0NvZGUpIGZvciBpc28gaW4gdGFpbF9lbnRpdGllcyk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkVsZW1lbnRzIGluICd0YWlsX2VudGl0aWVzJyBtdXN0IGJlIElTT0NvZGUgb2JqZWN0cyIpCiAgICBpZiByZWxhdGlvbnMgYW5kIG5vdCBpc2luc3RhbmNlKHJlbGF0aW9ucywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdyZWxhdGlvbnMnIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShyZWxhdGlvbnMpfSIpCiAgICBpZiByZWxhdGlvbnMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShjb2RlLCBDQU1FT0NvZGUpIGZvciBjb2RlIGluIHJlbGF0aW9ucyk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkVsZW1lbnRzIGluICdyZWxhdGlvbnMnIG11c3QgYmUgQ0FNRU9Db2RlIG9iamVjdHMiKQogICAgaWYgdGV4dF9kZXNjcmlwdGlvbiBhbmQgbm90IGlzaW5zdGFuY2UodGV4dF9kZXNjcmlwdGlvbiwgc3RyKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ3RleHRfZGVzY3JpcHRpb24nIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKHRleHRfZGVzY3JpcHRpb24pfSIpCgogICAgIyBwcm9jZXNzIGRhdGFfa2cgYnkgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucwogICAgY3Vycl9kYXRhID0gZGF0YV9rZy5jb3B5KCkKICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0RhdGVTdHInXSA8PSBERUZBVUxUX0VORF9EQVRFXQogICAgaWYgZGF0ZV9yYW5nZToKICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbKGN1cnJfZGF0YVsnRGF0ZVN0ciddID49IGRhdGVfcmFuZ2Uuc3RhcnRfZGF0ZS5kYXRlKSAmIChjdXJyX2RhdGFbJ0RhdGVTdHInXSA8PSBkYXRlX3JhbmdlLmVuZF9kYXRlLmRhdGUpXQogICAgaWYgaGVhZF9lbnRpdGllczoKICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydBY3RvcjFDb3VudHJ5Q29kZSddLmlzaW4oW2lzby5jb2RlIGZvciBpc28gaW4gaGVhZF9lbnRpdGllc10pXQogICAgaWYgdGFpbF9lbnRpdGllczoKICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydBY3RvcjJDb3VudHJ5Q29kZSddLmlzaW4oW2lzby5jb2RlIGZvciBpc28gaW4gdGFpbF9lbnRpdGllc10pXQogICAgaWYgcmVsYXRpb25zOgogICAgICAgICMgaWYgZmlyc3QgbGV2ZWwgcmVsYXRpb25zIGFyZSBsaXN0ZWQsIGluY2x1ZGUgYWxsIHNlY29uZCBsZXZlbCByZWxhdGlvbnMgdW5kZXIgdGhlbQogICAgICAgIGZvciBjb2RlIGluIHJlbGF0aW9uczoKICAgICAgICAgICAgaWYgbGVuKGNvZGUuY29kZSkgPT0gMjoKICAgICAgICAgICAgICAgIHJlbGF0aW9ucy5leHRlbmQoW0NBTUVPQ29kZShjKSBmb3IgYyBpbiBkaWN0X2NvZGUycmVsYXRpb24gaWYgY1s6Ml0gPT0gY29kZS5jb2RlIGFuZCBsZW4oYykgPT0gM10pCiAgICAgICAgY3Vycl9kYXRhID0gY3Vycl9kYXRhW2N1cnJfZGF0YVsnRXZlbnRCYXNlQ29kZSddLmlzaW4oW2NvZGUuY29kZSBmb3IgY29kZSBpbiByZWxhdGlvbnNdKV0KICAgIGlmIG5vdCB0ZXh0X2Rlc2NyaXB0aW9uOgogICAgICAgICMgZ2V0IG1heCAzMCBldmVudHMgZnJvbSB0aGUgZmlsdGVyZWQgZGF0YQogICAgICAgIGV2ZW50cyA9IFtdCiAgICAgICAgY3Vycl9kYXRhLmRyb3BfZHVwbGljYXRlcyhzdWJzZXQ9WydRdWFkRXZlbnRDb2RlJ10sIGlucGxhY2U9VHJ1ZSkKICAgICAgICAjIHNvcnRlZCBieSBkYXRlIGluIGRlc2NlbmRpbmcgb3JkZXIKICAgICAgICBjdXJyX2RhdGEuc29ydF92YWx1ZXMoYnk9J0RhdGVTdHInLCBhc2NlbmRpbmc9RmFsc2UsIGlucGxhY2U9VHJ1ZSkKICAgICAgICBjb3VudCA9IDAKICAgICAgICBmb3IgXywgcm93IGluIGN1cnJfZGF0YS5pdGVycm93cygpOgogICAgICAgICAgICBpZiBjb3VudCA+PSAzMDoKICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgIGV2ZW50cy5hcHBlbmQoRXZlbnQoZGF0ZT1EYXRlKHJvd1snRGF0ZVN0ciddKSwgaGVhZF9lbnRpdHk9SVNPQ29kZShyb3dbJ0FjdG9yMUNvdW50cnlDb2RlJ10pLCByZWxhdGlvbj1DQU1FT0NvZGUocm93WydFdmVudEJhc2VDb2RlJ10pLCB0YWlsX2VudGl0eT1JU09Db2RlKHJvd1snQWN0b3IyQ291bnRyeUNvZGUnXSkpKQogICAgICAgIHJldHVybiBldmVudHNbOjMwXQogICAgZWxzZToKICAgICAgICAjIGNvbmNhdCB0aGUgRG9jaWRzIGxpc3Qgb2YgY3VycmVudCBkYXRhIHRvIGdldCB0aGUgbmV3cyBhcnRpY2xlcwogICAgICAgIGRvY2lkc19saXN0ID0gW2V2YWwoZG9jaWRzKSBmb3IgZG9jaWRzIGluIGN1cnJfZGF0YVsnRG9jaWRzJ10udW5pcXVlKCkudG9saXN0KCldCiAgICAgICAgZG9jaWRzID0gbGlzdChzZXQoW2l0ZW0gZm9yIHN1Ymxpc3QgaW4gZG9jaWRzX2xpc3QgZm9yIGl0ZW0gaW4gc3VibGlzdF0pKQogICAgICAgIGRvY2lkcyA9IFtzdHIoZG9jaWQpIGZvciBkb2NpZCBpbiBkb2NpZHNdCiAgICAgICAgbmV3c19hcnRpY2xlcyA9IGRhdGFfbmV3c1tkYXRhX25ld3NbJ0RvY2lkJ10uaXNpbihkb2NpZHMpXQogICAgICAgICMgZ2V0IHRoZSBtYXggMzAgZG9jaWRzIHdpdGggdGhlIGhpZ2hlc3QgQk0yNSBzY29yZSB0byB0aGUgdGV4dF9kZXNjcmlwdGlvbgogICAgICAgIGNvcnB1cyA9IG5ld3NfYXJ0aWNsZXNbJ1RpdGxlJ10gKyAnICcgKyBuZXdzX2FydGljbGVzWydUZXh0J10KICAgICAgICB0b2tlbml6ZWRfY29ycHVzID0gW2RvYy5zcGxpdCgiICIpIGZvciBkb2MgaW4gY29ycHVzXQogICAgICAgIGJtMjUgPSBCTTI1T2thcGkodG9rZW5pemVkX2NvcnB1cykKICAgICAgICB0b2tlbml6ZWRfcXVlcnkgPSB0ZXh0X2Rlc2NyaXB0aW9uLnNwbGl0KCIgIikKICAgICAgICBkb2Nfc2NvcmVzID0gYm0yNS5nZXRfc2NvcmVzKHRva2VuaXplZF9xdWVyeSkKICAgICAgICB0b3BfaW5kaWNlcyA9IG5wLmFyZ3NvcnQoZG9jX3Njb3JlcylbOjotMV1bOjMwXQogICAgICAgIG5ld3NfYXJ0aWNsZXMgPSBuZXdzX2FydGljbGVzLmlsb2NbdG9wX2luZGljZXNdCiAgICAgICAgZG9jaWRzID0gbmV3c19hcnRpY2xlc1snRG9jaWQnXS50b2xpc3QoKQogICAgICAgICMgZ2V0IG1heCAzMCBldmVudHMgZnJvbSB0aGUgZmlsdGVyZWQgZGF0YQogICAgICAgIGV2ZW50cyA9IHNldCgpCiAgICAgICAgZm9yIGRvY2lkIGluIGRvY2lkczoKICAgICAgICAgICAgaWYgbGVuKGV2ZW50cykgPj0gMzA6CiAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICBkb2NfY3Vycl9kYXRhID0gY3Vycl9kYXRhW2N1cnJfZGF0YVsnRG9jaWQnXSA9PSBkb2NpZF0KICAgICAgICAgICAgIyByZXZlcnNlIHRoZSBvcmRlciBvZiB0aGUgZXZlbnRzIHRvIGdldCB0aGUgbGF0ZXN0IGV2ZW50cyBmaXJzdAogICAgICAgICAgICBkb2NfY3Vycl9kYXRhID0gZG9jX2N1cnJfZGF0YS5zb3J0X3ZhbHVlcyhieT0nRGF0ZVN0cicsIGFzY2VuZGluZz1GYWxzZSkKICAgICAgICAgICAgZm9yIF8sIHJvdyBpbiBkb2NfY3Vycl9kYXRhLml0ZXJyb3dzKCk6CiAgICAgICAgICAgICAgICBldmVudHMuYWRkKEV2ZW50KGRhdGU9RGF0ZShyb3dbJ0RhdGVTdHInXSksIGhlYWRfZW50aXR5PUlTT0NvZGUocm93WydBY3RvcjFDb3VudHJ5Q29kZSddKSwgcmVsYXRpb249Q0FNRU9Db2RlKHJvd1snRXZlbnRCYXNlQ29kZSddKSwgdGFpbF9lbnRpdHk9SVNPQ29kZShyb3dbJ0FjdG9yMkNvdW50cnlDb2RlJ10pKSkKICAgICAgICByZXR1cm4gbGlzdChldmVudHMpCgpkZWYgZ2V0X2VudGl0eV9kaXN0cmlidXRpb24oZGF0ZV9yYW5nZTogT3B0aW9uYWxbRGF0ZVJhbmdlXSA9IE5vbmUsIGludm9sdmVkX3JlbGF0aW9uczogT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSA9IE5vbmUsIGludGVyYWN0ZWRfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgZW50aXR5X3JvbGU6IE9wdGlvbmFsW3N0cl0gPSBOb25lKSAtPiBEaWN0W0lTT0NvZGUsIGludF06CiAgICAiIiIKICAgIEdldHMgdGhlIGRpc3RyaWJ1dGlvbiBvZiBlbnRpdGllcyBpbiB0aGUga25vd2xlZGdlIGdyYXBoIHVuZGVyIHNwZWNpZmllZCBjb25kaXRpb25zLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgZGF0ZV9yYW5nZSAoT3B0aW9uYWxbRGF0ZVJhbmdlXSk6IFJhbmdlIG9mIGRhdGVzIHRvIGZpbHRlciB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGludm9sdmVkX3JlbGF0aW9ucyAoT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSk6IExpc3Qgb2YgcmVsYXRpb25zIHRoYXQgdGhlIHJldHVybmVkIGVudGl0aWVzIG11c3QgYmUgaW52b2x2ZWQgaW4gYW55IG9mLiBJZiBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGxpc3RlZCwgYWxsIHNlY29uZCBsZXZlbCByZWxhdGlvbnMgdW5kZXIgdGhlbSBhcmUgaW5jbHVkZWQuIElmIE5vbmUsIGFsbCByZWxhdGlvbnMgYXJlIGluY2x1ZGVkLgogICAgICAgIGludGVyYWN0ZWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiBlbnRpdGllcyB0aGF0IHRoZSByZXR1cm5lZCBlbnRpdGllcyBtdXN0IGhhdmUgaW50ZXJhY3RlZCB3aXRoIGFueSBvZi4gSWYgTm9uZSwgYWxsIGVudGl0aWVzIGFyZSBpbmNsdWRlZC4KICAgICAgICBlbnRpdHlfcm9sZSAoT3B0aW9uYWxbRW50aXR5Um9sZV0pOiBTcGVjaWZpZXMgdGhlIHJvbGUgb2YgdGhlIHJldHVybmVkIGVudGl0eSBpbiB0aGUgZXZlbnRzLiBPcHRpb25zIGFyZSAnaGVhZCcsICd0YWlsJywgb3IgJ2JvdGgnLiBJZiAnYm90aCcgb3IgTm9uZSwgdGhlIHJldHVybmVkIGVudGl0eSBjYW4gYmUgZWl0aGVyIGhlYWQgb3IgdGFpbC4KCiAgICBSZXR1cm5zOgogICAgICAgIERpY3RbSVNPQ29kZSwgaW50XTogQSBkaWN0aW9uYXJ5IG1hcHBpbmcgcmV0dXJuZWQgZW50aXRpZXMnIElTTyBjb2RlcyB0byB0aGUgbnVtYmVyIG9mIGV2ZW50cyB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucyBpbiB3aGljaCB0aGV5IGFyZSBpbnZvbHZlZCwgc29ydGVkIGJ5IGNvdW50cyBpbiBkZXNjZW5kaW5nIG9yZGVyLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9lbnRpdHlfZGlzdHJpYnV0aW9uKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBpbnZvbHZlZF9yZWxhdGlvbnM9W0NBTUVPQ29kZSgiMDEwIildLCBpbnRlcmFjdGVkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCBlbnRpdHlfcm9sZT0idGFpbCIpCiAgICAgICAge0lTT0NvZGUoIlVTQSIpOiAzLCBJU09Db2RlKCJDSE4iKTogMX0KICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBkYXRlX3JhbmdlIGFuZCBub3QgaXNpbnN0YW5jZShkYXRlX3JhbmdlLCBEYXRlUmFuZ2UpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAnZGF0ZV9yYW5nZScgbXVzdCBiZSBhIERhdGVSYW5nZSBvYmplY3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGRhdGVfcmFuZ2UpfSIpCiAgICBpZiBpbnZvbHZlZF9yZWxhdGlvbnMgYW5kIG5vdCBpc2luc3RhbmNlKGludm9sdmVkX3JlbGF0aW9ucywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdpbnZvbHZlZF9yZWxhdGlvbnMnIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShpbnZvbHZlZF9yZWxhdGlvbnMpfSIpCiAgICBpZiBpbnZvbHZlZF9yZWxhdGlvbnMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShjb2RlLCBDQU1FT0NvZGUpIGZvciBjb2RlIGluIGludm9sdmVkX3JlbGF0aW9ucyk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkVsZW1lbnRzIGluICdpbnZvbHZlZF9yZWxhdGlvbnMnIG11c3QgYmUgQ0FNRU9Db2RlIG9iamVjdHMiKQogICAgaWYgaW50ZXJhY3RlZF9lbnRpdGllcyBhbmQgbm90IGlzaW5zdGFuY2UoaW50ZXJhY3RlZF9lbnRpdGllcywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdpbnRlcmFjdGVkX2VudGl0aWVzJyBtdXN0IGJlIGEgbGlzdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoaW50ZXJhY3RlZF9lbnRpdGllcyl9IikKICAgIGlmIGludGVyYWN0ZWRfZW50aXRpZXMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShpc28sIElTT0NvZGUpIGZvciBpc28gaW4gaW50ZXJhY3RlZF9lbnRpdGllcyk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkVsZW1lbnRzIGluICdpbnRlcmFjdGVkX2VudGl0aWVzJyBtdXN0IGJlIElTT0NvZGUgb2JqZWN0cyIpCiAgICBpZiBlbnRpdHlfcm9sZSBhbmQgZW50aXR5X3JvbGUgbm90IGluIFsnaGVhZCcsICd0YWlsJywgJ2JvdGgnXToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ2VudGl0eV9yb2xlJyBtdXN0IGJlIGEgc3RyaW5nICdoZWFkJywgJ3RhaWwnLCBvciAnYm90aCcsIGJ1dCByZWNlaXZlZDoge2VudGl0eV9yb2xlfSIpCgogICAgIyBwcm9jZXNzIGRhdGFfa2cgYnkgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucwogICAgY3Vycl9kYXRhID0gZGF0YV9rZy5jb3B5KCkKICAgIGN1cnJfZGF0YS5kcm9wX2R1cGxpY2F0ZXMoc3Vic2V0PVsnUXVhZEV2ZW50Q29kZSddLCBpbnBsYWNlPVRydWUpCiAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydEYXRlU3RyJ10gPD0gREVGQVVMVF9FTkRfREFURV0KICAgIGlmIGRhdGVfcmFuZ2U6CiAgICAgICAgY3Vycl9kYXRhID0gY3Vycl9kYXRhWyhjdXJyX2RhdGFbJ0RhdGVTdHInXSA+PSBkYXRlX3JhbmdlLnN0YXJ0X2RhdGUuZGF0ZSkgJiAoY3Vycl9kYXRhWydEYXRlU3RyJ10gPD0gZGF0ZV9yYW5nZS5lbmRfZGF0ZS5kYXRlKV0KICAgIGlmIGludm9sdmVkX3JlbGF0aW9uczoKICAgICAgICAjIGlmIGZpcnN0IGxldmVsIHJlbGF0aW9ucyBhcmUgbGlzdGVkLCBpbmNsdWRlIGFsbCBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zIHVuZGVyIHRoZW0KICAgICAgICBmb3IgY29kZSBpbiBpbnZvbHZlZF9yZWxhdGlvbnM6CiAgICAgICAgICAgIGlmIGxlbihjb2RlLmNvZGUpID09IDI6CiAgICAgICAgICAgICAgICBpbnZvbHZlZF9yZWxhdGlvbnMuZXh0ZW5kKFtDQU1FT0NvZGUoYykgZm9yIGMgaW4gZGljdF9jb2RlMnJlbGF0aW9uIGlmIGNbOjJdID09IGNvZGUuY29kZSBhbmQgbGVuKGMpID09IDNdKQogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0V2ZW50QmFzZUNvZGUnXS5pc2luKFtjb2RlLmNvZGUgZm9yIGNvZGUgaW4gaW52b2x2ZWRfcmVsYXRpb25zXSldCiAgICBpZiBpbnRlcmFjdGVkX2VudGl0aWVzOgogICAgICAgIGlmIGVudGl0eV9yb2xlPT0naGVhZCc6CiAgICAgICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiBpbnRlcmFjdGVkX2VudGl0aWVzXSldCiAgICAgICAgZWxpZiBlbnRpdHlfcm9sZT09J3RhaWwnOgogICAgICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydBY3RvcjFDb3VudHJ5Q29kZSddLmlzaW4oW2lzby5jb2RlIGZvciBpc28gaW4gaW50ZXJhY3RlZF9lbnRpdGllc10pXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVsoY3Vycl9kYXRhWydBY3RvcjFDb3VudHJ5Q29kZSddLmlzaW4oW2lzby5jb2RlIGZvciBpc28gaW4gaW50ZXJhY3RlZF9lbnRpdGllc10pKSB8IChjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiBpbnRlcmFjdGVkX2VudGl0aWVzXSkpXQogICAgIyBjb3VudCB0aGUgbnVtYmVyIG9mIGV2ZW50cyBmb3IgZWFjaCBlbnRpdHkKICAgIGVudGl0eV9jb3VudHMgPSBjdXJyX2RhdGFbJ0FjdG9yMUNvdW50cnlDb2RlJ10uX2FwcGVuZChjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10pLnZhbHVlX2NvdW50cygpCiAgICBlbnRpdHlfY291bnRzID0gZW50aXR5X2NvdW50cy50b19kaWN0KCkKICAgICMgc29ydCB0aGUgZGljdGlvbmFyeSBieSB2YWx1ZXMgaW4gZGVzY2VuZGluZyBvcmRlcgogICAgZW50aXR5X2NvdW50cyA9IGRpY3Qoc29ydGVkKGVudGl0eV9jb3VudHMuaXRlbXMoKSwga2V5PWxhbWJkYSBpdGVtOiBpdGVtWzFdLCByZXZlcnNlPVRydWUpKQogICAgZW50aXR5X2NvdW50cyA9IHtJU09Db2RlKGtleSk6IHZhbHVlIGZvciBrZXksIHZhbHVlIGluIGVudGl0eV9jb3VudHMuaXRlbXMoKX0KICAgIHJldHVybiBlbnRpdHlfY291bnRzCgpkZWYgZ2V0X3JlbGF0aW9uX2Rpc3RyaWJ1dGlvbihkYXRlX3JhbmdlOiBPcHRpb25hbFtEYXRlUmFuZ2VdID0gTm9uZSwgaGVhZF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lLCB0YWlsX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUpIC0+IERpY3RbQ0FNRU9Db2RlLCBpbnRdOgogICAgIiIiCiAgICBHZXRzIHRoZSBkaXN0cmlidXRpb24gb2Ygc2Vjb25kIGxldmVsIHJlbGF0aW9ucyBpbiB0aGUga25vd2xlZGdlIGdyYXBoIHVuZGVyIHNwZWNpZmllZCBjb25kaXRpb25zLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgZGF0ZV9yYW5nZSAoT3B0aW9uYWxbRGF0ZVJhbmdlXSk6IFJhbmdlIG9mIGRhdGVzIHRvIGZpbHRlciB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGhlYWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiBoZWFkIGVudGl0aWVzIHRoYXQgdGhlIGV2ZW50cyBtdXN0IGludm9sdmUgYW55IG9mLiBJZiBOb25lLCBhbGwgaGVhZCBlbnRpdGllcyBhcmUgaW5jbHVkZWQuCiAgICAgICAgdGFpbF9lbnRpdGllcyAoT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0pOiBMaXN0IG9mIHRhaWwgZW50aXRpZXMgdGhhdCB0aGUgZXZlbnRzIG11c3QgaW52b2x2ZSBhbnkgb2YuIElmIE5vbmUsIGFsbCB0YWlsIGVudGl0aWVzIGFyZSBpbmNsdWRlZC4KCiAgICBSZXR1cm5zOgogICAgICAgIERpY3RbQ0FNRU9Db2RlLCBpbnRdOiBBIGRpY3Rpb25hcnkgbWFwcGluZyBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zJyBDQU1FTyBjb2RlcyB0byB0aGUgbnVtYmVyIG9mIGV2ZW50cyB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucyBpbiB3aGljaCB0aGV5IGFyZSBpbnZvbHZlZCwgc29ydGVkIGJ5IGNvdW50cyBpbiBkZXNjZW5kaW5nIG9yZGVyLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9yZWxhdGlvbl9kaXN0cmlidXRpb24oZGF0ZV9yYW5nZT1EYXRlUmFuZ2Uoc3RhcnRfZGF0ZT1EYXRlKCIyMDIyLTAxLTAxIiksIGVuZF9kYXRlPURhdGUoIjIwMjItMDEtMzEiKSksIGhlYWRfZW50aXRpZXM9W0lTT0NvZGUoIlVTQSIpLCBJU09Db2RlKCJDSE4iKV0sIHRhaWxfZW50aXRpZXM9Tm9uZSkKICAgICAgICB7Q0FNRU9Db2RlKCIwMTAiKTogMywgQ0FNRU9Db2RlKCIwMTEiKTogMX0KICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBkYXRlX3JhbmdlIGFuZCBub3QgaXNpbnN0YW5jZShkYXRlX3JhbmdlLCBEYXRlUmFuZ2UpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAnZGF0ZV9yYW5nZScgbXVzdCBiZSBhIERhdGVSYW5nZSBvYmplY3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGRhdGVfcmFuZ2UpfSIpCiAgICBpZiBoZWFkX2VudGl0aWVzIGFuZCBub3QgaXNpbnN0YW5jZShoZWFkX2VudGl0aWVzLCBsaXN0KToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ2hlYWRfZW50aXRpZXMnIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShoZWFkX2VudGl0aWVzKX0iKQogICAgaWYgaGVhZF9lbnRpdGllcyBhbmQgbm90IGFsbChpc2luc3RhbmNlKGlzbywgSVNPQ29kZSkgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiRWxlbWVudHMgaW4gJ2hlYWRfZW50aXRpZXMnIG11c3QgYmUgSVNPQ29kZSBvYmplY3RzIikKICAgIGlmIHRhaWxfZW50aXRpZXMgYW5kIG5vdCBpc2luc3RhbmNlKHRhaWxfZW50aXRpZXMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAndGFpbF9lbnRpdGllcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKHRhaWxfZW50aXRpZXMpfSIpCiAgICBpZiB0YWlsX2VudGl0aWVzIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoaXNvLCBJU09Db2RlKSBmb3IgaXNvIGluIHRhaWxfZW50aXRpZXMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAndGFpbF9lbnRpdGllcycgbXVzdCBiZSBJU09Db2RlIG9iamVjdHMiKQoKICAgICMgcHJvY2VzcyBkYXRhX2tnIGJ5IGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbnMKICAgIGN1cnJfZGF0YSA9IGRhdGFfa2cuY29weSgpCiAgICBjdXJyX2RhdGEuZHJvcF9kdXBsaWNhdGVzKHN1YnNldD1bJ1F1YWRFdmVudENvZGUnXSwgaW5wbGFjZT1UcnVlKQogICAgY3Vycl9kYXRhID0gY3Vycl9kYXRhW2N1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IERFRkFVTFRfRU5EX0RBVEVdCiAgICBpZiBkYXRlX3JhbmdlOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVsoY3Vycl9kYXRhWydEYXRlU3RyJ10gPj0gZGF0ZV9yYW5nZS5zdGFydF9kYXRlLmRhdGUpICYgKGN1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IGRhdGVfcmFuZ2UuZW5kX2RhdGUuZGF0ZSldCiAgICBpZiBoZWFkX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMUNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzXSldCiAgICBpZiB0YWlsX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiB0YWlsX2VudGl0aWVzXSldCiAgICAjIGNvdW50IHRoZSBudW1iZXIgb2YgZXZlbnRzIGZvciBlYWNoIHJlbGF0aW9uCiAgICByZWxhdGlvbl9jb3VudHMgPSBjdXJyX2RhdGFbJ0V2ZW50QmFzZUNvZGUnXS52YWx1ZV9jb3VudHMoKQogICAgcmVsYXRpb25fY291bnRzID0gcmVsYXRpb25fY291bnRzLnRvX2RpY3QoKQogICAgIyBzb3J0IHRoZSBkaWN0aW9uYXJ5IGJ5IHZhbHVlcyBpbiBkZXNjZW5kaW5nIG9yZGVyCiAgICByZWxhdGlvbl9jb3VudHMgPSBkaWN0KHNvcnRlZChyZWxhdGlvbl9jb3VudHMuaXRlbXMoKSwga2V5PWxhbWJkYSBpdGVtOiBpdGVtWzFdLCByZXZlcnNlPVRydWUpKQogICAgcmVsYXRpb25fY291bnRzID0ge0NBTUVPQ29kZShrZXkpOiB2YWx1ZSBmb3Iga2V5LCB2YWx1ZSBpbiByZWxhdGlvbl9jb3VudHMuaXRlbXMoKX0KICAgIHJldHVybiByZWxhdGlvbl9jb3VudHMKCmRlZiBjb3VudF9uZXdzX2FydGljbGVzKGRhdGVfcmFuZ2U6IE9wdGlvbmFsW0RhdGVSYW5nZV0gPSBOb25lLCBoZWFkX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUsIHRhaWxfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgcmVsYXRpb25zOiBPcHRpb25hbFtMaXN0W0NBTUVPQ29kZV1dID0gTm9uZSwga2V5d29yZHM6IE9wdGlvbmFsW0xpc3Rbc3RyXV0gPSBOb25lKSAtPiBpbnQ6CiAgICAiIiIKICAgIENvdW50cyB0aGUgbnVtYmVyIG9mIG5ld3MgYXJ0aWNsZXMgYmFzZWQgb24gc3BlY2lmaWVkIGNvbmRpdGlvbnMuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBkYXRlX3JhbmdlIChPcHRpb25hbFtEYXRlUmFuZ2VdKTogUmFuZ2Ugb2YgZGF0ZXMgdG8gZmlsdGVyIHRoZSBuZXdzIGFydGljbGVzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGhlYWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogQXQgbGVhc3Qgb25lIG9mIHRoZSBlbnRpdGllcyBtdXN0IGJlIG1lbnRpb25lZCBpbiB0aGUgYXJ0aWNsZXMgYW5kIGJlIHRoZSBoZWFkIGVudGl0eSBpbiB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZW50aXRpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHRhaWxfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogQXQgbGVhc3Qgb25lIG9mIHRoZSBlbnRpdGllcyBtdXN0IGJlIG1lbnRpb25lZCBpbiB0aGUgYXJ0aWNsZXMgYW5kIGJlIHRoZSB0YWlsIGVudGl0eSBpbiB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZW50aXRpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHJlbGF0aW9ucyAoT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSk6IEF0IGxlYXN0IG9uZSBvZiB0aGUgcmVsYXRpb25zIG11c3QgYmUgbWVudGlvbmVkIGluIHRoZSBhcnRpY2xlcy4gSWYgZmlyc3QgbGV2ZWwgcmVsYXRpb25zIGFyZSBsaXN0ZWQsIGFsbCBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zIHVuZGVyIHRoZW0gYXJlIGluY2x1ZGVkLiBJZiBOb25lLCBhbGwgcmVsYXRpb25zIGFyZSBpbmNsdWRlZC4KICAgICAgICBrZXl3b3JkcyAoT3B0aW9uYWxbTGlzdFtzdHJdXSk6IEF0IGxlYXN0IG9uZSBvZiB0aGUga2V5d29yZHMgbXVzdCBiZSBwcmVzZW50IGluIHRoZSBhcnRpY2xlcy4gSWYgTm9uZSwgYWxsIGFydGljbGVzIGFyZSBpbmNsdWRlZC4KCiAgICBSZXR1cm5zOgogICAgICAgIGludDogVGhlIGNvdW50IG9mIG5ld3MgYXJ0aWNsZXMgbWF0Y2hpbmcgdGhlIGNvbmRpdGlvbnMuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gY291bnRfbmV3c19hcnRpY2xlcyhkYXRlX3JhbmdlPURhdGVSYW5nZShzdGFydF9kYXRlPURhdGUoIjIwMjItMDEtMDEiKSwgZW5kX2RhdGU9RGF0ZSgiMjAyMi0wMS0zMSIpKSwgaGVhZF9lbnRpdGllcz1bSVNPQ29kZSgiVVNBIiksIElTT0NvZGUoIkNITiIpXSwgdGFpbF9lbnRpdGllcz1bSVNPQ29kZSgiVVNBIiksIElTT0NvZGUoIkNITiIpXSwgcmVsYXRpb25zPVtDQU1FT0NvZGUoIjAxMCIpXSwga2V5d29yZHM9WyJ0cmFkZSJdKQogICAgICAgIDIKICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBkYXRlX3JhbmdlIGFuZCBub3QgaXNpbnN0YW5jZShkYXRlX3JhbmdlLCBEYXRlUmFuZ2UpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAnZGF0ZV9yYW5nZScgbXVzdCBiZSBhIERhdGVSYW5nZSBvYmplY3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGRhdGVfcmFuZ2UpfSIpCiAgICBpZiBoZWFkX2VudGl0aWVzIGFuZCBub3QgaXNpbnN0YW5jZShoZWFkX2VudGl0aWVzLCBsaXN0KToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ2hlYWRfZW50aXRpZXMnIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShoZWFkX2VudGl0aWVzKX0iKQogICAgaWYgaGVhZF9lbnRpdGllcyBhbmQgbm90IGFsbChpc2luc3RhbmNlKGlzbywgSVNPQ29kZSkgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiRWxlbWVudHMgaW4gJ2hlYWRfZW50aXRpZXMnIG11c3QgYmUgSVNPQ29kZSBvYmplY3RzIikKICAgIGlmIHRhaWxfZW50aXRpZXMgYW5kIG5vdCBpc2luc3RhbmNlKHRhaWxfZW50aXRpZXMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAndGFpbF9lbnRpdGllcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKHRhaWxfZW50aXRpZXMpfSIpCiAgICBpZiB0YWlsX2VudGl0aWVzIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoaXNvLCBJU09Db2RlKSBmb3IgaXNvIGluIHRhaWxfZW50aXRpZXMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAndGFpbF9lbnRpdGllcycgbXVzdCBiZSBJU09Db2RlIG9iamVjdHMiKQogICAgaWYgcmVsYXRpb25zIGFuZCBub3QgaXNpbnN0YW5jZShyZWxhdGlvbnMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAncmVsYXRpb25zJyBtdXN0IGJlIGEgbGlzdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUocmVsYXRpb25zKX0iKQogICAgaWYgcmVsYXRpb25zIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoY29kZSwgQ0FNRU9Db2RlKSBmb3IgY29kZSBpbiByZWxhdGlvbnMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAncmVsYXRpb25zJyBtdXN0IGJlIENBTUVPQ29kZSBvYmplY3RzIikKICAgIGlmIGtleXdvcmRzIGFuZCBub3QgaXNpbnN0YW5jZShrZXl3b3JkcywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdrZXl3b3JkcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGtleXdvcmRzKX0iKQogICAgaWYga2V5d29yZHMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShrZXl3b3JkLCBzdHIpIGZvciBrZXl3b3JkIGluIGtleXdvcmRzKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiRWxlbWVudHMgaW4gJ2tleXdvcmRzJyBtdXN0IGJlIHN0cmluZ3MiKQoKICAgICMgcHJvY2VzcyBkYXRhX2tnIGJ5IGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbnMKICAgIGN1cnJfZGF0YSA9IGRhdGFfa2cuY29weSgpCiAgICBjdXJyX2RhdGEuZHJvcF9kdXBsaWNhdGVzKHN1YnNldD1bJ1F1YWRFdmVudENvZGUnXSwgaW5wbGFjZT1UcnVlKQogICAgY3Vycl9kYXRhID0gY3Vycl9kYXRhW2N1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IERFRkFVTFRfRU5EX0RBVEVdCiAgICBpZiBkYXRlX3JhbmdlOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVsoY3Vycl9kYXRhWydEYXRlU3RyJ10gPj0gZGF0ZV9yYW5nZS5zdGFydF9kYXRlLmRhdGUpICYgKGN1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IGRhdGVfcmFuZ2UuZW5kX2RhdGUuZGF0ZSldCiAgICBpZiBoZWFkX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMUNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzXSldCiAgICBpZiB0YWlsX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiB0YWlsX2VudGl0aWVzXSldCiAgICBpZiByZWxhdGlvbnM6CiAgICAgICAgIyBpZiBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGxpc3RlZCwgaW5jbHVkZSBhbGwgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyB1bmRlciB0aGVtCiAgICAgICAgZm9yIGNvZGUgaW4gcmVsYXRpb25zOgogICAgICAgICAgICBpZiBsZW4oY29kZS5jb2RlKSA9PSAyOgogICAgICAgICAgICAgICAgcmVsYXRpb25zLmV4dGVuZChbQ0FNRU9Db2RlKGMpIGZvciBjIGluIGRpY3RfY29kZTJyZWxhdGlvbiBpZiBjWzoyXSA9PSBjb2RlLmNvZGUgYW5kIGxlbihjKSA9PSAzXSkKICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydFdmVudEJhc2VDb2RlJ10uaXNpbihbY29kZS5jb2RlIGZvciBjb2RlIGluIHJlbGF0aW9uc10pXQogICAgIyBjb25jYXQgdGhlIERvY2lkcyBsaXN0IG9mIGN1cnJlbnQgZGF0YSB0byBnZXQgdGhlIG5ld3MgYXJ0aWNsZXMKICAgIGRvY2lkc19saXN0ID0gW2V2YWwoZG9jaWRzKSBmb3IgZG9jaWRzIGluIGN1cnJfZGF0YVsnRG9jaWRzJ10udW5pcXVlKCkudG9saXN0KCldCiAgICBkb2NpZHMgPSBsaXN0KHNldChbaXRlbSBmb3Igc3VibGlzdCBpbiBkb2NpZHNfbGlzdCBmb3IgaXRlbSBpbiBzdWJsaXN0XSkpCiAgICBkb2NpZHMgPSBbc3RyKGRvY2lkKSBmb3IgZG9jaWQgaW4gZG9jaWRzXQogICAgbmV3c19hcnRpY2xlcyA9IGRhdGFfbmV3c1tkYXRhX25ld3NbJ0RvY2lkJ10uaXNpbihkb2NpZHMpXQogICAgaWYga2V5d29yZHM6CiAgICAgICAgIyBmaWx0ZXIgdGhlIG5ld3MgYXJ0aWNsZXMgdGhhdCBjb250YWluIGF0IGxlYXN0IG9uZSBvZiB0aGUga2V5d29yZHMgaW4gdGhlIHRpdGxlIG9yIHRleHQgc3RyaW5nCiAgICAgICAgbmV3c19hcnRpY2xlcyA9IG5ld3NfYXJ0aWNsZXNbbmV3c19hcnRpY2xlc1snVGl0bGUnXS5zdHIuY29udGFpbnMoJ3wnLmpvaW4oa2V5d29yZHMpLCBjYXNlPUZhbHNlKSB8IG5ld3NfYXJ0aWNsZXNbJ1RleHQnXS5zdHIuY29udGFpbnMoJ3wnLmpvaW4oa2V5d29yZHMpLCBjYXNlPUZhbHNlKV0KICAgIHJldHVybiBsZW4obmV3c19hcnRpY2xlcykKCmRlZiBnZXRfbmV3c19hcnRpY2xlcyhkYXRlX3JhbmdlOiBPcHRpb25hbFtEYXRlUmFuZ2VdID0gTm9uZSwgaGVhZF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lLCB0YWlsX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUsIHJlbGF0aW9uczogT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSA9IE5vbmUsIGtleXdvcmRzOiBPcHRpb25hbFtMaXN0W3N0cl1dID0gTm9uZSwgdGV4dF9kZXNjcmlwdGlvbjogT3B0aW9uYWxbc3RyXSA9IE5vbmUpIC0+IExpc3RbVHVwbGVbRGF0ZSwgc3RyXV06CiAgICAiIiIKICAgIFJldHJpZXZlcyBuZXdzIGFydGljbGVzIGJhc2VkIG9uIHNwZWNpZmllZCBjb25kaXRpb25zLgogICAgSW5oZXJpdHMgY29tbW9uIGZpbHRlciBwYXJhbWV0ZXJzIGZyb20gY291bnRfbmV3c19hcnRpY2xlcy4gU2VlIGNvdW50X25ld3NfYXJ0aWNsZXMgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGVzZSBwYXJhbWV0ZXJzLgoKICAgIEFkZGl0aW9uYWwgUGFyYW1ldGVyczoKICAgICAgICB0ZXh0X2Rlc2NyaXB0aW9uIChPcHRpb25hbFtzdHJdKTogVGV4dHVhbCBkZXNjcmlwdGlvbiB0byBtYXRjaCB3aXRoIHRoZSBuZXdzIGFydGljbGVzLiBJZiBOb25lLCB0aGUgcmV0dXJuZWQgYXJ0aWNsZXMgYXJlIHNvcnRlZCBieSBkYXRlIGluIGRlc2NlbmRpbmcgb3JkZXI7IG90aGVyd2lzZSwgc29ydGVkIGJ5IHJlbGV2YW5jZSB0byB0aGUgZGVzY3JpcHRpb24uCgogICAgUmV0dXJuczoKICAgICAgICBMaXN0W1R1cGxlW0RhdGUsIHN0cl1dOiBBIGxpc3Qgb2YgbWF4aW11bSAxNSBuZXdzIGFydGljbGVzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucywgZWFjaCByZXByZXNlbnRlZCBieSBhIHR1cGxlIG9mIGRhdGUgYW5kIHRpdGxlLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9uZXdzX2FydGljbGVzKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBoZWFkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCB0YWlsX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCByZWxhdGlvbnM9W0NBTUVPQ29kZSgiMDEwIildLCBrZXl3b3Jkcz1bInRyYWRlIl0sIHRleHRfZGVzY3JpcHRpb249IkVjb25vbWljIHRyYWRlIGlzIGVuY291cmFnZWQgYmV0d2VlbiBVU0EgYW5kIENoaW5hLiIpCiAgICAgICAgWyhOZXdzQXJ0aWNsZS5kYXRlPURhdGUoIjIwMjItMDEtMTUiKSwgTmV3c0FydGljbGUudGl0bGU9IkNoaW5hIGFuZCBVU0Egc2lnbiB0cmFkZSBkZWFsIiksIChOZXdzQXJ0aWNsZS5kYXRlPURhdGUoIjIwMjItMDEtMTAiKSwgTmV3c0FydGljbGUudGl0bGU9IlRyYWRlIGFncmVlbWVudCBiZXR3ZWVuIFVTQSBhbmQgQ2hpbmEiKV0KICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBkYXRlX3JhbmdlIGFuZCBub3QgaXNpbnN0YW5jZShkYXRlX3JhbmdlLCBEYXRlUmFuZ2UpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAnZGF0ZV9yYW5nZScgbXVzdCBiZSBhIERhdGVSYW5nZSBvYmplY3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGRhdGVfcmFuZ2UpfSIpCiAgICBpZiBoZWFkX2VudGl0aWVzIGFuZCBub3QgaXNpbnN0YW5jZShoZWFkX2VudGl0aWVzLCBsaXN0KToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ2hlYWRfZW50aXRpZXMnIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShoZWFkX2VudGl0aWVzKX0iKQogICAgaWYgaGVhZF9lbnRpdGllcyBhbmQgbm90IGFsbChpc2luc3RhbmNlKGlzbywgSVNPQ29kZSkgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiRWxlbWVudHMgaW4gJ2hlYWRfZW50aXRpZXMnIG11c3QgYmUgSVNPQ29kZSBvYmplY3RzIikKICAgIGlmIHRhaWxfZW50aXRpZXMgYW5kIG5vdCBpc2luc3RhbmNlKHRhaWxfZW50aXRpZXMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAndGFpbF9lbnRpdGllcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKHRhaWxfZW50aXRpZXMpfSIpCiAgICBpZiB0YWlsX2VudGl0aWVzIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoaXNvLCBJU09Db2RlKSBmb3IgaXNvIGluIHRhaWxfZW50aXRpZXMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAndGFpbF9lbnRpdGllcycgbXVzdCBiZSBJU09Db2RlIG9iamVjdHMiKQogICAgaWYgcmVsYXRpb25zIGFuZCBub3QgaXNpbnN0YW5jZShyZWxhdGlvbnMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAncmVsYXRpb25zJyBtdXN0IGJlIGEgbGlzdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUocmVsYXRpb25zKX0iKQogICAgaWYgcmVsYXRpb25zIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoY29kZSwgQ0FNRU9Db2RlKSBmb3IgY29kZSBpbiByZWxhdGlvbnMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAncmVsYXRpb25zJyBtdXN0IGJlIENBTUVPQ29kZSBvYmplY3RzIikKICAgIGlmIGtleXdvcmRzIGFuZCBub3QgaXNpbnN0YW5jZShrZXl3b3JkcywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdrZXl3b3JkcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGtleXdvcmRzKX0iKQogICAgaWYga2V5d29yZHMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShrZXl3b3JkLCBzdHIpIGZvciBrZXl3b3JkIGluIGtleXdvcmRzKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiRWxlbWVudHMgaW4gJ2tleXdvcmRzJyBtdXN0IGJlIHN0cmluZ3MiKQogICAgaWYgdGV4dF9kZXNjcmlwdGlvbiBhbmQgbm90IGlzaW5zdGFuY2UodGV4dF9kZXNjcmlwdGlvbiwgc3RyKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ3RleHRfZGVzY3JpcHRpb24nIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKHRleHRfZGVzY3JpcHRpb24pfSIpCgogICAgIyBwcm9jZXNzIGRhdGFfa2cgYnkgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucwogICAgY3Vycl9kYXRhID0gZGF0YV9rZy5jb3B5KCkKICAgIGN1cnJfZGF0YS5kcm9wX2R1cGxpY2F0ZXMoc3Vic2V0PVsnUXVhZEV2ZW50Q29kZSddLCBpbnBsYWNlPVRydWUpCiAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydEYXRlU3RyJ10gPD0gREVGQVVMVF9FTkRfREFURV0KICAgIGlmIGRhdGVfcmFuZ2U6CiAgICAgICAgY3Vycl9kYXRhID0gY3Vycl9kYXRhWwogICAgICAgICAgICAoY3Vycl9kYXRhWydEYXRlU3RyJ10gPj0gZGF0ZV9yYW5nZS5zdGFydF9kYXRlLmRhdGUpICYgKGN1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IGRhdGVfcmFuZ2UuZW5kX2RhdGUuZGF0ZSldCiAgICBpZiBoZWFkX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMUNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzXSldCiAgICBpZiB0YWlsX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiB0YWlsX2VudGl0aWVzXSldCiAgICBpZiByZWxhdGlvbnM6CiAgICAgICAgIyBpZiBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGxpc3RlZCwgaW5jbHVkZSBhbGwgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyB1bmRlciB0aGVtCiAgICAgICAgZm9yIGNvZGUgaW4gcmVsYXRpb25zOgogICAgICAgICAgICBpZiBsZW4oY29kZS5jb2RlKSA9PSAyOgogICAgICAgICAgICAgICAgcmVsYXRpb25zLmV4dGVuZChbQ0FNRU9Db2RlKGMpIGZvciBjIGluIGRpY3RfY29kZTJyZWxhdGlvbiBpZiBjWzoyXSA9PSBjb2RlLmNvZGUgYW5kIGxlbihjKSA9PSAzXSkKICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydFdmVudEJhc2VDb2RlJ10uaXNpbihbY29kZS5jb2RlIGZvciBjb2RlIGluIHJlbGF0aW9uc10pXQogICAgZG9jaWRzX2xpc3QgPSBbZXZhbChkb2NpZHMpIGZvciBkb2NpZHMgaW4gY3Vycl9kYXRhWydEb2NpZHMnXS51bmlxdWUoKS50b2xpc3QoKV0KICAgIGRvY2lkcyA9IGxpc3Qoc2V0KFtpdGVtIGZvciBzdWJsaXN0IGluIGRvY2lkc19saXN0IGZvciBpdGVtIGluIHN1Ymxpc3RdKSkKICAgIGRvY2lkcyA9IFtzdHIoZG9jaWQpIGZvciBkb2NpZCBpbiBkb2NpZHNdCiAgICBuZXdzX2FydGljbGVzID0gZGF0YV9uZXdzW2RhdGFfbmV3c1snRG9jaWQnXS5pc2luKGRvY2lkcyldCiAgICBpZiBrZXl3b3JkczoKICAgICAgICAjIGZpbHRlciB0aGUgbmV3cyBhcnRpY2xlcyB0aGF0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIG9mIHRoZSBrZXl3b3JkcyBpbiB0aGUgdGl0bGUgb3IgdGV4dCBzdHJpbmcKICAgICAgICBuZXdzX2FydGljbGVzID0gbmV3c19hcnRpY2xlc1tuZXdzX2FydGljbGVzWydUaXRsZSddLnN0ci5jb250YWlucygnfCcuam9pbihrZXl3b3JkcyksIGNhc2U9RmFsc2UpIHwgbmV3c19hcnRpY2xlc1snVGV4dCddLnN0ci5jb250YWlucygnfCcuam9pbihrZXl3b3JkcyksIGNhc2U9RmFsc2UpXQogICAgaWYgbm90IHRleHRfZGVzY3JpcHRpb246CiAgICAgICAgIyBnZXQgbWF4IDE1IG5ld3MgYXJ0aWNsZXMgZnJvbSB0aGUgZmlsdGVyZWQgZGF0YQogICAgICAgICMgc29ydGVkIGJ5IGRhdGUgaW4gZGVzY2VuZGluZyBvcmRlcgogICAgICAgIG5ld3NfYXJ0aWNsZXMuc29ydF92YWx1ZXMoYnk9J0RhdGUnLCBhc2NlbmRpbmc9RmFsc2UsIGlucGxhY2U9VHJ1ZSkKICAgICAgICBuZXdzX2FydGljbGVzID0gbmV3c19hcnRpY2xlc1tbJ0RhdGUnLCAnVGl0bGUnXV0uaGVhZCgxNSkKICAgICAgICByZXR1cm4gWyhEYXRlKHJvd1snRGF0ZSddKSwgcm93WydUaXRsZSddKSBmb3IgXywgcm93IGluIG5ld3NfYXJ0aWNsZXMuaXRlcnJvd3MoKV0KICAgIGVsc2U6CiAgICAgICAgIyBnZXQgdGhlIG1heCAxNSBuZXdzIGFydGljbGVzIHdpdGggdGhlIGhpZ2hlc3QgQk0yNSBzY29yZSB0byB0aGUgdGV4dF9kZXNjcmlwdGlvbgogICAgICAgIGNvcnB1cyA9IG5ld3NfYXJ0aWNsZXNbJ1RpdGxlJ10gKyAnICcgKyBuZXdzX2FydGljbGVzWydUZXh0J10KICAgICAgICB0b2tlbml6ZWRfY29ycHVzID0gW2RvYy5zcGxpdCgiICIpIGZvciBkb2MgaW4gY29ycHVzXQogICAgICAgIGJtMjUgPSBCTTI1T2thcGkodG9rZW5pemVkX2NvcnB1cykKICAgICAgICB0b2tlbml6ZWRfcXVlcnkgPSB0ZXh0X2Rlc2NyaXB0aW9uLnNwbGl0KCIgIikKICAgICAgICBkb2Nfc2NvcmVzID0gYm0yNS5nZXRfc2NvcmVzKHRva2VuaXplZF9xdWVyeSkKICAgICAgICB0b3BfaW5kaWNlcyA9IG5wLmFyZ3NvcnQoZG9jX3Njb3JlcylbOjotMV1bOjE1XQogICAgICAgIG5ld3NfYXJ0aWNsZXMgPSBuZXdzX2FydGljbGVzLmlsb2NbdG9wX2luZGljZXNdCiAgICAgICAgcmV0dXJuIFsoRGF0ZShyb3dbJ0RhdGUnXSksIHJvd1snVGl0bGUnXSkgZm9yIF8sIHJvdyBpbiBuZXdzX2FydGljbGVzLml0ZXJyb3dzKCldCgpkZWYgYnJvd3NlX25ld3NfYXJ0aWNsZShkYXRlOiBEYXRlLCB0aXRsZTogc3RyKSAtPiBzdHI6CiAgICAiIiIKICAgIFJldHJpZXZlcyB0aGUgZnVsbCB0ZXh0IG9mIGEgbmV3cyBhcnRpY2xlIGJ5IGl0cyB0aXRsZS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGRhdGUgKERhdGUpOiBUaGUgZGF0ZSBvZiB0aGUgbmV3cyBhcnRpY2xlIHRvIHJldHJpZXZlLgogICAgICAgIHRpdGxlIChzdHIpOiBUaGUgdGl0bGUgb2YgdGhlIG5ld3MgYXJ0aWNsZSB0byByZXRyaWV2ZS4KCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogVGhlIGRhdGUsIHRoZSB0aXRsZSBhbmQgZnVsbCBjb250ZW50cyBvZiB0aGUgbmV3cyBhcnRpY2xlLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGJyb3dzZV9uZXdzX2FydGljbGUoRGF0ZSgiMjAyMi0wMS0xMCIpLCAiVHJhZGUgYWdyZWVtZW50IGJldHdlZW4gVVNBIGFuZCBDaGluYSIpCiAgICAgICAgMjAyMi0wMS0xMDoKICAgICAgICBUcmFkZSBhZ3JlZW1lbnQgYmV0d2VlbiBVU0EgYW5kIENoaW5hCiAgICAgICAgT24gSmFudWFyeSAxMCwgMjAyMiwgYSB0cmFkZSBhZ3JlZW1lbnQgd2FzIHNpZ25lZCBiZXR3ZWVuIHRoZSBVU0EgYW5kIENoaW5hIHRvIHByb21vdGUgZWNvbm9taWMgY29vcGVyYXRpb24uLi4KICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBub3QgaXNpbnN0YW5jZShkYXRlLCBEYXRlKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ2RhdGUnIG11c3QgYmUgYSBEYXRlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoZGF0ZSl9IikKICAgIGlmIG5vdCBpc2luc3RhbmNlKHRpdGxlLCBzdHIpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAndGl0bGUnIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKHRpdGxlKX0iKQoKICAgICMgcHJvY2VzcyBkYXRhX25ld3MgdG8gZmluZCB0aGUgbmV3cyBhcnRpY2xlIHdpdGggdGhlIHNwZWNpZmllZCBkYXRlIGFuZCB0aXRsZQogICAgY3Vycl9kYXRhID0gZGF0YV9uZXdzWyhkYXRhX25ld3NbJ0RhdGUnXSA9PSBkYXRlLmRhdGUpICYgKGRhdGFfbmV3c1snVGl0bGUnXSA9PSB0aXRsZSldCiAgICBpZiBsZW4oY3Vycl9kYXRhKSA9PSAwOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJObyBuZXdzIGFydGljbGUgZm91bmQgd2l0aCB0aGUgc3BlY2lmaWVkIGRhdGUge2RhdGUuZGF0ZX0gYW5kIHRpdGxlIHt0aXRsZX0iKQogICAgcmV0dXJuIGYie2RhdGV9Olxue3RpdGxlfVxue2N1cnJfZGF0YVsnVGV4dCddLnZhbHVlc1swXX0i)1@dataclass2class  Date:3  """Represents  a  date."""4  date:  str  #  Date  in  the  format  ’YYYY-MM-DD’5  #  Example:  Date("2022-01-01")67  def  __init__(self,  date:  str):8  #  check  type9  if  not  isinstance(date,  str):10  raise  ValueError(f"Attribute  ’date’  of  class  Date  must  be  a  string  in  the  format  ’YYYY-MM-DD’,  but  received:  {date}  in  type  {type(date)}")1112  #  check  if  date  is  in  the  correct  format  by  trying  to  convert  it  to  a  date  object13  try:14  datetime.datetime.strptime(date,  ’%Y-%m-%d’)15  except  ValueError:16  raise  ValueError(f"Date  must  be  in  the  format  ’YYYY-MM-DD’,  but  received:  {date}")17  if  date  <  DEFAULT_START_DATE:18  raise  ValueError(f"Date  must  be  on  or  after  {DEFAULT_START_DATE},  but  received:  {date}")19  if  DEFAULT_END_DATE  and  date  >  DEFAULT_END_DATE:20  raise  ValueError(f"Date  must  be  on  or  before  the  current  date  {DEFAULT_END_DATE},  but  received:  {date}")2122  self.date  =  date2324  def  __str__(self):25  return  f"Date(’{self.date}’)"2627  def  __hash__(self):28  return  hash(self.date)2930  def  __eq__(self,  other):31  if  isinstance(other,  Date):32  return  self.date  ==  other.date33  return  False3435@dataclass36class  DateRange:37  """Represents  a  range  of  dates  (inclusive)."""38  start_date:  Optional[Date]  #  If  None,  the  earliest  date  is  used39  end_date:  Optional[Date]  #  If  None,  the  current  date  is  used40  #  Example:  DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31"))4142  def  __init__(self,  start_date:  Optional[Date]  =  None,  end_date:  Optional[Date]  =  None):43  #  check  type44  if  start_date  and  not  isinstance(start_date,  Date):45  raise  ValueError(f"Attribute  ’start_date’  of  class  DateRange  must  be  a  Date  object,  but  received  type  {type(start_date)}")46  if  end_date  and  not  isinstance(end_date,  Date):47  raise  ValueError(f"Attribute  ’end_date’  of  class  DateRange  must  be  a  Date  object,  but  received  type  {type(end_date)}")4849  self.start_date  =  start_date  if  start_date  else  Date(DEFAULT_START_DATE)50  self.end_date  =  end_date  if  end_date  else  Date(DEFAULT_END_DATE)51  if  start_date  and  end_date  and  start_date.date  >  end_date.date:52  raise  ValueError("Start  date  must  be  before  or  equal  to  end  date,  but  received:  start_date={},  end_date={}".format(start_date.date,  end_date.date))5354  def  __str__(self):55  return  f"DateRange(start_date={self.start_date},  end_date={self.end_date})"5657  def  __hash__(self):58  return  hash((self.start_date,  self.end_date))5960  def  __eq__(self,  other):61  if  isinstance(other,  DateRange):62  return  self.start_date  ==  other.start_date  and  self.end_date  ==  other.end_date63  return  False6465@dataclass66class  ISOCode:67  """Represents  an  ISO  alpha-3  country  code."""68  code:  str  #  3-letter  ISO  code69  #  Example:  ISOCode("USA")7071  def  __init__(self,  code:  str):72  #  check  type73  if  not  isinstance(code,  str):74  raise  ValueError(f"Attribute  ’code’  of  class  ISOCode  must  be  a  string,  but  received  type  {type(code)}")7576  if  len(code)  !=  3:77  raise  ValueError(f"ISO  code  must  be  a  3-letter  string,  but  received:  {code}")78  if  code  not  in  dict_iso2alternames:79  raise  ValueError(f"ISO  code  must  be  a  valid  ISO  alpha-3  country  code,  but  received:  {code}")80  self.code  =  code8182  def  __str__(self):83  return  f"ISOCode(’{self.code}’)"8485  def  __hash__(self):86  return  hash(self.code)8788  def  __eq__(self,  other):89  if  isinstance(other,  ISOCode):90  return  self.code  ==  other.code91  return  False9293@dataclass94class  Country:95  """Represents  a  country  entity."""96  iso_code:  ISOCode97  name:  str98  #  Example:  Country(iso_code=ISOCode("USA"),  name="United  States")99100  def  __init__(self,  iso_code:  ISOCode,  name:  str):101  #  check  type102  if  not  isinstance(iso_code,  ISOCode):103  raise  ValueError(f"Attribute  ’iso_code’  of  class  Country  must  be  an  ISOCode  object,  but  received  type  {type(iso_code)}")104  if  not  isinstance(name,  str):105  raise  ValueError(f"Attribute  ’name’  of  class  Country  must  be  a  string,  but  received  type  {type(name)}")106107  if  dict_iso2alternames[iso_code.code][0]  !=  name:108  raise  ValueError(f"Country  name  must  match  the  name  corresponding  to  the  ISO  code,  but  received:  {name}  for  ISO  code:  {iso_code.code}")109  self.iso_code  =  iso_code110  self.name  =  name111112  def  __str__(self):113  return  f"Country(iso_code={self.iso_code},  name=’{self.name}’)"114115  def  __hash__(self):116  return  hash((self.iso_code,  self.name))117118  def  __eq__(self,  other):119  if  isinstance(other,  Country):120  return  self.iso_code  ==  other.iso_code  and  self.name  ==  other.name121  return  False122123@dataclass124class  CAMEOCode:125  """Represents  a  CAMEO  verb  code."""126  code:  str  #  2-digit  CAMEO  code  for  first  level  relations,  3-digit  CAMEO  code  for  second  level  relations127  #  Example:  CAMEOCode("01"),  CAMEOCode("010")128129  def  __init__(self,  code:  str):130  #  check  type131  if  not  isinstance(code,  str):132  raise  ValueError(f"Attribute  ’code’  of  class  CAMEOCode  must  be  a  string,  but  received  type  {type(code)}")133134  if  len(code)  not  in  [2,  3]:135  raise  ValueError(f"CAMEO  code  must  be  a  valid  2  or  3-digit  string  defined  in  the  ’Conflict  and  Mediation  Event  Observations’  Codebook,  but  received:  {code}")136  if  code  not  in  dict_code2relation:137  raise  ValueError(f"CAMEO  code  must  be  a  valid  CAMEO  code  defined  in  the  ’Conflict  and  Mediation  Event  Observations’  Codebook,  but  received:  {code}")138  self.code  =  code139140  def  __str__(self):141  return  f"CAMEOCode(’{self.code}’)"142143  def  __hash__(self):144  return  hash(self.code)145146  def  __eq__(self,  other):147  if  isinstance(other,  CAMEOCode):148  return  self.code  ==  other.code149  return  False150151@dataclass152class  Relation:153  """Represents  a  relation."""154  cameo_code:  CAMEOCode155  name:  str156  description:  str  #  A  brief  description  of  what  event  the  relation  represents157  #  Example:  Relation(cameo_code=CAMEOCode("010"),  name="Make  statement,  not  specified",  description="All  public  statements  expressed  verbally  or  in  action,  not  otherwise  specified."158159  def  __init__(self,  cameo_code:  CAMEOCode,  name:  str,  description:  str):160  #  check  type161  if  not  isinstance(cameo_code,  CAMEOCode):162  raise  ValueError(f"Attribute  ’cameo_code’  of  class  Relation  must  be  a  CAMEOCode  object,  but  received  type  {type(cameo_code)}")163  if  not  isinstance(name,  str):164  raise  ValueError(f"Attribute  ’name’  of  class  Relation  must  be  a  string,  but  received  type  {type(name)}")165  if  not  isinstance(description,  str):166  raise  ValueError(f"Attribute  ’description’  of  class  Relation  must  be  a  string,  but  received  type  {type(description)}")167168  if  dict_code2relation[cameo_code.code][’Name’]  !=  name:169  raise  ValueError(f"Relation  name  must  match  the  name  corresponding  to  the  CAMEO  code,  but  received:  {name}  for  CAMEO  code  {cameo_code.code}")170  if  dict_code2relation[cameo_code.code][’Description’]  !=  description:171  raise  ValueError(f"Relation  description  must  match  the  description  corresponding  to  the  CAMEO  code,  but  received:  {description}  for  CAMEO  code  {cameo_code.code}")172  self.cameo_code  =  cameo_code173  self.name  =  name174  self.description  =  description175176  def  __str__(self):177  return  f"Relation(cameo_code={self.cameo_code},  name=’{self.name}’,  description=’{self.description}’)"178179  def  __hash__(self):180  return  hash((self.cameo_code,  self.name,  self.description))181182  def  __eq__(self,  other):183  if  isinstance(other,  Relation):184  return  self.cameo_code  ==  other.cameo_code  and  self.name  ==  other.name  and  self.description  ==  other.description185  return  False186187@dataclass188class  Event:189  """Represents  an  event  characterized  by  date,  head  entity,  relation,  and  tail  entity."""190  date:  Date191  head_entity:  ISOCode192  relation:  CAMEOCode193  tail_entity:  ISOCode194  #  Example:  Event(date=Date("2022-01-01"),  head_entity=ISOCode("USA"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("CAN"))195196  def  __init__(self,  date:  Date,  head_entity:  ISOCode,  relation:  CAMEOCode,  tail_entity:  ISOCode):197  #  check  type198  if  not  isinstance(date,  Date):199  raise  ValueError(f"Attribute  ’date’  of  class  Event  must  be  a  Date  object,  but  received  type  {type(date)}")200  if  not  isinstance(head_entity,  ISOCode):201  raise  ValueError(f"Attribute  ’head_entity’  of  class  Event  must  be  an  ISOCode  object,  but  received  type  {type(head_entity)}")202  if  not  isinstance(relation,  CAMEOCode):203  raise  ValueError(f"Attribute  ’relation’  of  class  Event  must  be  a  CAMEOCode  object,  but  received  type  {type(relation)}")204  if  not  isinstance(tail_entity,  ISOCode):205  raise  ValueError(f"Attribute  ’tail_entity’  of  class  Event  must  be  an  ISOCode  object,  but  received  type  {type(tail_entity)}")206207  self.date  =  date208  self.head_entity  =  head_entity209  self.relation  =  relation210  self.tail_entity  =  tail_entity211212  def  __str__(self):213  return  f"Event(date={self.date},  head_entity={self.head_entity},  relation={self.relation},  tail_entity={self.tail_entity})"214215  def  __hash__(self):216  return  hash((self.date,  self.head_entity,  self.relation,  self.tail_entity))217218  def  __eq__(self,  other):219  if  isinstance(other,  Event):220  return  self.date  ==  other.date  and  self.head_entity  ==  other.head_entity  and  self.relation  ==  other.relation  and  self.tail_entity  ==  other.tail_entity221  return  False222223@dataclass224class  NewsArticle:225  """Represents  a  news  article,  including  metadata  and  content."""226  date:  Date227  title:  str228  content:  str  #  Full  text  content  of  the  news  article229  events:  List[Event]  #  List  of  events  mentioned  in  the  article230  #  Example:  NewsArticle(date=Date("2022-01-01"),  title="Trade  agreement  between  USA  and  China",  content="On  January  1,  2022,  a  trade  agreement  was  signed  between  the  USA  and  China...",  events=[Event(date=Date("2022-01-01"),  head_entity=ISOCode("USA"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("CHN")])231232  def  __init__(self,  date:  Date,  title:  str,  content:  str,  events:  List[Event]):233  #  check  type234  if  not  isinstance(date,  Date):235  raise  ValueError(f"Attribute  ’date’  of  class  NewsArticle  must  be  a  Date  object,  but  received  type  {type(date)}")236  if  not  isinstance(title,  str):237  raise  ValueError(f"Attribute  ’title’  of  class  NewsArticle  must  be  a  string,  but  received  type  {type(title)}")238  if  not  isinstance(content,  str):239  raise  ValueError(f"Attribute  ’content’  of  class  NewsArticle  must  be  a  string,  but  received  type  {type(content)}")240  if  not  isinstance(events,  list):241  raise  ValueError(f"Attribute  ’events’  of  class  NewsArticle  must  be  a  list,  but  received  type  {type(events)}")242243  self.date  =  date244  self.title  =  title245  self.content  =  content246  self.events  =  events247248  def  __str__(self):249  return  f"{self.date}:\n{self.title}\n{self.content}"250251  def  __hash__(self):252  return  hash((self.date,  self.title,  self.content))253254  def  __eq__(self,  other):255  if  isinstance(other,  NewsArticle):256  return  self.date  ==  other.date  and  self.title  ==  other.title  and  self.content  ==  other.content257  return  False258259def  map_country_name_to_iso(name:  str)  ->  List[Country]:260  """261  Maps  a  country  name  to  the  most  likely  corresponding  Country  objects  with  ISO  codes.262263  Parameters:264  name  (str):  The  country  name  to  map.265266  Returns:267  List[Country]:  A  list  of  5  most  likely  Country  objects  sorted  by  relevance.268269  Example:270  >>>  map_country_name_to_iso("Korea")271  [Country(iso_code=ISOCode("KOR"),  name="Republic  of  Korea"),  Country(iso_code=ISOCode("PRK"),  name="Democratic  People’s  Republic  of  Korea")]272  """273  #  check  type274  if  not  isinstance(name,  str):275  raise  ValueError(f"Input  ’name’  must  be  a  string,  but  received  type  {type(name)}")276277  if  name  in  dict_countryname2iso:278  return  [Country(iso_code=ISOCode(dict_countryname2iso[name]),  name=name)]279  else:280  #  get  top  5  ISO  codes  with  the  highest  cosine  similarity281  name_embeddings  =  get_embedding(name)282  similarities  =  cosine_similarity(country_embeddings,  name_embeddings)283  top_indices  =  np.argsort(similarities)[::-1][:5]284  countries  =  []285  for  idx  in  top_indices:286  iso_code  =  list(dict_iso2alternames.keys())[idx]287  curr_name  =  dict_iso2alternames[iso_code][0]288  countries.append(Country(iso_code=ISOCode(iso_code),  name=curr_name))289  return  countries290291def  map_iso_to_country_name(iso_code:  ISOCode)  ->  str:292  """293  Maps  an  ISO  code  to  a  country  name.294295  Parameters:296  iso_code  (ISOCode):  The  ISO  code  to  map.297298  Returns:299  str:  The  corresponding  country  name.300301  Example:302  >>>  map_iso_to_country_name(ISOCode("CHN"))303  "China"304  """305  #  check  type306  if  not  isinstance(iso_code,  ISOCode):307  raise  ValueError(f"Input  ’iso_code’  must  be  an  ISOCode  object,  but  received  type  {type(iso_code)}")308309  return  dict_iso2alternames[iso_code.code][0]310311def  map_relation_description_to_cameo(description:  str)  ->  List[Relation]:312  """313  Maps  a  relation  description  to  the  most  likely  Relation  objects.314315  Parameters:316  description  (str):  The  relation  description  to  map.317318  Returns:319  List[Relation]:  A  list  of  5  most  likely  Relations  sorted  by  relevance.320321  Example:322  >>>  map_relation_description_to_cameo("Fight  with  guns")323  [Reltion(cameo_code=CAMEOCode("19"),  name="Fight",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups."),  Relation(cameo_code=CAMEOCode("193"),  name="Fight  with  small  arms  and  light  weapons",  description="Attack  using  small  arms  and  light  weapons  such  as  rifles,  machine-guns,  and  mortar  shells."),  Relation(cameo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified.")]324  """325  #  check  type326  if  not  isinstance(description,  str):327  raise  ValueError(f"Input  ’description’  must  be  a  string,  but  received  type  {type(description)}")328329  if  description  in  dict_relation2code:330  code  =  dict_relation2code[description]331  return  [Relation(cameo_code=CAMEOCode(code),  name=dict_code2relation[code][’Name’],  description=dict_code2relation[code][’Description’])]332  else:333  #  get  top  5  CAMEO  codes  with  the  highest  cosine  similarity334  description_embedding  =  get_embedding(description)335  similarities  =  cosine_similarity(relation_embeddings,  description_embedding)336  top_indices  =  np.argsort(similarities)[::-1][:5]337  relations  =  []338  for  idx  in  top_indices:339  code  =  list(dict_code2relation.keys())[idx]340  relations.append(Relation(cameo_code=CAMEOCode(code),  name=dict_code2relation[code][’Name’],  description=dict_code2relation[code][’Description’]))341  return  relations342343def  map_cameo_to_relation(cameo_code:  CAMEOCode)  ->  Relation:344  """345  Maps  a  CAMEO  code  to  a  relation,  including  its  name  and  description.346347  Parameters:348  cameo_code  (CAMEOCode):  The  CAMEO  code  to  map.349350  Returns:351  Relation:  The  corresponding  relation.352353  Example:354  >>>  map_cameo_to_relation(CAMEOCode("190"))355  Relation(cameo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified.")356  """357  #  check  type358  if  not  isinstance(cameo_code,  CAMEOCode):359  raise  ValueError(f"Input  ’cameo_code’  must  be  a  CAMEOCode  object,  but  received  type  {type(cameo_code)}")360361  info  =  dict_code2relation[cameo_code.code]362  return  Relation(cameo_code=cameo_code,  name=info[’Name’],  description=info[’Description’])363364def  get_parent_relation(cameo_code:  CAMEOCode)  ->  Relation:365  """366  Retrieves  the  parent  relation  of  a  given  relation  identified  by  CAMEO  code.367368  Parameters:369  cameo_code  (CAMEOCode):  The  CAMEO  code  of  the  relation  whose  parent  is  sought.  Only  second  level  relations  are  accepted.370371  Returns:372  Relation:  The  first  level  parent  relation.373374  Example:375  >>>  get_parent_relation(CAMEOCode("193"))376  Relation(cameo_code=CAMEOCode("19"),  name="Fight",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups.")377  """378  #  check  type379  if  not  isinstance(cameo_code,  CAMEOCode):380  raise  ValueError(f"Input  ’cameo_code’  must  be  a  CAMEOCode  object,  but  received  type  {type(cameo_code)}")381382  if  len(cameo_code.code)  !=  3:383  raise  ValueError("Only  second  level  relations  are  accepted,  but  received:  {}".format(cameo_code.code))384  parent_code  =cameo_code.code[:2]385  return  map_cameo_to_relation(CAMEOCode(parent_code))386387def  get_child_relations(cameo_code:  CAMEOCode)  ->  List[Relation]:388  """389  Retrieves  child  relations  of  a  given  relation  identified  by  CAMEO  code.390391  Parameters:392  cameo_code  (CAMEOCode):  The  CAMEO  code  of  the  relation  whose  children  are  sought.  Only  first  level  relations  are  accepted.393394  Returns:395  List[Relation]:  A  list  of  second  level  child  relations.396397  Example:398  >>>  get_child_relations(CAMEOCode("19"))399  [Relation(caemo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified."),  Relation(cameo_code=CAMEOCode("191"),  name="Impose  blockade  or  restrict  movement",  description="Prevent  entry  into  and/or  exit  from  a  territory  using  armed  forces."),  ...]400  """401  #  check  type402  if  not  isinstance(cameo_code,  CAMEOCode):403  raise  ValueError(f"Input  ’cameo_code’  must  be  a  CAMEOCode  object,  but  received  type  {type(cameo_code)}")404405  if  len(cameo_code.code)  !=  2:406  raise  ValueError("Only  first  level  relations  are  accepted,  but  received:  {}".format(cameo_code.code))407  children  =  []408  for  code,  info  in  dict_code2relation.items():409  if  code[:2]  ==  cameo_code.code  and  len(code)  ==  3:410  children.append(Relation(cameo_code=CAMEOCode(code),  name=info[’Name’],  description=info[’Description’]))411  return  children412413def  get_sibling_relations(cameo_code:  CAMEOCode)  ->  List[Relation]:414  """415  Retrieves  sibling  relations  of  a  given  relation  identified  by  CAMEO  code.416417  Parameters:418  cameo_code  (CAMEOCode):  The  CAMEO  code  of  the  relation  whose  siblings  are  sought.  Both  first  and  second  level  relations  are  accepted.419420  Returns:421  List[Relation]:  A  list  of  sibling  relations  at  the  same  level.422423  Example:424  >>>  get_sibling_relations(CAMEOCode("193"))425  [Relation(caemo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified."),  Relation(cameo_code=CAMEOCode("191"),  name="Impose  blockade  or  restrict  movement",  description="Prevent  entry  into  and/or  exit  from  a  territory  using  armed  forces."),  ...]426  """427  #  check  type428  if  not  isinstance(cameo_code,  CAMEOCode):429  raise  ValueError(f"Input  ’cameo_code’  must  be  a  CAMEOCode  object,  but  received  type  {type(cameo_code)}")430431  if  len(cameo_code.code)  ==  3:432  return  get_child_relations(get_parent_relation(cameo_code).cameo_code)433  elif  len(cameo_code.code)  ==  2:434  #  get  ’01’  to  ’20’  relations435  first_level_codes  =  [str(i).zfill(2)  for  i  in  range(1,  21)]436  relations  =  []437  for  code  in  first_level_codes:438  relations.append(map_cameo_to_relation(CAMEOCode(code)))439  return  relations440441def  count_events(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None)  ->  int:442  """443  Counts  the  number  of  events  in  the  knowledge  graph  based  on  specified  conditions.444445  Parameters:446  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  events.  If  None,  all  dates  are  included.447  head_entities  (Optional[List[ISOCode]]):  List  of  head  entity  ISO  codes  to  be  included.  If  None,  all  countries  are  included.448  tail_entities  (Optional[List[ISOCode]]):  List  of  tail  entity  ISO  codes  to  be  included.  If  None,  all  countries  are  included.449  relations  (Optional[List[CAMEOCode]]):  List  of  relation  CAMEO  codes  to  be  included.  If  first  level  relations  are  listed,  all  second  level  relations  under  them  are  included.  If  None,  all  relations  are  included.450451  Returns:452  int:  Count  of  unique  events  matching  the  conditions.453454  Example:455  >>>  count_events(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=None,  relations=[CAMEOCode("010")])456  4457  """458  #  check  type459  if  date_range  and  not  isinstance(date_range,  DateRange):460  raise  ValueError(f"Input  ’date_range’  must  be  a  DateRange  object,  but  received  type  {type(date_range)}")461  if  head_entities  and  not  isinstance(head_entities,  list):462  raise  ValueError(f"Input  ’head_entities’  must  be  a  list,  but  received  type  {type(head_entities)}")463  if  head_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  head_entities):464  raise  ValueError(f"Elements  in  ’head_entities’  must  be  ISOCode  objects")465  if  tail_entities  and  not  isinstance(tail_entities,  list):466  raise  ValueError(f"Input  ’tail_entities’  must  be  a  list,  but  received  type  {type(tail_entities)}")467  if  tail_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  tail_entities):468  raise  ValueError(f"Elements  in  ’tail_entities’  must  be  ISOCode  objects")469  if  relations  and  not  isinstance(relations,  list):470  raise  ValueError(f"Input  ’relations’  must  be  a  list,  but  received  type  {type(relations)}")471  if  relations  and  not  all(isinstance(code,  CAMEOCode)  for  code  in  relations):472  raise  ValueError(f"Elements  in  ’relations’  must  be  CAMEOCode  objects")473474  #  process  data_kg  by  filtering  based  on  the  specified  conditions475  curr_data  =  data_kg.copy()476  curr_data.drop_duplicates(subset=[’QuadEventCode’],  inplace=True)477  curr_data  =  curr_data[curr_data[’DateStr’]  <=  DEFAULT_END_DATE]478  if  date_range:479  curr_data  =  curr_data[(curr_data[’DateStr’]  >=  date_range.start_date.date)  &  (curr_data[’DateStr’]  <=  date_range.end_date.date)]480  if  head_entities:481  curr_data  =  curr_data[curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  head_entities])]482  if  tail_entities:483  curr_data  =  curr_data[curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  tail_entities])]484  if  relations:485  #  if  first  level  relations  are  listed,  include  all  second  level  relations  under  them486  for  code  in  relations:487  if  len(code.code)  ==  2:488  relations.extend([CAMEOCode(c)  for  c  in  dict_code2relation  if  c[:2]  ==  code.code  and  len(c)  ==  3])489  curr_data  =  curr_data[curr_data[’EventBaseCode’].isin([code.code  for  code  in  relations])]490  return  len(curr_data)491492def  get_events(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None,  text_description:  Optional[str]  =  None)  ->  List[Event]:493  """494  Retrieves  events  from  the  knowledge  graph  based  on  specified  conditions.495  Inherits  common  filter  parameters  from  count_events.  See  count_events  for  more  details  on  these  parameters.496497  Additional  Parameters:498  text_description  (Optional[str]):  Textual  description  to  match  with  the  source  news  articles  of  events.  If  None,  the  returned  events  are  sorted  by  date  in  descending  order;  otherwise,  sorted  by  relevance  of  the  source  news  article  to  the  description.499500  Returns:501  List[Event]:  A  list  of  maximum  30  events  matching  the  specified  conditions.502503  Example:504  >>>  get_events(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=None,  relations=[CAMEOCode("010")],  text_description="economic  trade")505  [Event(date=Date("2022-01-15"),  head_entity=ISOCode("USA"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("CAN"),  Event(date=Date("2022-01-10"),  head_entity=ISOCode("CHN"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("USA"),  ...]506  """507  #  check  type508  if  date_range  and  not  isinstance(date_range,  DateRange):509  raise  ValueError(f"Input  ’date_range’  must  be  a  DateRange  object,  but  received  type  {type(date_range)}")510  if  head_entities  and  not  isinstance(head_entities,  list):511  raise  ValueError(f"Input  ’head_entities’  must  be  a  list,  but  received  type  {type(head_entities)}")512  if  head_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  head_entities):513  raise  ValueError(f"Elements  in  ’head_entities’  must  be  ISOCode  objects")514  if  tail_entities  and  not  isinstance(tail_entities,  list):515  raise  ValueError(f"Input  ’tail_entities’  must  be  a  list,  but  received  type  {type(tail_entities)}")516  if  tail_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  tail_entities):517  raise  ValueError(f"Elements  in  ’tail_entities’  must  be  ISOCode  objects")518  if  relations  and  not  isinstance(relations,  list):519  raise  ValueError(f"Input  ’relations’  must  be  a  list,  but  received  type  {type(relations)}")520  if  relations  and  not  all(isinstance(code,  CAMEOCode)  for  code  in  relations):521  raise  ValueError(f"Elements  in  ’relations’  must  be  CAMEOCode  objects")522  if  text_description  and  not  isinstance(text_description,  str):523  raise  ValueError(f"Input  ’text_description’  must  be  a  string,  but  received  type  {type(text_description)}")524525  #  process  data_kg  by  filtering  based  on  the  specified  conditions526  curr_data  =  data_kg.copy()527  curr_data  =  curr_data[curr_data[’DateStr’]  <=  DEFAULT_END_DATE]528  if  date_range:529  curr_data  =  curr_data[(curr_data[’DateStr’]  >=  date_range.start_date.date)  &  (curr_data[’DateStr’]  <=  date_range.end_date.date)]530  if  head_entities:531  curr_data  =  curr_data[curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  head_entities])]532  if  tail_entities:533  curr_data  =  curr_data[curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  tail_entities])]534  if  relations:535  #  if  first  level  relations  are  listed,  include  all  second  level  relations  under  them536  for  code  in  relations:537  if  len(code.code)  ==  2:538  relations.extend([CAMEOCode(c)  for  c  in  dict_code2relation  if  c[:2]  ==  code.code  and  len(c)  ==  3])539  curr_data  =  curr_data[curr_data[’EventBaseCode’].isin([code.code  for  code  in  relations])]540  if  not  text_description:541  #  get  max  30  events  from  the  filtered  data542  events  =  []543  curr_data.drop_duplicates(subset=[’QuadEventCode’],  inplace=True)544  #  sorted  by  date  in  descending  order545  curr_data.sort_values(by=’DateStr’,  ascending=False,  inplace=True)546  count  =  0547  for  _,  row  in  curr_data.iterrows():548  if  count  >=  30:549  break550  events.append(Event(date=Date(row[’DateStr’]),  head_entity=ISOCode(row[’Actor1CountryCode’]),  relation=CAMEOCode(row[’EventBaseCode’]),  tail_entity=ISOCode(row[’Actor2CountryCode’])))551  return  events[:30]552  else:553  #  concat  the  Docids  list  of  current  data  to  get  the  news  articles554  docids_list  =  [eval(docids)  for  docids  in  curr_data[’Docids’].unique().tolist()]555  docids  =  list(set([item  for  sublist  in  docids_list  for  item  in  sublist]))556  docids  =  [str(docid)  for  docid  in  docids]557  news_articles  =  data_news[data_news[’Docid’].isin(docids)]558  #  get  the  max  30  docids  with  the  highest  BM25  score  to  the  text_description559  corpus  =  news_articles[’Title’]  +  ’  ’  +  news_articles[’Text’]560  tokenized_corpus  =  [doc.split("  ")  for  doc  in  corpus]561  bm25  =  BM25Okapi(tokenized_corpus)562  tokenized_query  =  text_description.split("  ")563  doc_scores  =  bm25.get_scores(tokenized_query)564  top_indices  =  np.argsort(doc_scores)[::-1][:30]565  news_articles  =  news_articles.iloc[top_indices]566  docids  =  news_articles[’Docid’].tolist()567  #  get  max  30  events  from  the  filtered  data568  events  =  set()569  for  docid  in  docids:570  if  len(events)  >=  30:571  break572  doc_curr_data  =  curr_data[curr_data[’Docid’]  ==  docid]573  #  reverse  the  order  of  the  events  to  get  the  latest  events  first574  doc_curr_data  =  doc_curr_data.sort_values(by=’DateStr’,  ascending=False)575  for  _,  row  in  doc_curr_data.iterrows():576  events.add(Event(date=Date(row[’DateStr’]),  head_entity=ISOCode(row[’Actor1CountryCode’]),  relation=CAMEOCode(row[’EventBaseCode’]),  tail_entity=ISOCode(row[’Actor2CountryCode’])))577  return  list(events)578579def  get_entity_distribution(date_range:  Optional[DateRange]  =  None,  involved_relations:  Optional[List[CAMEOCode]]  =  None,  interacted_entities:  Optional[List[ISOCode]]  =  None,  entity_role:  Optional[str]  =  None)  ->  Dict[ISOCode,  int]:580  """581  Gets  the  distribution  of  entities  in  the  knowledge  graph  under  specified  conditions.582583  Parameters:584  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  events.  If  None,  all  dates  are  included.585  involved_relations  (Optional[List[CAMEOCode]]):  List  of  relations  that  the  returned  entities  must  be  involved  in  any  of.  If  first  level  relations  are  listed,  all  second  level  relations  under  them  are  included.  If  None,  all  relations  are  included.586  interacted_entities  (Optional[List[ISOCode]]):  List  of  entities  that  the  returned  entities  must  have  interacted  with  any  of.  If  None,  all  entities  are  included.587  entity_role  (Optional[EntityRole]):  Specifies  the  role  of  the  returned  entity  in  the  events.  Options  are  ’head’,  ’tail’,  or  ’both’.  If  ’both’  or  None,  the  returned  entity  can  be  either  head  or  tail.588589  Returns:590  Dict[ISOCode,  int]:  A  dictionary  mapping  returned  entities’  ISO  codes  to  the  number  of  events  with  the  specified  conditions  in  which  they  are  involved,  sorted  by  counts  in  descending  order.591592  Example:593  >>>  get_entity_distribution(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  involved_relations=[CAMEOCode("010")],  interacted_entities=[ISOCode("USA"),  ISOCode("CHN")],  entity_role="tail")594  {ISOCode("USA"):  3,  ISOCode("CHN"):  1}595  """596  #  check  type597  if  date_range  and  not  isinstance(date_range,  DateRange):598  raise  ValueError(f"Input  ’date_range’  must  be  a  DateRange  object,  but  received  type  {type(date_range)}")599  if  involved_relations  and  not  isinstance(involved_relations,  list):600  raise  ValueError(f"Input  ’involved_relations’  must  be  a  list,  but  received  type  {type(involved_relations)}")601  if  involved_relations  and  not  all(isinstance(code,  CAMEOCode)  for  code  in  involved_relations):602  raise  ValueError(f"Elements  in  ’involved_relations’  must  be  CAMEOCode  objects")603  if  interacted_entities  and  not  isinstance(interacted_entities,  list):604  raise  ValueError(f"Input  ’interacted_entities’  must  be  a  list,  but  received  type  {type(interacted_entities)}")605  if  interacted_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  interacted_entities):606  raise  ValueError(f"Elements  in  ’interacted_entities’  must  be  ISOCode  objects")607  if  entity_role  and  entity_role  not  in  [’head’,  ’tail’,  ’both’]:608  raise  ValueError(f"Input  ’entity_role’  must  be  a  string  ’head’,  ’tail’,  or  ’both’,  but  received:  {entity_role}")609610  #  process  data_kg  by  filtering  based  on  the  specified  conditions611  curr_data  =  data_kg.copy()612  curr_data.drop_duplicates(subset=[’QuadEventCode’],  inplace=True)613  curr_data  =  curr_data[curr_data[’DateStr’]  <=  DEFAULT_END_DATE]614  if  date_range:615  curr_data  =  curr_data[(curr_data[’DateStr’]  >=  date_range.start_date.date)  &  (curr_data[’DateStr’]  <=  date_range.end_date.date)]616  if  involved_relations:617  #  if  first  level  relations  are  listed,  include  all  second  level  relations  under  them618  for  code  in  involved_relations:619  if  len(code.code)  ==  2:620  involved_relations.extend([CAMEOCode(c)  for  c  in  dict_code2relation  if  c[:2]  ==  code.code  and  len(c)  ==  3])621  curr_data  =  curr_data[curr_data[’EventBaseCode’].isin([code.code  for  code  in  involved_relations])]622  if  interacted_entities:623  if  entity_role==’head’:624  curr_data  =  curr_data[curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  interacted_entities])]625  elif  entity_role==’tail’:626  curr_data  =  curr_data[curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  interacted_entities])]627  else:628  curr_data  =  curr_data[(curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  interacted_entities]))  |  (curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  interacted_entities]))]629  #  count  the  number  of  events  for  each  entity630  entity_counts  =  curr_data[’Actor1CountryCode’]._append(curr_data[’Actor2CountryCode’]).value_counts()631  entity_counts  =  entity_counts.to_dict()632  #  sort  the  dictionary  by  values  in  descending  order633  entity_counts  =  dict(sorted(entity_counts.items(),  key=lambda  item:  item[1],  reverse=True))634  entity_counts  =  {ISOCode(key):  value  for  key,  value  in  entity_counts.items()}635  return  entity_counts636637def  get_relation_distribution(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None)  ->  Dict[CAMEOCode,  int]:638  """639  Gets  the  distribution  of  second  level  relations  in  the  knowledge  graph  under  specified  conditions.640641  Parameters:642  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  events.  If  None,  all  dates  are  included.643  head_entities  (Optional[List[ISOCode]]):  List  of  head  entities  that  the  events  must  involve  any  of.  If  None,  all  head  entities  are  included.644  tail_entities  (Optional[List[ISOCode]]):  List  of  tail  entities  that  the  events  must  involve  any  of.  If  None,  all  tail  entities  are  included.645646  Returns:647  Dict[CAMEOCode,  int]:  A  dictionary  mapping  second  level  relations’  CAMEO  codes  to  the  number  of  events  with  the  specified  conditions  in  which  they  are  involved,  sorted  by  counts  in  descending  order.648649  Example:650  >>>  get_relation_distribution(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=None)651  {CAMEOCode("010"):  3,  CAMEOCode("011"):  1}652  """653  #  check  type654  if  date_range  and  not  isinstance(date_range,  DateRange):655  raise  ValueError(f"Input  ’date_range’  must  be  a  DateRange  object,  but  received  type  {type(date_range)}")656  if  head_entities  and  not  isinstance(head_entities,  list):657  raise  ValueError(f"Input  ’head_entities’  must  be  a  list,  but  received  type  {type(head_entities)}")658  if  head_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  head_entities):659  raise  ValueError(f"Elements  in  ’head_entities’  must  be  ISOCode  objects")660  if  tail_entities  and  not  isinstance(tail_entities,  list):661  raise  ValueError(f"Input  ’tail_entities’  must  be  a  list,  but  received  type  {type(tail_entities)}")662  if  tail_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  tail_entities):663  raise  ValueError(f"Elements  in  ’tail_entities’  must  be  ISOCode  objects")664665  #  process  data_kg  by  filtering  based  on  the  specified  conditions666  curr_data  =  data_kg.copy()667  curr_data.drop_duplicates(subset=[’QuadEventCode’],  inplace=True)668  curr_data  =  curr_data[curr_data[’DateStr’]  <=  DEFAULT_END_DATE]669  if  date_range:670  curr_data  =  curr_data[(curr_data[’DateStr’]  >=  date_range.start_date.date)  &  (curr_data[’DateStr’]  <=  date_range.end_date.date)]671  if  head_entities:672  curr_data  =  curr_data[curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  head_entities])]673  if  tail_entities:674  curr_data  =  curr_data[curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  tail_entities])]675  #  count  the  number  of  events  for  each  relation676  relation_counts  =  curr_data[’EventBaseCode’].value_counts()677  relation_counts  =  relation_counts.to_dict()678  #  sort  the  dictionary  by  values  in  descending  order679  relation_counts  =  dict(sorted(relation_counts.items(),  key=lambda  item:  item[1],  reverse=True))680  relation_counts  =  {CAMEOCode(key):  value  for  key,  value  in  relation_counts.items()}681  return  relation_counts682683def  count_news_articles(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None,  keywords:  Optional[List[str]]  =  None)  ->  int:684  """685  Counts  the  number  of  news  articles  based  on  specified  conditions.686687  Parameters:688  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  news  articles.  If  None,  all  dates  are  included.689  head_entities  (Optional[List[ISOCode]]):  At  least  one  of  the  entities  must  be  mentioned  in  the  articles  and  be  the  head  entity  in  the  events.  If  None,  all  entities  are  included.690  tail_entities  (Optional[List[ISOCode]]):  At  least  one  of  the  entities  must  be  mentioned  in  the  articles  and  be  the  tail  entity  in  the  events.  If  None,  all  entities  are  included.691  relations  (Optional[List[CAMEOCode]]):  At  least  one  of  the  relations  must  be  mentioned  in  the  articles.  If  first  level  relations  are  listed,  all  second  level  relations  under  them  are  included.  If  None,  all  relations  are  included.692  keywords  (Optional[List[str]]):  At  least  one  of  the  keywords  must  be  present  in  the  articles.  If  None,  all  articles  are  included.693694  Returns:695  int:  The  count  of  news  articles  matching  the  conditions.696697  Example:698  >>>  count_news_articles(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=[ISOCode("USA"),  ISOCode("CHN")],  relations=[CAMEOCode("010")],  keywords=["trade"])699  2700  """701  #  check  type702  if  date_range  and  not  isinstance(date_range,  DateRange):703  raise  ValueError(f"Input  ’date_range’  must  be  a  DateRange  object,  but  received  type  {type(date_range)}")704  if  head_entities  and  not  isinstance(head_entities,  list):705  raise  ValueError(f"Input  ’head_entities’  must  be  a  list,  but  received  type  {type(head_entities)}")706  if  head_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  head_entities):707  raise  ValueError(f"Elements  in  ’head_entities’  must  be  ISOCode  objects")708  if  tail_entities  and  not  isinstance(tail_entities,  list):709  raise  ValueError(f"Input  ’tail_entities’  must  be  a  list,  but  received  type  {type(tail_entities)}")710  if  tail_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  tail_entities):711  raise  ValueError(f"Elements  in  ’tail_entities’  must  be  ISOCode  objects")712  if  relations  and  not  isinstance(relations,  list):713  raise  ValueError(f"Input  ’relations’  must  be  a  list,  but  received  type  {type(relations)}")714  if  relations  and  not  all(isinstance(code,  CAMEOCode)  for  code  in  relations):715  raise  ValueError(f"Elements  in  ’relations’  must  be  CAMEOCode  objects")716  if  keywords  and  not  isinstance(keywords,  list):717  raise  ValueError(f"Input  ’keywords’  must  be  a  list,  but  received  type  {type(keywords)}")718  if  keywords  and  not  all(isinstance(keyword,  str)  for  keyword  in  keywords):719  raise  ValueError(f"Elements  in  ’keywords’  must  be  strings")720721  #  process  data_kg  by  filtering  based  on  the  specified  conditions722  curr_data  =  data_kg.copy()723  curr_data.drop_duplicates(subset=[’QuadEventCode’],  inplace=True)724  curr_data  =  curr_data[curr_data[’DateStr’]  <=  DEFAULT_END_DATE]725  if  date_range:726  curr_data  =  curr_data[(curr_data[’DateStr’]  >=  date_range.start_date.date)  &  (curr_data[’DateStr’]  <=  date_range.end_date.date)]727  if  head_entities:728  curr_data  =  curr_data[curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  head_entities])]729  if  tail_entities:730  curr_data  =  curr_data[curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  tail_entities])]731  if  relations:732  #  if  first  level  relations  are  listed,  include  all  second  level  relations  under  them733  for  code  in  relations:734  if  len(code.code)  ==  2:735  relations.extend([CAMEOCode(c)  for  c  in  dict_code2relation  if  c[:2]  ==  code.code  and  len(c)  ==  3])736  curr_data  =  curr_data[curr_data[’EventBaseCode’].isin([code.code  for  code  in  relations])]737  #  concat  the  Docids  list  of  current  data  to  get  the  news  articles738  docids_list  =  [eval(docids)  for  docids  in  curr_data[’Docids’].unique().tolist()]739  docids  =  list(set([item  for  sublist  in  docids_list  for  item  in  sublist]))740  docids  =  [str(docid)  for  docid  in  docids]741  news_articles  =  data_news[data_news[’Docid’].isin(docids)]742  if  keywords:743  #  filter  the  news  articles  that  contain  at  least  one  of  the  keywords  in  the  title  or  text  string744  news_articles  =  news_articles[news_articles[’Title’].str.contains(’|’.join(keywords),  case=False)  |  news_articles[’Text’].str.contains(’|’.join(keywords),  case=False)]745  return  len(news_articles)746747def  get_news_articles(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None,  keywords:  Optional[List[str]]  =  None,  text_description:  Optional[str]  =  None)  ->  List[Tuple[Date,  str]]:748  """749  Retrieves  news  articles  based  on  specified  conditions.750  Inherits  common  filter  parameters  from  count_news_articles.  See  count_news_articles  for  more  details  on  these  parameters.751752  Additional  Parameters:753  text_description  (Optional[str]):  Textual  description  to  match  with  the  news  articles.  If  None,  the  returned  articles  are  sorted  by  date  in  descending  order;  otherwise,  sorted  by  relevance  to  the  description.754755  Returns:756  List[Tuple[Date,  str]]:  A  list  of  maximum  15  news  articles  matching  the  specified  conditions,  each  represented  by  a  tuple  of  date  and  title.757758  Example:759  >>>  get_news_articles(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=[ISOCode("USA"),  ISOCode("CHN")],  relations=[CAMEOCode("010")],  keywords=["trade"],  text_description="Economic  trade  is  encouraged  between  USA  and  China.")760  [(NewsArticle.date=Date("2022-01-15"),  NewsArticle.title="China  and  USA  sign  trade  deal"),  (NewsArticle.date=Date("2022-01-10"),  NewsArticle.title="Trade  agreement  between  USA  and  China")]761  """762  #  check  type763  if  date_range  and  not  isinstance(date_range,  DateRange):764  raise  ValueError(f"Input  ’date_range’  must  be  a  DateRange  object,  but  received  type  {type(date_range)}")765  if  head_entities  and  not  isinstance(head_entities,  list):766  raise  ValueError(f"Input  ’head_entities’  must  be  a  list,  but  received  type  {type(head_entities)}")767  if  head_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  head_entities):768  raise  ValueError(f"Elements  in  ’head_entities’  must  be  ISOCode  objects")769  if  tail_entities  and  not  isinstance(tail_entities,  list):770  raise  ValueError(f"Input  ’tail_entities’  must  be  a  list,  but  received  type  {type(tail_entities)}")771  if  tail_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  tail_entities):772  raise  ValueError(f"Elements  in  ’tail_entities’  must  be  ISOCode  objects")773  if  relations  and  not  isinstance(relations,  list):774  raise  ValueError(f"Input  ’relations’  must  be  a  list,  but  received  type  {type(relations)}")775  if  relations  and  not  all(isinstance(code,  CAMEOCode)  for  code  in  relations):776  raise  ValueError(f"Elements  in  ’relations’  must  be  CAMEOCode  objects")777  if  keywords  and  not  isinstance(keywords,  list):778  raise  ValueError(f"Input  ’keywords’  must  be  a  list,  but  received  type  {type(keywords)}")779  if  keywords  and  not  all(isinstance(keyword,  str)  for  keyword  in  keywords):780  raise  ValueError(f"Elements  in  ’keywords’  must  be  strings")781  if  text_description  and  not  isinstance(text_description,  str):782  raise  ValueError(f"Input  ’text_description’  must  be  a  string,  but  received  type  {type(text_description)}")783784  #  process  data_kg  by  filtering  based  on  the  specified  conditions785  curr_data  =  data_kg.copy()786  curr_data.drop_duplicates(subset=[’QuadEventCode’],  inplace=True)787  curr_data  =  curr_data[curr_data[’DateStr’]  <=  DEFAULT_END_DATE]788  if  date_range:789  curr_data  =  curr_data[790  (curr_data[’DateStr’]  >=  date_range.start_date.date)  &  (curr_data[’DateStr’]  <=  date_range.end_date.date)]791  if  head_entities:792  curr_data  =  curr_data[curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  head_entities])]793  if  tail_entities:794  curr_data  =  curr_data[curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  tail_entities])]795  if  relations:796  #  if  first  level  relations  are  listed,  include  all  second  level  relations  under  them797  for  code  in  relations:798  if  len(code.code)  ==  2:799  relations.extend([CAMEOCode(c)  for  c  in  dict_code2relation  if  c[:2]  ==  code.code  and  len(c)  ==  3])800  curr_data  =  curr_data[curr_data[’EventBaseCode’].isin([code.code  for  code  in  relations])]801  docids_list  =  [eval(docids)  for  docids  in  curr_data[’Docids’].unique().tolist()]802  docids  =  list(set([item  for  sublist  in  docids_list  for  item  in  sublist]))803  docids  =  [str(docid)  for  docid  in  docids]804  news_articles  =  data_news[data_news[’Docid’].isin(docids)]805  if  keywords:806  #  filter  the  news  articles  that  contain  at  least  one  of  the  keywords  in  the  title  or  text  string807  news_articles  =  news_articles[news_articles[’Title’].str.contains(’|’.join(keywords),  case=False)  |  news_articles[’Text’].str.contains(’|’.join(keywords),  case=False)]808  if  not  text_description:809  #  get  max  15  news  articles  from  the  filtered  data810  #  sorted  by  date  in  descending  order811  news_articles.sort_values(by=’Date’,  ascending=False,  inplace=True)812  news_articles  =  news_articles[[’Date’,  ’Title’]].head(15)813  return  [(Date(row[’Date’]),  row[’Title’])  for  _,  row  in  news_articles.iterrows()]814  else:815  #  get  the  max  15  news  articles  with  the  highest  BM25  score  to  the  text_description816  corpus  =  news_articles[’Title’]  +  ’  ’  +  news_articles[’Text’]817  tokenized_corpus  =  [doc.split("  ")  for  doc  in  corpus]818  bm25  =  BM25Okapi(tokenized_corpus)819  tokenized_query  =  text_description.split("  ")820  doc_scores  =  bm25.get_scores(tokenized_query)821  top_indices  =  np.argsort(doc_scores)[::-1][:15]822  news_articles  =  news_articles.iloc[top_indices]823  return  [(Date(row[’Date’]),  row[’Title’])  for  _,  row  in  news_articles.iterrows()]824825def  browse_news_article(date:  Date,  title:  str)  ->  str:826  """827  Retrieves  the  full  text  of  a  news  article  by  its  title.828829  Parameters:830  date  (Date):  The  date  of  the  news  article  to  retrieve.831  title  (str):  The  title  of  the  news  article  to  retrieve.832833  Returns:834  str:  The  date,  the  title  and  full  contents  of  the  news  article.835836  Example:837  >>>  browse_news_article(Date("2022-01-10"),  "Trade  agreement  between  USA  and  China")838  2022-01-10:839  Trade  agreement  between  USA  and  China840  On  January  10,  2022,  a  trade  agreement  was  signed  between  the  USA  and  China  to  promote  economic  cooperation...841  """842  #  check  type843  if  not  isinstance(date,  Date):844  raise  ValueError(f"Input  ’date’  must  be  a  Date  object,  but  received  type  {type(date)}")845  if  not  isinstance(title,  str):846  raise  ValueError(f"Input  ’title’  must  be  a  string,  but  received  type  {type(title)}")847848  #  process  data_news  to  find  the  news  article  with  the  specified  date  and  title849  curr_data  =  data_news[(data_news[’Date’]  ==  date.date)  &  (data_news[’Title’]  ==  title)]850  if  len(curr_data)  ==  0:851  raise  ValueError(f"No  news  article  found  with  the  specified  date  {date.date}  and  title  {title}")852  return  f"{date}:\n{title}\n{curr_data[’Text’].values[0]}"’