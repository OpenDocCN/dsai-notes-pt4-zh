- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-09-08 18:51:29'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '日期: 2024-09-08 18:51:29'
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'C2HLSC: LLMs 能否弥合软件与硬件设计之间的差距？'
- en: 来源：[https://ar5iv.labs.arxiv.org/html/2406.09233](https://ar5iv.labs.arxiv.org/html/2406.09233)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://ar5iv.labs.arxiv.org/html/2406.09233](https://ar5iv.labs.arxiv.org/html/2406.09233)
- en: Luca Collini , Siddharth Garg , Ramesh Karri
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Luca Collini，Siddharth Garg，Ramesh Karri
- en: Abstract
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 摘要
- en: High Level Synthesis (HLS) tools offer rapid hardware design from C code, but
    their compatibility is limited by code constructs. This paper investigates Large
    Language Models (LLMs) for refactoring C code into HLS-compatible formats. We
    present several case studies by using an LLM to rewrite C code for NIST 800-22
    randomness tests, a QuickSort algorithm and AES-128 into HLS-synthesizable c.
    The LLM iteratively transforms the C code guided by user prompts, implementing
    functions like streaming data and hardware-specific signals. This evaluation demonstrates
    the LLM’s potential to assist hardware design refactoring regular C code into
    HLS synthesizable C code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 高级综合（HLS）工具通过 C 代码提供快速的硬件设计，但它们的兼容性受到代码结构的限制。本文探讨了大语言模型（LLMs）在将 C 代码重构为 HLS
    兼容格式中的应用。我们通过使用 LLM 将 C 代码重写为 NIST 800-22 随机性测试、快速排序算法和 AES-128 的 HLS 可综合 C 的几个案例研究。LLM
    在用户提示的指导下迭代地转换 C 代码，实现了如数据流和硬件特定信号等功能。这项评估展示了 LLM 在协助硬件设计方面的潜力，将常规 C 代码重构为 HLS
    可综合 C 代码。
- en: 'Index Terms:'
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 索引词：
- en: 'Chip Design, LLM, Catapult HLS, Cryptocores.^†^†publicationid: pubid: 979-8-3503-7608-1/24$31.00
    ©2024 IEEE'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '芯片设计，LLM，Catapult HLS，加密核心。^†^†出版号: pubid: 979-8-3503-7608-1/24$31.00 ©2024
    IEEE'
- en: I Introduction
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I 引言
- en: 'High-Level Synthesis (HLS) is a promising chip design methodology that enables
    rapid hardware design from high-level specifications. HLS tools convert a high-level
    specification (C, C++) into an register transfer level (RTL) description [[1](#bib.bib1)]:
    (1) HLS uses state-of-the-art compilers (e.g., LLVM or GCC) to extract a high-level
    control data flow graph (CDFG). (2) They then assign operations to time (scheduling)
    and space (allocation and binding) to determine the micro-architecture. HLS tools
    also support pragmas and directives to explore architectural choices for a C specification.
    Software and hardware paradigms are different. Hence HLS tools support a subset
    of C constructs that map to hardware. For instance, hardware does not support
    dynamic memory allocation and recursive constructs. Outputs can only communicate
    through parameters, arrays sizes need to be static, limit support for pointers
    and multiple processes can be modeled through independent function instances mapped
    into hardware blocks. Designers manually refactor C code to remove these constructs
    and make it compatible with HLS tools. However, manual refactoring is time consuming,
    and error prone [[2](#bib.bib2)].'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 高级综合（HLS）是一种有前景的芯片设计方法论，它能够从高级规格中快速设计硬件。HLS 工具将高级规格（C、C++）转换为寄存器传输级（RTL）描述 [[1](#bib.bib1)]：（1）HLS
    使用最先进的编译器（如 LLVM 或 GCC）来提取高级控制数据流图（CDFG）。 (2) 然后，它们将操作分配到时间（调度）和空间（分配和绑定）以确定微架构。HLS
    工具还支持 pragmas 和指令，以探索 C 规格的架构选择。软件和硬件范式不同。因此，HLS 工具支持一部分映射到硬件的 C 结构。例如，硬件不支持动态内存分配和递归结构。输出只能通过参数通信，数组大小需要静态，限制对指针的支持，多进程可以通过映射到硬件块的独立函数实例来建模。设计师手动重构
    C 代码以删除这些结构，使其与 HLS 工具兼容。然而，手动重构既费时又容易出错 [[2](#bib.bib2)]。
- en: I-A Large Language Models (LLMs)
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I-A 大语言模型（LLMs）
- en: LLMs are trained on massive amounts of text data and excel at tasks like code
    generation and translation, particularly in languages like C, Cc++, and Python.
    However, their performance suffers on Hardware Description Languages (HDLs) like
    Verilog or VHDL due to the limited amount of training data available in those
    languages [[3](#bib.bib3)]. This paper explores LLMs for refactoring C code, transforming
    it into a subset C compatible with HLS tools. LLMs can analyze generic C code
    and refactor it to HLS-synthesizable C. This leverages the power of LLMs in generating
    and manipulating C code and bypassing their limitations in generating HDL code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: LLMs 在大量文本数据上进行训练，在代码生成和翻译等任务中表现出色，特别是在 C、C++ 和 Python 等语言中。然而，由于这些语言中可用的训练数据有限，它们在硬件描述语言（HDLs）如
    Verilog 或 VHDL 上的表现不佳 [[3](#bib.bib3)]。本文探讨了 LLMs 用于重构 C 代码，将其转换为与 HLS 工具兼容的子集
    C。LLMs 可以分析通用 C 代码并将其重构为 HLS 可综合 C。这利用了 LLMs 在生成和操控 C 代码方面的能力，绕过了其在生成 HDL 代码时的限制。
- en: I-B Contributions and Roadmap
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I-B 贡献和路线图
- en: 'LLMs have limited success in generating Verilog code [[4](#bib.bib4), [5](#bib.bib5)].
    This is due to the scarcity online of hardware description language (HDL) data
    compared to code in C, C++ and other software. We explore use of LLMs to assist
    developers in refactoring generic C specification into synthesizable C that is
    compatible with HLS as shown in Figure [1](#S1.F1 "Figure 1 ‣ I-B Contributions
    and Roadmap ‣ I Introduction ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware
    Design Gap?"). Out work has two main contributions. First, we present case studies
    of deriving HLS-usable C codes derived from generic C codes. The study compares
    development time and resource use achieved using LLM-assisted development in lieu
    of cumbersome manual methods. Second, we discuss the results and present a prototype
    hands-free C2HLSC LLM-based tool, which will be open-source. The paper road-map
    is as follows: 1. Section [II](#S2 "II Related Work ‣ C2HLSC: Can LLMs Bridge
    the Software-to-Hardware Design Gap?") presents related work, highlighting the
    novelties of the approach. 2. Section [III](#S3 "III Case Study ‣ C2HLSC: Can
    LLMs Bridge the Software-to-Hardware Design Gap?") illustrates the case study,
    presenting the tasks and methodologies and results. 3. Section [IV](#S4 "IV Hands-Free
    C2HSLC Prototype ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?")
    presents the prototype hands-free C2HLSC tool, discussing capabilities and limitations.
    4. Section [V](#S5 "V Conclusions ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware
    Design Gap?") concludes the paper.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 'LLM 在生成 Verilog 代码方面取得的成功有限 [[4](#bib.bib4), [5](#bib.bib5)]。这是因为与 C、C++ 和其他软件代码相比，硬件描述语言
    (HDL) 数据在线上较为稀缺。我们探讨了使用 LLM 来协助开发者将通用 C 规范重构为与 HLS 兼容的可综合 C，如图 [1](#S1.F1 "图 1
    ‣ I-B 贡献与路线图 ‣ I 介绍 ‣ C2HLSC: LLM 是否可以弥合软件与硬件设计的差距？") 所示。我们的工作有两个主要贡献。首先，我们展示了从通用
    C 代码中推导出适用于 HLS 的 C 代码的案例研究。该研究比较了使用 LLM 辅助开发与繁琐的手动方法在开发时间和资源使用方面的差异。其次，我们讨论了结果并展示了一个原型免手动
    C2HLSC LLM 工具，该工具将开源。论文的路线图如下：1. [II](#S2 "II 相关工作 ‣ C2HLSC: LLM 是否可以弥合软件与硬件设计的差距？")
    节展示相关工作，突出了方法的创新。2. [III](#S3 "III 案例研究 ‣ C2HLSC: LLM 是否可以弥合软件与硬件设计的差距？") 节说明了案例研究，介绍了任务、方法和结果。3.
    [IV](#S4 "IV 免手动 C2HSLC 原型 ‣ C2HLSC: LLM 是否可以弥合软件与硬件设计的差距？") 节展示了免手动 C2HLSC 工具的原型，讨论了其能力和局限性。4.
    [V](#S5 "V 结论 ‣ C2HLSC: LLM 是否可以弥合软件与硬件设计的差距？") 节总结了论文。'
- en: '![Refer to caption](img/1dbbe43ac3d13f93384e2a2eba246631.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![参见说明](img/1dbbe43ac3d13f93384e2a2eba246631.png)'
- en: 'Figure 1: Flow for the proposed C2HLSC approach.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：所提出的 C2HLSC 方法的流程。
- en: II Related Work
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: II 相关工作
- en: Previous work explored LLMs to design hardware. Verigen fine-tuned an LLM to
    improve its ability to produce Verilog [[4](#bib.bib4)]. The fine tuned LLM though
    performed marginally better than ChatGPT3.5-turbo with an accuracy $\sim$65%.
    ChipChat [[5](#bib.bib5)] was the first to tapeout a design written by an AI model.
    However, the single shot performance of the AI model was low and needed several
    iterations in order for the LLM to get to the correct result. We target generating
    synthesizable C code as LLMs are more capable at C than at hardware languages [[3](#bib.bib3)].
    In [[6](#bib.bib6)] an LLM was used to write Amaranth HDL, a Python based HDL,
    that allows to model synchronous logic at the RTL. For this reason, while it uses
    a high level language, its semantics are close to verilog, and targets hardware
    designers. While the LLM came up with parts of the design, it fell short in some
    tasks, like generating interfaces. Software developers use HLS to design hardware
    and as such the code only provides the functionality¹¹1Whereas the hardware architecture
    and interface specification are instructed using HLS pragmas and directives..
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的工作探索了使用 LLMs 设计硬件。Verigen 对 LLM 进行了微调，以提高其生成 Verilog 的能力 [[4](#bib.bib4)]。虽然微调后的
    LLM 的表现略优于 ChatGPT3.5-turbo，准确率约为 $\sim$65%。ChipChat [[5](#bib.bib5)] 是第一个由 AI
    模型生成并完成 tapeout 的设计。然而，AI 模型的一次性表现较低，需要多次迭代才能获得正确结果。我们的目标是生成可综合的 C 代码，因为 LLM 在
    C 语言上比在硬件语言上更具能力 [[3](#bib.bib3)]。在 [[6](#bib.bib6)] 中，LLM 被用来编写 Amaranth HDL，一种基于
    Python 的 HDL，允许在 RTL 上建模同步逻辑。出于这个原因，虽然它使用的是高级语言，但其语义接近于 Verilog，并且针对硬件设计师。虽然 LLM
    提出了部分设计，但在生成接口等任务上表现不佳。软件开发者使用 HLS 设计硬件，因此代码只提供功能¹¹1而硬件架构和接口规范则通过 HLS 指令和指示进行指导。.
- en: III Case Study
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: III 案例研究
- en: III-A Overview
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: III-A 概述
- en: 'We evaluated Gemini LLM [[7](#bib.bib7)] to transform C code into synthesizable
    C suitable for HLS. The evaluation consisted of two tasks. The first task involved
    rewriting reference C implementations of the Frequency test, Frequency Block test,
    Cumulative Sums, and Overlapping Template Matching tests from the NIST 800-22
    suite [[8](#bib.bib8)] into synthesizable C code. These tests are designed to
    assess the randomness of a sequence. A first challenge arose due to the inherent
    differences between software and hardware implementations. The reference C implementations
    operate on a pre-loaded random sequence stored in memory. Conversely, hardware
    implementations require on-the-fly analysis, processing the sequence bit-by-bit.
    This necessitates modifying the code to handle a streaming data input rather than
    a pre-loaded array. A second challenge stemmed from the p-value calculation. In
    software context, the precise p-value is critical and computed on-the-fly. However,
    since the hardware implementations primarily focus on distinguishing random from
    non-random sequences one can simplify this by pre-computing certain values offline
    and reducing the computational burden during on-the-fly analysis. Both these challenges
    are non-trivial for human developers and LLMs. The second task assesses the LLM’s
    ability to rewrite code constructs that are not supported by HLS tools. We used
    two algorithms: a QuickSort containing pointers and recursion [[9](#bib.bib9)],
    and the AES128 encrypt from the tinyAES library [[10](#bib.bib10)] with six functions.
    The goal was for the LLM to generate code without pointers and recursion, making
    it suitable for (Catapult) HLS.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们评估了 Gemini LLM [[7](#bib.bib7)] 来将 C 代码转换为适用于 HLS 的可综合 C 代码。评估包含两个任务。第一个任务涉及将
    NIST 800-22 套件中的频率测试、频率块测试、累积和测试和重叠模板匹配测试的参考 C 实现 [[8](#bib.bib8)] 改写为可综合 C 代码。这些测试旨在评估序列的随机性。第一个挑战源于软件和硬件实现之间的固有差异。参考
    C 实现操作在预加载的存储在内存中的随机序列上。相比之下，硬件实现需要实时分析，将序列逐位处理。这要求修改代码以处理流数据输入，而不是预加载的数组。第二个挑战来自
    p 值计算。在软件环境中，精确的 p 值至关重要，并且需要实时计算。然而，由于硬件实现主要关注区分随机序列和非随机序列，因此可以通过离线预计算某些值并减少实时分析中的计算负担来简化这一过程。这两个挑战对于人类开发者和
    LLM 都并非简单。第二个任务评估了 LLM 改写不被 HLS 工具支持的代码结构的能力。我们使用了两个算法：一个包含指针和递归的 QuickSort [[9](#bib.bib9)]
    和来自 tinyAES 库的 AES128 加密 [[10](#bib.bib10)]，后者包含六个函数。目标是使 LLM 生成不包含指针和递归的代码，使其适合（Catapult）HLS。
- en: III-B Methodology
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: III-B 方法论
- en: 'We broke down the process into small steps to allow the LLM to transform the
    original C into synthesizable C. For the first task we followed the following
    steps for the three tests: 1. Present task to the LLM: ”Hi, I have this code in
    C that I need to rewrite such that I can use it with an HLS tool to generate hardware.”.
    2. Ask to remove print statements. 3. Ask to rewrite the function as a streaming
    interface: ”Now I need to rewrite the function such that it will get inferred
    as a streaming interface, to do so, I need to get rid of the epsilon array and
    have the function take a parameter to accept a bit at each function call.” 4.
    Ask to remove math steps to be computed offline (in some cases, ask to write a
    script to run them). 5. Ask to add is_random and valid signals as parameters.
    6. Ask to optimize data types using arbitrary width integers and fixed point arithmetic
    using HLSLIBS [[11](#bib.bib11)]. 7. Ask to write a main function to test the
    function passing random bits. 8. Ask to fix mistakes passing errors from HLS tool.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将过程分解为小步骤，以便 LLM 将原始 C 转换为可综合 C。对于第一个任务，我们遵循以下步骤进行三个测试：1. 向 LLM 介绍任务：“你好，我有这段
    C 代码，我需要将其改写，以便我可以使用 HLS 工具生成硬件。” 2. 请求去除打印语句。 3. 请求将函数改写为流接口：“现在我需要将函数改写为流接口，以便能够推断出来，为此，我需要去掉
    epsilon 数组，并使函数接收一个参数以接受每次函数调用中的一位数据。” 4. 请求去除离线计算的数学步骤（在某些情况下，请求编写一个脚本来运行这些步骤）。
    5. 请求添加 is_random 和 valid 信号作为参数。 6. 请求使用任意宽度整数和固定点算术进行数据类型优化，使用 HLSLIBS [[11](#bib.bib11)]。
    7. 请求编写一个主函数以测试传递随机位的函数。 8. 请求修复传递 HLS 工具中的错误。
- en: 'For QuickSort we followed these steps: 1. Present the task to the LLM: ”Hi,
    I have this code in C that I need to rewrite such that I can use it with an HLS
    tool to generate hardware.”. 2. Ask to remove print statements. 3. Ask to rewrite
    function without using pointers. 4. Ask to rewrite function without recursion.
    5. Ask to fix array sizes in function parameters. 6. Ask to optimize data types
    using arbitrary width integers and fixed point arithmetic using HLSLIBS. 7. Ask
    to write a main function to test the function passing an array to sort. 8. Ask
    to fix mistakes by passing errors from HLS tool.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于QuickSort，我们遵循了以下步骤：1. 向LLM提出任务：“你好，我有这段C代码需要重写，以便我可以用HLS工具生成硬件。”。2. 请求去除打印语句。3.
    请求重写函数，不使用指针。4. 请求重写函数，不使用递归。5. 请求修正函数参数中的数组大小。6. 请求使用任意宽度整数和固定点算术通过HLSLIBS优化数据类型。7.
    请求编写一个主函数来测试函数，传递一个数组进行排序。8. 请求通过传递HLS工具的错误来修复错误。
- en: 'For the AES 128 from tinyAES [[10](#bib.bib10)] we followed the following steps
    asking to fix one function at a time: 1. Present the task to the LLM: ”Hi, I have
    this code in C that I need to rewrite such that I can use it with an HLS tool
    to generate hardware.”. 2. Ask to rewrite for loops with fixed bounds and no pointer
    usage. 3. Ask to rewrite the function parameters to using fixed size arrays. 4.
    Ask to fix eventual mistakes passing errors from the HLS tool. When the LLM responds
    with sub optimal answers, we check alternative answers, and if none fully satisfied
    the request we instruct the LLM with additional prompts including more details
    pointing out where the problem was, and, if not sufficient, hinting at possible
    solutions.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于tinyAES中的AES 128 [[10](#bib.bib10)]，我们遵循以下步骤，逐个请求修复一个函数：1. 向LLM提出任务：“你好，我有这段C代码需要重写，以便我可以用HLS工具生成硬件。”。2.
    请求将for循环重写为固定边界且不使用指针。3. 请求将函数参数重写为使用固定大小的数组。4. 请求通过传递HLS工具的错误来修复可能的错误。当LLM提供次优答案时，我们检查替代答案，如果没有一个完全满足请求，我们会用额外的提示，包括更多细节指出问题所在，如果还不够，提示可能的解决方案。
- en: III-C Results
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: III-C 结果
- en: 'The aim of this study is to evaluate how LLMs perform at rewriting C code such
    that it is HLS synthesizable²²2Finding pragmas to optimize the hardware architecture
    is an orthogonal problem for which LLMs could be employed, left as future work..
    We run the code through Catapult HLS to check correctness after synthesis, but
    we do not focus on the resource utilization, as it is depends on the architectural
    decisions. We targeted the nangate45 library at 50 MHz with a synchronous active
    high reset for all the tests. The LLM was able to rewrite all C codes to run on
    Catapult HLS. We performed simulations with Modelsim to check result equivalency
    between the original C and the synthesized Verilog obtained from the LLM-generated
    C. The original C codes (without printfs) and the HLS C code rewritten by the
    LLM are in Appendix [-A](#A0.SS1 "-A LLM generated HLS compatible C codes ‣ C2HLSC:
    Can LLMs Bridge the Software-to-Hardware Design Gap?"), links to the conversations
    are in Appendix [-C](#A0.SS3 "-C Conversations ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware
    Design Gap?"). We can classify the errors in the LLM generated code into compile/synthesis
    errors, and functional errors. The former where easier to fix instructing the
    LLM with the error message and affected line. For functional errors caught by
    the failing tests, it was harder for the LLM to identify the cause and propose
    a fix. Manual effort was needed to point out sources of the issues for the LLM
    to propose an effective fix. Typical functional issues where mistaken loop readjustments,
    widths and arbitrary widths types.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '本研究的目的是评估LLM在重写C代码以使其具备HLS合成能力方面的表现²²2找到优化硬件架构的pragma是一个正交问题，LLM可以被用来解决，但留待未来工作中进行。我们通过Catapult
    HLS运行代码以检查合成后的正确性，但不关注资源利用率，因为它依赖于架构决策。我们在所有测试中以50 MHz的频率和同步高电平复位针对nangate45库进行测试。LLM能够重写所有C代码以便在Catapult
    HLS上运行。我们使用Modelsim进行仿真，以检查原始C代码和LLM生成的C代码合成后的Verilog之间的结果等效性。原始C代码（没有printf语句）和LLM重写的HLS
    C代码见附录[-A](#A0.SS1 "-A LLM生成的HLS兼容C代码 ‣ C2HLSC: LLM能否弥合软件与硬件设计的差距？")，对话链接见附录[-C](#A0.SS3
    "-C 对话 ‣ C2HLSC: LLM能否弥合软件与硬件设计的差距？")。我们可以将LLM生成的代码中的错误分为编译/合成错误和功能错误。前者更容易修复，通过向LLM提供错误消息和受影响的行来进行。对于被失败测试捕获的功能错误，LLM更难识别原因并提出修复方案。需要人工努力指出问题来源，以便LLM提出有效的修复方案。典型的功能问题包括错误的循环调整、宽度和任意宽度类型。'
- en: III-C1 C2HLSC of NIST 800-22 Randomness Tests
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-C1 C2HLSC 的 NIST 800-22 随机性测试
- en: 'The LLM performed well in most steps, especially in rewriting the function
    as a streaming interface, which is one of the more complex steps. Figure [2](#S3.F2
    "Figure 2 ‣ III-C1 C2HLSC of NIST 800-22 Randomness Tests ‣ III-C Results ‣ III
    Case Study ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?") shows
    the streaming interface rewriting for the Frequency Block test. For all the three
    tests this step was performed correctly at the first shot. However, the LLM did
    stumble on tasks that seemd more trivial. For example, when asked to remove the
    abs function in this line of code (abs(sum.to_int()) <= SUM_THRESHOLD); it came
    up with convoluted ways that did not work like (sum.to_int()   sum_type;  //  true  for  signed5typedef  ac_int  count_type;  //  false  for  unsigned6typedef  ac_int  bit_type;7void8Frequency_Bit(bit_type  *bit,  bit_type  *valid,  bit_type  *result)9{10  static  sum_type  sum  =  0;11  static  count_type  count  =  0;12  sum  +=  (*bit)  ?  sum_type(1)  :  sum_type(-1);13  count++;14  if  (count  ==  TARGET_BITS)  {15  //  Check  if  sum  is  within  the  threshold  range16  *result  =  (sum  <=  THRESHOLD)  &&  (sum  >=  -THRESHOLD);17  *valid  =  1;18  count  =  0;19  sum  =  0;20  }  else  {21  *result  =  0;22  *valid  =  0;23}}'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '1原始c代码（去除printf语句后）\end{lstlisting}2\vspace{-7pt}3\end{subfigure}4\begin{subfigure}[t]{.9\columnwidth}5\begin{lstlisting}[language=c]6void
    Frequency(int n)7{8  int i;9  double f, s_obs, p_value, sum, sqrt2 = 1.41421356237309504880;10  sum
    = 0.0;11  for (i=0; i sum_type;  //
    true表示有符号5typedef ac_int count_type;  // false表示无符号6typedef ac_int bit_type;7void8Frequency_Bit(bit_type *bit, bit_type *valid, bit_type *result)9{10  static
    sum_type sum = 0;11  static count_type count = 0;12  sum += (*bit) ? sum_type(1)
    : sum_type(-1);13  count++;14  if (count == TARGET_BITS) {15  // 检查sum是否在阈值范围内16  *result
    = (sum <= THRESHOLD) && (sum >= -THRESHOLD);17  *valid = 1;18  count = 0;19  sum
    = 0;20  } else {21  *result = 0;22  *valid = 0;23}}'
- en: 'Figure 6: Human-in-the-loop Monobit'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：人机协作单比特
- en: '1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  BlockFrequency(int  M,  int  n)7{8  int  i,  j,  N,  blockSum;9  double  p_value,  sum,  pi,  v,  chi_squared;10  N  =  n/M;  /*  #  OF  SUBSTRING  BLOCKS  */11  sum  =  0.0;1213  for  (  i=0;  i  bit,  ac_int&  valid,  ac_int&  result)  {2  static  ac_int  blockSum  =  0;3  static  ac_fixed  sum  =  0.0;4  ac_fixed  pi_fixed,  v;5  static  ac_int  i  =  0;6  static  ac_int  j  =  0;7  if  (j  ==  0)  {8  i++;9  blockSum  =  0;10  }11  blockSum  +=  bit;12  j++;13  if  (j  ==  BLOCK_SIZE)  {14  pi_fixed  =  (ac_fixed)  blockSum  /  BLOCK_SIZE;15  const  ac_fixed  half  =  0.5;16  v  =  pi_fixed  -  half;17  sum  +=  v  *  v;18  j  =  0;19  }20  if  (i  ==  NUM_BLOCKS)  {21  const  ac_fixed  threshold  =  13.8155  /  512.0;22  valid  =  true;23  result  =  (sum  <  threshold)  ?  0  :  1;24  }  else  {25  valid  =  false;26  result  =  0;27}}'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '1原始c代码（去除printf语句后）\end{lstlisting}2\vspace{-7pt}3\end{subfigure}4\begin{subfigure}[t]{.9\columnwidth}5\begin{lstlisting}[language=c]6void
    BlockFrequency(int M, int n)7{8  int i, j, N, blockSum;9  double p_value, sum,
    pi, v, chi_squared;10  N = n/M;  /* 子字符串块的数量 */11  sum = 0.0;1213  for (i=0; i bit, ac_int& valid, ac_int&
    result) {2  static ac_int blockSum = 0;3  static ac_fixed
    sum = 0.0;4  ac_fixed pi_fixed, v;5  static ac_int i =
    0;6  static ac_int j = 0;7  if (j == 0) {8  i++;9  blockSum = 0;10  }11  blockSum
    += bit;12  j++;13  if (j == BLOCK_SIZE) {14  pi_fixed = (ac_fixed)
    blockSum / BLOCK_SIZE;15  const ac_fixed half = 0.5;16  v = pi_fixed
    - half;17  sum += v * v;18  j = 0;19  }20  if (i == NUM_BLOCKS) {21  const ac_fixed threshold = 13.8155 / 512.0;22  valid = true;23  result = (sum < threshold)
    ? 0 : 1;24  } else {25  valid = false;26  result = 0;27}}'
- en: 'Figure 7: Human-in-the-loop Monobit Block'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：人机协作单比特块
- en: '1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  CumulativeSums(int  n)  {7  int  S,  sup,  inf,  z,  zrev,  k;8  double  sum1,  sum2,  p_value;9  S  =  0;  sup  =  0;  inf  =  0;10  for  (k  =  0;  k  <  n;  k++)  {11  epsilon[k]  ?  S++  :  S--;12  if  (S  >  sup)  sup++;13  if  (S  <  inf)  inf--;14  z  =  (sup  >  -inf)  ?  sup  :  -inf;15  zrev  =  (sup  -  S  >  S  -  inf)  ?  sup  -  S  :  S  -  inf;}16  sum1  =  0.0;  //  forward17  for  (k  =  (-n  /  z  +  1)  /  4;  k  <=  (n  /  z  -  1)  /  4;  k++)  {18  sum1  +=  cephes_normal(((4  *  k  +  1)  *  z)  /  sqrt(n));19  sum1  -=  cephes_normal(((4  *  k  -  1)  *  z)  /  sqrt(n));}20  sum2  =  0.0;21  for  (k  =  (-n  /  z  -  3)  /  4;  k  <=  (n  /  z  -  1)  /  4;  k++)  {22  sum2  +=  cephes_normal(((4  *  k  +  3)  *  z)  /  sqrt(n));23  sum2  -=  cephes_normal(((4  *  k  +  1)  *  z)  /  sqrt(n));}24  p_value  =  1.0  -  sum1  +  sum2;25  sum1  =  0.0;  //  backwards26  for  (k  =  (-n  /  zrev  +  1)  /  4;  k  <=  (n  /  zrev  -  1)  /  4;  k++)  {27  sum1  +=  cephes_normal(((4  *  k  +  1)  *  zrev)  /  sqrt(n));28  sum1  -=  cephes_normal(((4  *  k  -  1)  *  zrev)  /  sqrt(n));}29  sum2  =  0.0;30  for  (k  =  (-n  /  zrev  -  3)  /  4;  k  <=  (n  /  zrev  -  1)  /  4;  k++)  {31  sum2  +=  cephes_normal(((4  *  k  +  3)  *  zrev)  /  sqrt(n));32  sum2  -=  cephes_normal(((4  *  k  +  1)  *  zrev)  /  sqrt(n));}33  p_value  =  1.0  -  sum1  +  sum2;}1HLS  compatible  code  rewritten  by  the  LLM1#define  N  200002#define  THRESHOLD  (ac_int)3973void  CumulativeSums_Streaming(ac_int  bit,  ac_int*  output,  ac_int*  valid)  {4  static  ac_int  S  =  0;5  static  ac_int  sup  =  0;6  static  ac_int  inf  =  0;7  S  +=  bit  ?  1  :  -1;8  sup  =  sup  >  S  ?  sup  :  S;9  inf  =  inf  <  S  ?  inf  :  S;10  //  Logic  for  output  based  on  sup  and  inf11  static  ac_int  processed_bits  =  0;12  processed_bits++;13  if  (processed_bits  ==  N)  {14  *output  =  (sup  <  THRESHOLD  &&  inf  >  -THRESHOLD)  ?  1  :  0;15  *valid  =  (processed_bits  ==  N);16  processed_bits  =  0;17  }  else  {18  *output  =  0;19  *valid  =  0;20}}'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '1 原始  c  代码  （去除 printf 后） \end{lstlisting}2\vspace{-7pt}3 \end{subfigure}4
    \begin{subfigure}[t]{.9\columnwidth}5 \begin{lstlisting}[language=c]6void  CumulativeSums(int  n)  {7  int  S,  sup,  inf,  z,  zrev,  k;8  double  sum1,  sum2,  p_value;9  S  =  0;  sup  =  0;  inf  =  0;10  for  (k  =  0;  k  <  n;  k++)  {11  epsilon[k]  ?  S++  :  S--;12  if  (S  >  sup)  sup++;13  if  (S  <  inf)  inf--;14  z  =  (sup  >  -inf)  ?  sup  :  -inf;15  zrev  =  (sup  -  S  >  S  -  inf)  ?  sup  -  S  :  S  -  inf;}16  sum1  =  0.0;  //  向前17  for  (k  =  (-n  /  z  +  1)  /  4;  k  <=  (n  /  z  -  1)  /  4;  k++)  {18  sum1  +=  cephes_normal(((4  *  k  +  1)  *  z)  /  sqrt(n));19  sum1  -=  cephes_normal(((4  *  k  -  1)  *  z)  /  sqrt(n));}20  sum2  =  0.0;21  for  (k  =  (-n  /  z  -  3)  /  4;  k  <=  (n  /  z  -  1)  /  4;  k++)  {22  sum2  +=  cephes_normal(((4  *  k  +  3)  *  z)  /  sqrt(n));23  sum2  -=  cephes_normal(((4  *  k  +  1)  *  z)  /  sqrt(n));}24  p_value  =  1.0  -  sum1  +  sum2;25  sum1  =  0.0;  //  向后26  for  (k  =  (-n  /  zrev  +  1)  /  4;  k  <=  (n  /  zrev  -  1)  /  4;  k++)  {27  sum1  +=  cephes_normal(((4  *  k  +  1)  *  zrev)  /  sqrt(n));28  sum1  -=  cephes_normal(((4  *  k  -  1)  *  zrev)  /  sqrt(n));}29  sum2  =  0.0;30  for  (k  =  (-n  /  zrev  -  3)  /  4;  k  <=  (n  /  zrev  -  1)  /  4;  k++)  {31  sum2  +=  cephes_normal(((4  *  k  +  3)  *  zrev)  /  sqrt(n));32  sum2  -=  cephes_normal(((4  *  k  +  1)  *  zrev)  /  sqrt(n));}33  p_value  =  1.0  -  sum1  +  sum2;}1
    HLS  兼容  代码  由  LLM1  重写#define  N  200002#define  THRESHOLD  (ac_int)3973void  CumulativeSums_Streaming(ac_int  bit,  ac_int*  output,  ac_int*  valid)  {4  static  ac_int  S  =  0;5  static  ac_int  sup  =  0;6  static  ac_int  inf  =  0;7  S  +=  bit  ?  1  :  -1;8  sup  =  sup  >  S  ?  sup  :  S;9  inf  =  inf  <  S  ?  inf  :  S;10  //  基于  sup  和  inf  的  输出
    逻辑11  static  ac_int  processed_bits  =  0;12  processed_bits++;13  if  (processed_bits  ==  N)  {14  *output  =  (sup  <  THRESHOLD  &&  inf  >  -THRESHOLD)  ?  1  :  0;15  *valid  =  (processed_bits  ==  N);16  processed_bits  =  0;17  }  else  {18  *output  =  0;19  *valid  =  0;20}}'
- en: 'Figure 8: Human-in-the-loop Cusums'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8：人类在回路中的 Cusums
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  OverlappingTemplateMatchings(int  m,  int  n)7{8int  i,  k,  match;9double  W_obs,  eta,  sum,  chi2,  p_value,  lambda;10int  M,  N,  j,  K  =  5;11unsigned  int  nu[6]  =  {  0,  0,  0,  0,  0,  0  };12//double  pi[6]  =  {  0.143783,  0.139430,  0.137319,  0.124314,  0.106209,  0.348945  };13double  pi[6]  =  {  0.364091,  0.185659,  0.139381,  0.100571,  0.0704323,  0.139865  };14BitSequence  *sequence;15M  =  1032;16N  =  n/M;17if  (  (sequence  =  (BitSequence  *)  calloc(m,  sizeof(BitSequence)))  ==  NULL  )  {18  //  ERROR19}20else21  for  (  i=0;  i(1056300.0)6void  OverlappingTemplateMatchings(int  epsilon,  ac_int  *is_random_out,  ac_int  *valid_output_out)  {7  static  ac_int  W_obs  =  0;8  static  ac_int  nu[6]  =  {0,  0,  0,  0,  0,  0};9  static  ac_int  shift_reg[9]  =  {0};10  static  ac_int  n_counter  =  0;11  static  const  ac_fixed  pi[6]  =  {12  2.746566,13  ac_fixed(5.386218),  ac_fixed(7.17457),14  ac_fixed(9.94322),  ac_fixed(14.198031),  ac_fixed(7.1497515)15  };16ac_fixed  chi2  =  0;17  for  (int  i  =  8;  i  >  0;  i--)  {18  shift_reg[i]  =  shift_reg[i  -  1];19  }20  shift_reg[0]  =  ac_int(epsilon);21  ac_int  match  =  1;22  for  (int  i  =  0;  i  <  9;  i++)  {23  if  (shift_reg[i]  !=  1)  {24  match  =  0;25  break;26  }27  }28  if  (match)  {29  W_obs++;30  }31  n_counter++;32  if  (n_counter  %  M  ==  M-1)  {33  if  (W_obs  <=  4)  {34  nu[(int)W_obs]++;35  }  else  {36  nu[5]++;37  }38  W_obs  =  0;39  }40  *is_random_out  =  0;41  *valid_output_out  =  0;42  if  (n_counter  ==  N)  {43  for  (int  i  =  0;  i  <  6;  i++)  {44  chi2  +=  nu[i]  *  nu  [i]  *  pi[i];45  }46  *is_random_out  =  chi2  <  CHI2_THRESHOLD_FIXED;47  *valid_output_out  =  true;48  for  (int  i  =  0;  i  <  6;  i++)  {49  nu[i]  =  0;50  }51  n_counter  =  0;52}}
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS兼容代码，由LLM重写1#define N 10485762#define M 10323#define N_WIDTH 204#define
    M_WIDTH 105#define CHI2_THRESHOLD_FIXED ac_fixed(1056300.0)6void
    OverlappingTemplateMatchings(int epsilon, ac_int *is_random_out, ac_int *valid_output_out) {7  static ac_int W_obs = 0;8  static ac_int nu[6] = {0, 0, 0, 0, 0, 0};9  static ac_int shift_reg[9] = {0};10  static
    ac_int n_counter = 0;11  static const ac_fixed
    pi[6] = {12  2.746566,13  ac_fixed(5.386218), ac_fixed(7.17457),14  ac_fixed(9.94322), ac_fixed(14.198031),
    ac_fixed(7.1497515)15  };16ac_fixed chi2 = 0;17  for (int
    i = 8; i > 0; i--) {18  shift_reg[i] = shift_reg[i - 1];19  }20  shift_reg[0]
    = ac_int(epsilon);21  ac_int match = 1;22  for (int i = 0;
    i < 9; i++) {23  if (shift_reg[i] != 1) {24  match = 0;25  break;26  }27  }28  if
    (match) {29  W_obs++;30  }31  n_counter++;32  if (n_counter % M == M-1) {33  if
    (W_obs <= 4) {34  nu[(int)W_obs]++;35  }  else  {36  nu[5]++;37  }38  W_obs =
    0;39  }40  *is_random_out = 0;41  *valid_output_out = 0;42  if (n_counter == N)
    {43  for (int i = 0; i < 6; i++) {44  chi2 += nu[i] * nu[i] * pi[i];45  }46  *is_random_out
    = chi2 < CHI2_THRESHOLD_FIXED;47  *valid_output_out = true;48  for (int i = 0;
    i < 6; i++) {49  nu[i] = 0;50  }51  n_counter = 0;52}}
- en: 'Figure 10: Human-in-the-loop Overlapping'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '图 10: 人工环节重叠'
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  swap(int*  a,  int*  b)  {7  int  temp  =  *a;8  *a  =  *b;9  *b  =  temp;  }10  int  partition(int  arr[],  int  low,  int  high)  {11  int  pivot  =  arr[low];12  int  i  =  low;13  int  j  =  high;14  while  (i  <  j)  {15  while  (arr[i]  <=  pivot  &&  i  <=  high  -  1)  {16  i++;17  }18  while  (arr[j]  >  pivot  &&  j  >=  low  +  1)  {19  j--;20  }21  if  (i  <  j)  {22  swap(&arr[i],  &arr[j]);23  }24  }25  swap(&arr[low],  &arr[j]);26  return  j;  }27void  quickSort(int  arr[],  int  low,  int  high)  {28  if  (low  <  high)  {29  int  partitionIndex  =  partition(arr,  low,  high);30  quickSort(arr,  low,  partitionIndex  -  1);31  quickSort(arr,  partitionIndex  +  1,  high);32}  }
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 1原始c代码（去掉printf后）\end{lstlisting}2\vspace{-7pt}3\end{subfigure}4\begin{subfigure}[t]{.9\columnwidth}5\begin{lstlisting}[language=c]6void
    swap(int* a, int* b) {7  int temp = *a;8  *a = *b;9  *b = temp;  }10  int partition(int
    arr[], int low, int high) {11  int pivot = arr[low];12  int i = low;13  int j
    = high;14  while (i < j) {15  while (arr[i] <= pivot && i <= high - 1) {16  i++;17  }18  while
    (arr[j] > pivot && j >= low + 1) {19  j--;20  }21  if (i < j) {22  swap(&arr[i],
    &arr[j]);23  }24  }25  swap(&arr[low], &arr[j]);26  return j;  }27void quickSort(int
    arr[], int low, int high) {28  if (low < high) {29  int partitionIndex = partition(arr,
    low, high);30  quickSort(arr, low, partitionIndex - 1);31  quickSort(arr, partitionIndex
    + 1, high);32}  }
- en: 'Figure 11: Quicksort original'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11: 快速排序原始'
- en: 1HLS  compatible  code  rewritten  by  the  LLM1int  partition(int  arr[MAX_SIZE],  int  low,  int  high)  {}2  int  pivot  =  arr[low];3  int  i  =  low;4  int  j  =  high;5  if  (low  ==  high)  {6  return  low;7  }8  while  (i  <  j)  {9  while  (arr[i]  <=  pivot  &&  i  <=  high  -  1)  {10  i++;11  }12  while  (arr[j]  >  pivot  &&  j  >=  low  +  1)  {13  j--;14  }15  if  (i  <  j)  {16  int  temp  =  arr[i];17  arr[i]  =  arr[j];18  arr[j]  =  temp;19  }20  }21  int  temp  =  arr[low];22  arr[low]  =  arr[j];23  arr[j]  =  temp;24  return  j;25}26void  quickSort(int  arr[MAX_SIZE],  int  low,  int  high)  {27int  stack[100];28int  top  =  -1;29if  (high  -  low  +  1  >  MAX_SIZE)  {30  return;31}32stack[++top]  =  low;33stack[++top]  =  high;34while  (top  >=  0)  {35  high  =  stack[top--];36  low  =  stack[top--];37  int  partitionIndex  =  partition(arr,  low,  high);38  if  (partitionIndex  +  1  <  high)  {39  stack[++top]  =  partitionIndex  +  1;40  stack[++top]  =  high;41  }42  if  (low  <  partitionIndex  -  1)  {43  stack[++top]  =  low;44  stack[++top]  =  partitionIndex  -  1;45}}}
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS 兼容代码由 LLM1int 重写 partition(int arr[MAX_SIZE], int low, int high) {}2 int
    pivot = arr[low];3 int i = low;4 int j = high;5 if (low == high) {6 return low;7
    }8 while (i < j) {9 while (arr[i] <= pivot && i <= high - 1) {10 i++;11 }12 while
    (arr[j] > pivot && j >= low + 1) {13 j--;14 }15 if (i < j) {16 int temp = arr[i];17
    arr[i] = arr[j];18 arr[j] = temp;19 }20 }21 int temp = arr[low];22 arr[low] =
    arr[j];23 arr[j] = temp;24 return j;25}26void quickSort(int arr[MAX_SIZE], int
    low, int high) {27int stack[100];28int top = -1;29if (high - low + 1 > MAX_SIZE)
    {30 return;31}32stack[++top] = low;33stack[++top] = high;34while (top >= 0) {35
    high = stack[top--];36 low = stack[top--];37 int partitionIndex = partition(arr,
    low, high);38 if (partitionIndex + 1 < high) {39 stack[++top] = partitionIndex
    + 1;40 stack[++top] = high;41 }42 if (low < partitionIndex - 1) {43 stack[++top]
    = low;44 stack[++top] = partitionIndex - 1;45}}}
- en: 'Figure 12: Human-in-the-loop Quicksort'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12：人机交互快速排序
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  Cipher(state_t*  state,  const  uint8_t*  RoundKey)7{8  uint8_t  round  =  0;9  AddRoundKey(0,  state,  RoundKey);10  for  (round  =  1;  ;  ++round)11  {12  SubBytes(state);13  ShiftRows(state);14  if  (round  ==  Nr)  {15  break;16  }17  MixColumns(state);18  AddRoundKey(round,  state,  RoundKey);19  }20  AddRoundKey(Nr,  state,  RoundKey);21}1HLS  compatible  code  rewritten  by  the  LLM1void  Cipher(state_t  state[4][4],  const  uint8_t  RoundKey[AES_keyExpSize])  {2  uint8_t  round;3  AddRoundKey(0,  state,  RoundKey);4  for  (round  =  1;  round  <=  Nr;  ++round)  {5  SubBytes(state);6  ShiftRows(state);7  if  (round  <  Nr)  {8  MixColumns(state);9  }10  AddRoundKey(round,  state,  RoundKey);11  }12}
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 1原始 C 代码（移除 printf 后） \end{lstlisting}2\vspace{-7pt}3 \end{subfigure}4 \begin{subfigure}[t]{.9\columnwidth}5
    \begin{lstlisting}[language=c]6static void Cipher(state_t* state, const uint8_t*
    RoundKey)7{8 uint8_t round = 0;9 AddRoundKey(0, state, RoundKey);10 for (round
    = 1; ; ++round)11 {12 SubBytes(state);13 ShiftRows(state);14 if (round == Nr)
    {15 break;16 }17 MixColumns(state);18 AddRoundKey(round, state, RoundKey);19 }20
    AddRoundKey(Nr, state, RoundKey);21}1HLS 兼容代码由 LLM1 重写2void Cipher(state_t state[4][4],
    const uint8_t RoundKey[AES_keyExpSize]) {3 uint8_t round;4 AddRoundKey(0, state,
    RoundKey);5 for (round = 1; round <= Nr; ++round) {6 SubBytes(state);7 ShiftRows(state);8
    if (round < Nr) {9 MixColumns(state);10 }11 AddRoundKey(round, state, RoundKey);12
    }}
- en: 'Figure 13: Human-in-the-loop AES Cipher'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13：人机交互 AES 加密算法
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  MixColumns(state_t*  state)7{8  uint8_t  i;9  uint8_t  Tmp,  Tm,  t;10  for  (i  =  0;  i  <  4;  ++i)11  {12  t  =  (*state)[i][0];13  Tmp  =  (*state)[i][0]  ^  (*state)[i][1]  ^  (*state)[i][2]  ^  (*state)[i][3]  ;14  Tm  =  (*state)[i][0]  ^  (*state)[i][1]  ;15  Tm  =  xtime(Tm);  (*state)[i][0]  ^=  Tm  ^  Tmp  ;16  Tm  =  (*state)[i][1]  ^  (*state)[i][2]  ;17  Tm  =  xtime(Tm);  (*state)[i][1]  ^=  Tm  ^  Tmp  ;18  Tm  =  (*state)[i][2]  ^  (*state)[i][3]  ;19  Tm  =  xtime(Tm);  (*state)[i][2]  ^=  Tm  ^  Tmp  ;20  Tm  =  (*state)[i][3]  ^  t  ;21  Tm  =  xtime(Tm);  (*state)[i][3]  ^=  Tm  ^  Tmp  ;22  }23}1HLS  compatible  code  rewritten  by  the  LLM1static  void  MixColumns(state_t  state[4][4])  {2  uint8_t  i,  Tmp,  Tm,  t;3  for  (i  =  0;  i  <  4;  ++i)  {4  t  =  state[i][0];5  Tmp  =  state[i][0]  ^  state[i][1]  ^  state[i][2]  ^  state[i][3];6  Tm  =  state[i][0]  ^  state[i][1];  Tm  =  xtime(Tm);7  state[i][0]  ^=  Tm  ^  Tmp;89  //  Corrected  lines  with  direct  array  access10  Tm  =  state[i][1]  ^  state[i][2];  Tm  =  xtime(Tm);11  state[i][1]  ^=  Tm  ^  Tmp;12  Tm  =  state[i][2]  ^  state[i][3];  Tm  =  xtime(Tm);13  state[i][2]  ^=  Tm  ^  Tmp;14  Tm  =  state[i][3]  ^  t;  Tm  =  xtime(Tm);15  state[i][3]  ^=  Tm  ^  Tmp;16  }17}
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 1原始  c  代码  （移除  printf  后）\end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  MixColumns(state_t*  state)7{8  uint8_t  i;9  uint8_t  Tmp,  Tm,  t;10  for  (i  =  0;  i  <  4;  ++i)11  {12  t  =  (*state)[i][0];13  Tmp  =  (*state)[i][0]  ^  (*state)[i][1]  ^  (*state)[i][2]  ^  (*state)[i][3];14  Tm  =  (*state)[i][0]  ^  (*state)[i][1];15  Tm  =  xtime(Tm);  (*state)[i][0]  ^=  Tm  ^  Tmp;16  Tm  =  (*state)[i][1]  ^  (*state)[i][2];17  Tm  =  xtime(Tm);  (*state)[i][1]  ^=  Tm  ^  Tmp;18  Tm  =  (*state)[i][2]  ^  (*state)[i][3];19  Tm  =  xtime(Tm);  (*state)[i][2]  ^=  Tm  ^  Tmp;20  Tm  =  (*state)[i][3]  ^  t;21  Tm  =  xtime(Tm);  (*state)[i][3]  ^=  Tm  ^  Tmp;22  }23}1HLS  兼容  代码  由  LLM  重写1static  void  MixColumns(state_t  state[4][4])  {2  uint8_t  i,  Tmp,  Tm,  t;3  for  (i  =  0;  i  <  4;  ++i)  {4  t  =  state[i][0];5  Tmp  =  state[i][0]  ^  state[i][1]  ^  state[i][2]  ^  state[i][3];6  Tm  =  state[i][0]  ^  state[i][1];  Tm  =  xtime(Tm);7  state[i][0]  ^=  Tm  ^  Tmp;89  //  修正  了  直接  数组  访问的  行10  Tm  =  state[i][1]  ^  state[i][2];  Tm  =  xtime(Tm);11  state[i][1]  ^=  Tm  ^  Tmp;12  Tm  =  state[i][2]  ^  state[i][3];  Tm  =  xtime(Tm);13  state[i][2]  ^=  Tm  ^  Tmp;14  Tm  =  state[i][3]  ^  t;  Tm  =  xtime(Tm);15  state[i][3]  ^=  Tm  ^  Tmp;16  }17}
- en: 'Figure 14: Human-in-the-loop AES Mix Columns'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14：人机协作 AES Mix Columns
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  ShiftRows(state_t*  state)7{8  uint8_t  temp;910  //  Rotate  first  row  1  columns  to  left11  temp  =  (*state)[0][1];12  (*state)[0][1]  =  (*state)[1][1];13  (*state)[1][1]  =  (*state)[2][1];14  (*state)[2][1]  =  (*state)[3][1];15  (*state)[3][1]  =  temp;1617  //  Rotate  second  row  2  columns  to  left18  temp  =  (*state)[0][2];19  (*state)[0][2]  =  (*state)[2][2];20  (*state)[2][2]  =  temp;2122  temp  =  (*state)[1][2];23  (*state)[1][2]  =  (*state)[3][2];24  (*state)[3][2]  =  temp;2526  //  Rotate  third  row  3  columns  to  left27  temp  =  (*state)[0][3];28  (*state)[0][3]  =  (*state)[3][3];29  (*state)[3][3]  =  (*state)[2][3];30  (*state)[2][3]  =  (*state)[1][3];31  (*state)[1][3]  =  temp;32}1HLS  compatible  code  rewritten  by  the  LLM1static  void  ShiftRows(state_t  state[4][4])  {2  uint8_t  temp;3  int  i,  j;45  //  Loop  over  rows  1  to  3  (0-based  indexing)6  for  (i  =  1;  i  <  4;  ++i)  {7  //  Number  of  positions  to  left  shift  for  current  row8  int  shift  =  i;910  //  Use  a  separate  loop  for  the  number  of  shifts11  for  (j  =  0;  j  <  shift;  ++j)  {12  temp  =  state[0][i];  //  Store  the  element  to  be  shifted13  //  Shift  all  elements  by  one  position  to  the  left14  for  (int  k  =  0;  k  <  3;  ++k)  {15  state[k][i]  =  state[k  +  1][i];16  }17  state[3][i]  =  temp;  //  Place  the  temp  value  at  the  end18  }19  }20}
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 1 原始的 `c` 代码（去除 `printf`） \end{lstlisting}2\vspace{-7pt}3 \end{subfigure}4 \begin{subfigure}[t]{.9\columnwidth}5
    \begin{lstlisting}[language=c]6static void ShiftRows(state_t* state)7{8 uint8_t
    temp;910 // 将第一行向左旋转 1 列11 temp = (*state)[0][1];12 (*state)[0][1] = (*state)[1][1];13
    (*state)[1][1] = (*state)[2][1];14 (*state)[2][1] = (*state)[3][1];15 (*state)[3][1]
    = temp;1617 // 将第二行向左旋转 2 列18 temp = (*state)[0][2];19 (*state)[0][2] = (*state)[2][2];20
    (*state)[2][2] = temp;2122 temp = (*state)[1][2];23 (*state)[1][2] = (*state)[3][2];24
    (*state)[3][2] = temp;2526 // 将第三行向左旋转 3 列27 temp = (*state)[0][3];28 (*state)[0][3]
    = (*state)[3][3];29 (*state)[3][3] = (*state)[2][3];30 (*state)[2][3] = (*state)[1][3];31
    (*state)[1][3] = temp;32}1 HLS 兼容的代码由 LLM 重新编写1 static void ShiftRows(state_t
    state[4][4]) {2 uint8_t temp;3 int i, j;45 // 遍历行 1 到 3（从 0 开始的索引）6 for (i = 1;
    i < 4; ++i) {7 // 当前行左移的位置数8 int shift = i;910 // 使用单独的循环处理移动次数11 for (j = 0;
    j < shift; ++j) {12 temp = state[0][i];  // 存储要移动的元素13 // 将所有元素向左移动一个位置14 for
    (int k = 0; k < 3; ++k) {15 state[k][i] = state[k + 1][i];16 }17 state[3][i] =
    temp;  // 将临时值放到末尾18 }19 }20}
- en: 'Figure 15: Human-in-the-loop AES Shift Rows'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15：人机交互 AES Shift Rows
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  SubBytes(state_t*  state)7{8  uint8_t  i,  j;9  for  (i  =  0;  i  <  4;  ++i)10  {11  for  (j  =  0;  j  <  4;  ++j)12  {13  (*state)[j][i]  =  getSBoxValue((*state)[j][i]);14  }15  }16}1HLS  compatible  code  rewritten  by  the  LLM1static  void  SubBytes(state_t  state[4][4])  {2  uint8_t  i,  j;3  for  (i  =  0;  i  <  4;  ++i)  {4  for  (j  =  0;  j  <  4;  ++j)  {5  state[j][i]  =  getSBoxValue(state[j][i]);6  }7  }
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 1 原始的 `c` 代码（去除 `printf`） \end{lstlisting}2\vspace{-7pt}3 \end{subfigure}4 \begin{subfigure}[t]{.9\columnwidth}5
    \begin{lstlisting}[language=c]6static void SubBytes(state_t* state)7{8 uint8_t
    i, j;9 for (i = 0; i < 4; ++i)10 {11 for (j = 0; j < 4; ++j)12 {13 (*state)[j][i]
    = getSBoxValue((*state)[j][i]);14 }15 }16}1 HLS 兼容的代码由 LLM 重新编写1 static void SubBytes(state_t
    state[4][4]) {2 uint8_t i, j;3 for (i = 0; i < 4; ++i) {4 for (j = 0; j < 4; ++j)
    {5 state[j][i] = getSBoxValue(state[j][i]);6 }7 }
- en: 'Figure 16: Human-in-the-loop AES Sub Bytes'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16：人机交互 AES Sub Bytes
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  AddRoundKey(uint8_t  round,  state_t*  state,  const  uint8_t*  RoundKey)7{8  uint8_t  i,j;9  for  (i  =  0;  i  <  4;  ++i)10  {11  for  (j  =  0;  j  <  4;  ++j)12  {13  (*state)[i][j]  ^=  RoundKey[(round  *  Nb  *  4)  +  (i  *  Nb)  +  j];14  }15  }16}1HLS  compatible  code  rewritten  by  the  LLM1static  void  AddRoundKey(uint8_t  round,  state_t  state[4][4],  const  uint8_t  RoundKey[AES_KEYLEN])  {2  uint8_t  i,  j;3  uint8_t  base  =  round  *  Nb  *  4;4  for  (i  =  0;  i  <  4;  ++i)  {5  for  (j  =  0;  j  <  4;  ++j)  {6  state[i][j]  ^=  RoundKey[base  +  (i  *  Nb)  +  j];7  }8  }9}
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 1原始的 c 代码（去除 printf 后）\end{lstlisting}2\vspace{-7pt}3\end{subfigure}4\begin{subfigure}[t]{.9\columnwidth}5\begin{lstlisting}[language=c]6static
    void AddRoundKey(uint8_t round, state_t* state, const uint8_t* RoundKey)7{8  uint8_t
    i,j;9  for (i = 0; i < 4; ++i)10  {11  for (j = 0; j < 4; ++j)12  {13  (*state)[i][j]
    ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];14  }15  }16}1HLS 兼容的代码由 LLM 重写1static
    void AddRoundKey(uint8_t round, state_t state[4][4], const uint8_t RoundKey[AES_KEYLEN])
    {2  uint8_t i, j;3  uint8_t base = round * Nb * 4;4  for (i = 0; i < 4; ++i) {5  for
    (j = 0; j < 4; ++j) {6  state[i][j] ^= RoundKey[base + (i * Nb) + j];7  }8  }9}
- en: 'Figure 17: Human-in-the-loop AES Add Round Key'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17：人机交互 AES 添加轮密钥
- en: 1HLS  compatible  code  from  the  hands-free  flow1//  Function  to  swap  two  elements2void  swap(int*  a,  int*  b){3int  temp  =  *a;4*a  =  *b;5*b  =  temp;}6int  partition(int  arr[],  int  low,  int  high){7int  pivot  =  arr[low];8int  i  =  low;9int  j  =  high;10while  (i  <  j){11  while  (arr[i]  <=  pivot  &&  i  <=  high  -  1){12  i++;13  }14  while  (arr[j]  >  pivot  &&  j  >=  low  +  1){15  j--;16  }17  if  (i  <  j){18  swap(&arr[i],  &arr[j]);19  }20}21swap(&arr[low],  &arr[j]);22return  j;23}24void  quickSort(int  arr[64],  int  low,  int  high){25int  stack[128];  //  Fixed  size  stack  to  work  with  HLS  tools26int  top  =  -1;27stack[++top]  =  low;28stack[++top]  =  high;29while  (top  >=  0){30  high  =  stack[top--];31  low  =  stack[top--];32  if  (low  <  high){33  int  partitionIndex  =  partition(arr,  low,  high);34  stack[++top]  =  low;35  stack[++top]  =  partitionIndex  -  1;36  stack[++top]  =  partitionIndex  +  1;37  stack[++top]  =  high;38}}}
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS 兼容的代码来自免手动流程1// 交换两个元素的函数2void swap(int* a, int* b){3int temp = *a;4*a
    = *b;5*b = temp;}6int partition(int arr[], int low, int high){7int pivot = arr[low];8int
    i = low;9int j = high;10while (i < j){11  while (arr[i] <= pivot && i <= high
    - 1){12  i++;13  }14  while (arr[j] > pivot && j >= low + 1){15  j--;16  }17  if
    (i < j){18  swap(&arr[i], &arr[j]);19  }20}21swap(&arr[low], &arr[j]);22return
    j;23}24void quickSort(int arr[64], int low, int high){25int stack[128];  // 固定大小的栈以配合
    HLS 工具26int top = -1;27stack[++top] = low;28stack[++top] = high;29while (top >=
    0){30  high = stack[top--];31  low = stack[top--];32  if (low < high){33  int
    partitionIndex = partition(arr, low, high);34  stack[++top] = low;35  stack[++top]
    = partitionIndex - 1;36  stack[++top] = partitionIndex + 1;37  stack[++top] =
    high;38}}}
- en: 'Figure 18: Hands-free C2HLSC QuickSort'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18：免手动 C2HLSC 快速排序
- en: 1HLS  compatible  code  from  the  hands-free  flow1void  AddRoundKey(uint8_t  round,  state_t  state,  const  uint8_t*  RoundKey)2{3uint8_t  i,  j;4uint8_t  RoundKey_local[AES_keyExpSize];5for  (i  =  0;  i  <  AES_keyExpSize;  ++i)6{7#pragma  HLS  PIPELINE  II=18  RoundKey_local[i]  =  RoundKey[i];9}10for  (i  =  0;  i  <  4;  ++i)11{12  for  (j  =  0;  j  <  4;  ++j)13  {14#pragma  HLS  PIPELINE  II=115  state[i][j]  ^=  RoundKey_local[(round  *  Nb  *  4)  +  (i  *  Nb)  +  j];16  }17}18}
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS 兼容的代码来自免手动流程1void AddRoundKey(uint8_t round, state_t state, const uint8_t*
    RoundKey)2{3uint8_t i, j;4uint8_t RoundKey_local[AES_keyExpSize];5for (i = 0;
    i < AES_keyExpSize; ++i)6{7#pragma HLS PIPELINE II=18 RoundKey_local[i] = RoundKey[i];9}10for
    (i = 0; i < 4; ++i)11{12  for (j = 0; j < 4; ++j)13  {14#pragma HLS PIPELINE II=115  state[i][j]
    ^= RoundKey_local[(round * Nb * 4) + (i * Nb) + j];16  }17}18}
- en: 'Figure 19: Hands-free C2HLSC AES Add Round Key'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19：免手动 C2HLSC AES 添加轮密钥
- en: 1HLS  compatible  code  from  the  hands-free  flow1void  ShiftRows(state_t  state)  {2  uint8_t  temp;34  //  Rotate  first  row  1  column  to  the  left5  temp  =  state[0][1];6  state[0][1]  =  state[1][1];7  state[1][1]  =  state[2][1];8  state[2][1]  =  state[3][1];9  state[3][1]  =  temp;1011  //  Rotate  second  row  2  columns  to  the  left12  temp  =  state[0][2];13  state[0][2]  =  state[2][2];14  state[2][2]  =  temp;1516  temp  =  state[1][2];17  state[1][2]  =  state[3][2];18  state[3][2]  =  temp;1920  //  Rotate  third  row  3  columns  to  the  left21  temp  =  state[0][3];22  state[0][3]  =  state[3][3];23  state[3][3]  =  state[2][3];24  state[2][3]  =  state[1][3];25  state[1][3]  =  temp;26}
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS 兼容代码来自免手动流程1void  ShiftRows(state_t  state)  {2  uint8_t  temp;34  //  将第一行的1列向左旋转5  temp  =  state[0][1];6  state[0][1]  =  state[1][1];7  state[1][1]  =  state[2][1];8  state[2][1]  =  state[3][1];9  state[3][1]  =  temp;1011  //  将第二行的2列向左旋转12  temp  =  state[0][2];13  state[0][2]  =  state[2][2];14  state[2][2]  =  temp;1516  temp  =  state[1][2];17  state[1][2]  =  state[3][2];18  state[3][2]  =  temp;1920  //  将第三行的3列向左旋转21  temp  =  state[0][3];22  state[0][3]  =  state[3][3];23  state[3][3]  =  state[2][3];24  state[2][3]  =  state[1][3];25  state[1][3]  =  temp;26}
- en: 'Figure 20: Hands-free C2HLSC AES Shift Rows'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '图 20: 免手动 C2HLSC AES Shift Rows'
- en: 1HLS  compatible  code  from  the  hands-free  flow1void  MixColumns(state_t  state)2{3  uint8_t  i;4  uint8_t  Tmp,  Tm,  t;5  for  (i  =  0;  i  <  4;  ++i)6  {7  t  =  state[i][0];8  Tmp  =  state[i][0]  ^  state[i][1]  ^  state[i][2]  ^  state[i][3];9  Tm  =  state[i][0]  ^  state[i][1];  Tm  =  xtime(Tm);  state[i][0]  ^=  Tm  ^  Tmp;10  Tm  =  state[i][1]  ^  state[i][2];  Tm  =  xtime(Tm);  state[i][1]  ^=  Tm  ^  Tmp;11  Tm  =  state[i][2]  ^  state[i][3];  Tm  =  xtime(Tm);  state[i][2]  ^=  Tm  ^  Tmp;12  Tm  =  state[i][3]  ^  t;  Tm  =  xtime(Tm);  state[i][3]  ^=  Tm  ^  Tmp;13  }14}
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS 兼容代码来自免手动流程1void  MixColumns(state_t  state)2{3  uint8_t  i;4  uint8_t  Tmp,  Tm,  t;5  for  (i  =  0;  i  <  4;  ++i)6  {7  t  =  state[i][0];8  Tmp  =  state[i][0]  ^  state[i][1]  ^  state[i][2]  ^  state[i][3];9  Tm  =  state[i][0]  ^  state[i][1];  Tm  =  xtime(Tm);  state[i][0]  ^=  Tm  ^  Tmp;10  Tm  =  state[i][1]  ^  state[i][2];  Tm  =  xtime(Tm);  state[i][1]  ^=  Tm  ^  Tmp;11  Tm  =  state[i][2]  ^  state[i][3];  Tm  =  xtime(Tm);  state[i][2]  ^=  Tm  ^  Tmp;12  Tm  =  state[i][3]  ^  t;  Tm  =  xtime(Tm);  state[i][3]  ^=  Tm  ^  Tmp;13  }14}
- en: 'Figure 21: Hands-free C2HLSC AES Mix Columns'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '图 21: 免手动 C2HLSC AES 混合列'
- en: 1HLS  compatible  code  from  the  hands-free  flow1#define  getSBoxValue(num)  (sbox[(num)])23//  The  SubBytes  Function  Substitutes  the  values  in  the4//  state  matrix  with  values  in  an  S-box.5static  void  SubBytes(state_t  state)6{7  uint8_t  i,  j;8  for  (i  =  0;  i  <  4;  ++i)9  {10  for  (j  =  0;  j  <  4;  ++j)11  {12  state[j][i]  =  getSBoxValue(state[j][i]);13  }14  }15}
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS 兼容代码来自免手动流程1#define  getSBoxValue(num)  (sbox[(num)])23//  SubBytes 函数用
    S-box 中的值替换状态矩阵中的值。4//  state 矩阵中的值5static  void  SubBytes(state_t  state)6{7  uint8_t  i,  j;8  for  (i  =  0;  i  <  4;  ++i)9  {10  for  (j  =  0;  j  <  4;  ++j)11  {12  state[j][i]  =  getSBoxValue(state[j][i]);13  }14  }15}
- en: 'Figure 22: Hands-free C2HLSC AES Sub Bytes'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '图 22: 免手动 C2HLSC AES Sub Bytes'
- en: -B Waveforms
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: -B 波形
- en: -C Conversations
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: -C 对话
- en: Here we list the links to the conversations to go from C to HLS C.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们列出了将 C 代码转换为 HLS C 的对话链接。
- en: •
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '[Frequency Test: https://g.co/gemini/share/ba393c5de5a6](https://g.co/gemini/share/ba393c5de5a6)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[频率测试](https://g.co/gemini/share/ba393c5de5a6)'
- en: •
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '[Frequency Block Test: https://g.co/gemini/share/659379d677c0](https://g.co/gemini/share/659379d677c0)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[频率块测试](https://g.co/gemini/share/659379d677c0)'
- en: •
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '[Cumulative Sums Test: https://g.co/gemini/share/0f35a4d248e7](https://g.co/gemini/share/0f35a4d248e7)'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[累计和测试](https://g.co/gemini/share/0f35a4d248e7)'
- en: •
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '[QuickSort: https://g.co/gemini/share/92b68e7849fc](https://g.co/gemini/share/92b68e7849fc)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[快速排序](https://g.co/gemini/share/92b68e7849fc)'
- en: •
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '[AES 128: https://g.co/gemini/share/92b68e7849fc](https://g.co/gemini/share/92b68e7849fc)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[AES 128](https://g.co/gemini/share/92b68e7849fc)'
- en: •
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '[Overlapping Template Matching Test: https://g.co/gemini/share/c1ac0cef56f2](https://g.co/gemini/share/c1ac0cef56f2)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[重叠模板匹配测试](https://g.co/gemini/share/c1ac0cef56f2)'
