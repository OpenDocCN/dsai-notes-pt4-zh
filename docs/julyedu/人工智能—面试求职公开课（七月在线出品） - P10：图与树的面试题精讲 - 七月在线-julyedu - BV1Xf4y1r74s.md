# 人工智能—面试求职公开课（七月在线出品） - P10：图与树的面试题精讲 - 七月在线-julyedu - BV1Xf4y1r74s

大家好，欢迎观看7月算法公开课。我们这堂课的主要内容是图论面试题精讲。我将从如下几个方面讲述本课，先讲一下图论方面的简介。接着总结一下近些年来图论相关的面试题，做一个总体分析知识点的梳理。

接着我会讲五个例题，说是5个例题。这里面的例案其实是很多个小例题。因为他们都可以用一个统一的递规框架来解决，我就把它们放到一起了，希望能起到抛砖引玉的作用。从难度上讲呢，例一例二是比较简单的。

例三可以算中档题，例四是中上档。例五是最难的，所以难度基本上是递增的。最后我会总结结束本课。关于图论，其实大家比较熟悉，在数学领域，图结构是一种非常抽象的结构。我们要定义一个图呢，就要先定义它的节点。

再定义它的边。这两个东西定义好了，这个图就定义好了。它的分类呢其实分为有向图和无向图，这个主要取决于边是否有方向。那特殊的图在计算机的数据结构里面，特殊的图其实就是无相的。无环的图，也就是树。

这个数是指的无根数。那还有一种是有根数，这个写在这里了，并查集是一种有根数。这个在库斯co算法里面我讲到过。还有一种比较特殊的树，就是二叉树。其中更重要一点的就是二叉搜索数，这个都是比较经典的数据结构。

当然还有一种就是堆堆，其实也是一种科数的二叉树，比较著名的堆排序，就是用这种数据结构，这个是图论方面的简介。关于面试题，其实内容比较多。对于图来讲，我们会考察它的联通性。

就是两个点之间是否有路以及联通分量等等。啊，包括割点割边的概念。什么叫割点，什么叫割边呢？就是我把这个点去了，或者把这个边去了，这个图由连通变成不连通了。也就是我删掉哪个点，它就不连通了。

或者说删掉哪条边，它就不连通了。这样的点和边叫做割点和割边最好证成数，我在之前的课程中讲到过最短路很多类型，这个包括单元图的最短路。呃，任意两点间的有没有附圈的各方面的最短路。

我也提到过搜索BFSDFS讲到过欧拉回路与哈密尔朵回路。这个主要是概念上拓空排序比较简单。那对于数来讲呢，主要考察它的定义与判断这个定义有可能是普通的数，也有可能是二叉搜索数等等。

判断它是不是二叉搜索数，以及它平衡不平衡。求它的最大高度啊、最小高度啊，以及最近公共组先啊这类问题。这个是数和图方面的面试题的总体分析。我们接下来看正式的例题。第一个提示。

li code上105题比较简单，它给出的是二叉树的前序和中序的便历序列，要求我们构造这个二叉树。我们看一下前序遍历既然叫前序遍历。第一个节点显然是跟。那中序遍历呢，它的根在中间，但是我们有了这个根。

从前序里面，我们能看到这个根是X。我们从中序遍历里面也找到这个X，然后中序遍历就被X分割成两部分了，左边那部分就是左子树的中序遍历序列，右边那部分就是右子树的中序便历序列。那从前序遍历序练里面。

我们根据这个长度也把它分成两部分，这样我们分别就有了前序遍历序列的。左子树的前序变理序列以及右子数的前序变理序列，以及它们分别对应了中序变理序列，这样就分割成两个子问题了。

我们分别构造左子数和右子数就好了。我们来看一下代码。这个特殊情况单独处理。如果就是less是零就是空的，否则的话这个proor就是前序嘛，这个东西就是根了。根节点我们已经找到了。

那么分别找左右找左右的时候是从中序遍历里面找到这个根节点的位置，然后分成两部分，前序遍历也对应的分成两部分。这个下标的范围要算好了。这个要细致一点就可以了。其实大家可以看到它的本质也是一个递归的过程。

这个递归其实是前序遍历的过程。因为我们先遍历了，或者说先构造了根节点，然后再构造左子数再构造右子数是这么一个过程。有一个思考题就是lea code上106题，它是给定了后序遍历序列，以及中序遍历序列。

然后也构造这块二叉树，其实跟这个思路是完全一样的。第二个问题，其实它是一系列问题，主要是我总结了一个一般的思路。从刚才那个问题其实也能看出来。这个二叉树相关的问题基本上都可以用递归来实现。

倒不是说必须用递归。因为有的时候呃面试可能要求我们写非递归，但是它都可以用递归来实现。那递归就分为我先做哪部分，其实无外乎就是跟左右这三部分。那根据他们便利的顺序不同。

也就对应了一个抽象意义上的前序中序以及后序便利。比方说刚才那个问题，其实对应了一种抽象的前序便利。那我们看一下这个我现在举的这几个问题。第一个问题相对难一点。这个lea code上124题。

就是二叉树上每个节点有一个整数返回和最大的路径。什么叫和最大的路径呢？因为二叉树它说到底它是一棵树，任何两个点之间它都有一条唯一的路径，因为它是树嘛。那这条路径上每个节点都有一个整数。

这个整数的和就叫做这条路径的和。我们要求一条和最大的这样的一条路径。那么我们分别计算从左子数延伸下去的一条和最大的路径，从右子数延伸下去的一条河最大的路径。什么叫延伸下去，就是往叶子的方向延伸。

当然不一定到叶子，我只是要和最大。那么还有一种情况就是通过根节点的这个和最大的路径。那显然这个这个子数上的和最大路径，要么是我指的是一定要通过根节点，要么是从左子数从根到左子数往下延。

要么是从根往右子数往下延，要么就是一个V字形的到V字形的，呃，从左子数到根再到右子数这么一条，所以只有这三种情况。当然我们要求全局的最大值，所以这里要注意我返回值和最大值的关系。

可以看一下我的自己写的代码。注意这里面我写了一个帮助的函数叫help。我最后的返回值不是help返回值。help是有返回值的，但是我没有用help的返回值。这个result result是传引用进去的。

所以它会变对特殊情况单独考虑，我们处理一下左子数。左子数注意这个help返回的什么，help返回的就是从根节点往下延伸的最大的值。所以对于左子数来讲，就是从左子数的那个根节点往下延伸的最大值。

右子数也是一样。从右子数那个节点往下延伸的最大值。我们的目的在于如何用这两个值求出全局的最大值。我们看一下，先求从root往下延伸的最大值，也就是这个return节点。这个return的值，实际上就是。

😊，左子数和右子数较大了，加上根节点，因为我一定要从根节点往下延伸，所以至少取了根节点一个节点。这个呢这个和最大子数组合比较像。如果这两个值都是负的的话，我根本就没必要取我一个根节点就可以了。

我没有必要往下走。因为那两个值都是负的，所以这个return实际上最后求的是从这个root往下延伸的最大的那条路径。😊，那我们这个M是全局的最大路径。当然我这个root遍利了所有节点之后。

M就是全局的了。那么到目前为止，我这个M需要把这个当前这个节点经过当前这个节点的路径算出来最大的那条路径算出来。那显然这个return是一种可能。

这re就是从根往下走的那还有一种可能就是我刚才说的到V可能到V就是左子数的右子数的加上root的，其实它本质是个动态规划，因为左边我一定要最大，右边一定要最大，然后再算上根这三个和才可能最大。

所以M是所有东西的最大当root变利了所有节点之后，M就是全局的最大了，这个引用它会变。所以这个最后返回的全局的最大值。所以这个是。嗯，最大路径和位题？那我们看一下第二个问题。

第二个问题是返回二叉树的所最小深度，这个跟我们的深度定义不同。它这里面最小深度定义的是从根到叶子。一定要到一个叶子的。最少经过的这个节点数。那。我们要注意，比方说一个非常简单的二叉树，左子数是空。

右子数就一个节点，这个二叉树一共就两个节点。那么我们就要返回二，注意一定要到一个叶子。所以尽管它左子数是空，然后如果我们对左子数，右子数分别取最小的深度，那么我们会取左子数是零，右子数是一。

那么最后从根节点到零的距离最小，所以最后返回一个一，这是错的那思路还是左子数右子数最小深度取最小，但问题要保证左右子数都存在，这就是我写了这么多判断的原因。那如果左右子数都存在，根据我刚才说的。

它其实就是左右最小，然后当然加一个一。那如果只有一个的话，左子数存在，右子数不存在，那么就是左子数的那这个是对称的右子数存在，左子数不存在，就这样。否则的话左右都不存在，就一个根了，那就返回一。

那这个其实也是一个递归的过程，呃，可以把我个人理解可以把它理解为一个前序遍利吧。因为我们先访问了根，其实它。😊，不是一个很严格的前序遍历，但是它也是一个递归的过程。

刚才那个求路径和是一个很经典的后续变历。因为先算left，再算了right，再算了根，这个也是一个递归的框架。我们再继续看。判断树平衡平衡二叉树其实是这个数据结构里面也是一个比较重要的数据结构吧。

它的定义是我从每一个节点开始算出树的高度，注意这里面树的高度是最大的那个高度，而不是刚才定义的那个最小深度，就是传统意义上的树的高度。如果每个节点左子树和右子树的高度至多差一。那么这个二叉树是平衡的。

那这个数据结构书上也有所介绍。那看看我们来怎么判断给定一个root，就是以这个为根的二叉数是否是平衡的。我们我还写了一个help函数，这里面hat还是一个引用，它会变。那它返回的实际上是root的。

就是这个二叉数的真正意义上的高度。那么这个布尔函数最后返回的就是它是不是平衡的，我们顺便把它的高度算出来，因为平衡跟高度相关嘛，那等于零的时候单独处理，否则的话呢。我们看一下，算一下左子数的高度。

同时因为我们这个函数可以判断它是否平衡。如果左子数不平衡，显然整个二叉树也不可能平衡。因为二叉树的平衡要求，每一个节点的子数都要平衡，这个不平衡，那就不可能了。那直接返回了。那如果左子数平衡。

我们看一下右子数一样的那如果这两个都平衡的话，我们看一下以这个root为根的这个是不是平衡。那就要看一下这两个高度之间的关系。首先先算出这个root本身的高度。

这个高度刚才根据高度的定义是两个较高的加一，那么它是不是平衡呢，就看一下他们两个差是不是是不是至多差一，就是这个条件。那这个是在算平衡的时候，同时算出了高度。那其实这个我个人觉得也可以算一个便利。

但是不太好说什么便利。因为它先访问了根，我们可以理解为前序遍利。但是呢也可以理解为是后续遍利。因为假设这步不算的话，我们考虑的其实是先算了左再算了右，再把根节内的值算回来。

所以具体是抽象意义上的什么变力并不重要，本质还是一个递归的过程，递归基本上就是考虑左右以及它自身怎么算。所以这几个题的这个框架上来讲都是差不太多的我们再继续看。就最大深度，这个是我比较喜欢的一个题。

其实这个在那个刚才那个平衡上其实已经求出来了。我比较喜欢它的原因是其实如果写代码的话，一句话就可以写出来。当然这个用了很多技巧。比方说这种问号表达式，如果root是零的话，显然是一个空的数，高度是零。

否则的话，它就是左子数和右子数高度较大的加一，这个本身就是高度的定义，它写起来非常美观。一个二叉树的高度定义为左右较高的加一空数的高度定义为0。所以根据定义，我们直接就写出了这么一句话。😊。

这个很快了就可以过去，它是104题。那还有一个是判断两个二叉数是否相同，这是100题，这个也非常简单，给定两个二叉数，我们怎么判断它是否相同呢？假设它是P和Q，如果P是空，那么Q一定要是空。

所以我们看一下Q是不是空。如果到这里就说明P不是空了，Q是空，那显然是for。这两个 if服特殊条件处理完PQ都不是空，PQ都不是空就好办了。我们看一下他们的value是不是相等。

然后看一下它们左子数是不是一样的，右子数是不是一样的。所以本质还是根节点长的什么样，左子数是不是一样的，右子数什么样。根据定义其实两个数是不是一样，都是空是一样，空和非空不一样。

其实这个就是这个本身的定义，那一般情况下就是两个节点是一样的，并且左子数和右子数都是一样的。这两个二叉数就是一样的。所以。😊，这个二叉树由于定义本身是递归的，我们写代码都可以写成递归的，而且非常简单。

非常方便。你们继续。判断二叉数是否对称，这个是li code上101题。我们看一下，首先要对称，我就判断一下它的左子数和右子数的关系。那么重点就在这儿，左子数右子数空和非空。这个和刚才PQ那个是一样的。

否则我就看一下他们这两个Y6一样不一样。但是是判断的时候是这个左和这个右判断这个右和这个左判断。其实这和那个is same train非常像，只是这个左右颠倒一下，就是判断对称了。那，再继续。

判断是不是二叉搜索数，这是立得课上98题。呃，说一下这个题其实做法很多。因为这个我们可以判断呃是不是左子数的最大值，还要小于根节点，并且右子数的这个最小值，还要大于根节点等等，有各种判断方法。

而且我们还要考虑第一个节点啊等等这些特殊的这些地方。但是呢我我采取的判断方法是，如果一个二叉数是二叉搜索数的话，我们对它中序遍历，便历完的那个序列一定是有序的。

这样我们就不用考虑什么左子数最大值、右子数最小值这些具体的问题了。我们就做一个中序遍历，然后做完之后看一下那个序列是不是有序的。但是呢我没有存下来它的中序便历序列。😊。

我只是看一下当前的这个值是不是比前一个值更大就好了。因为这个序列我没有必要把它存下来。当然存下来是一种方式，我们可以用一个vector或者list了之类的东西，把中序遍历的序列存下来，再循环一遍看一下。

但是我没有必要，我们按顺序遍历直接跟前一个比一下就可以了。所以我这里面last就是。我前一个节点变利的值。当然在这里面是value，这个值是个引用，它会变，它的初值其实没有关系。

关键是我还有一个firstfirs表示我现在有没有变利过值。如果当前是就是这个节点是第一个遍利的节点，就是firs一上来是tro，就是这里的mark。当然它也是个引用。如果它是 true的话。

说明当前这个节点是第一个便利的节点，它就不要和之前的便利了。当然我们可以用一个类似于哨兵的技术，把这个之前那个节点设置为负无穷，就不需要这个了。但是对in来讲，我不太习惯设置这种max。

就是负max或者这种东西。所以我用了一个布尔的变量。所以一上来把它制成tro，表示现在还没有变利过任何节点。那我们看一下这些东西怎么更新。首先空数是二叉搜索，这个没问题。那么我刚才说了。

需要做这个中续便利。中序变力就要先遍利左子数。我看一下左子数，是不是左子数是二叉所索数了。那么我现在要辨历根节点这个位置，根节点，我要看一下左子数是不是真的便利了。也就是说左子数有可能是空。

它可能一个节点都没有。那如果左子数。就是说没有节点的话，这forrs就会是true。那么我当前这个root这个节点就是我便利的第一个节点，所以我这last就有值了。

我这last永远存的是上一个节点是什么东西，同时把forrs复成force。这个实际上就是中序便利里面更改状态的那一步。那我们再看一下。如果不是呢，就说明first的是for呃是for。

是forrs的话，就说明这个左子数确实变利了一些节点。那就证明我这个last的是有意义的。那么我就看一下我这个root的value和last的关系。如果last的大于等于root的 value。

那它显然不是二叉所所数。因为我刚才说了，它需要有序的，中序变列是有序的。我这root的value一定要比上一个值大，那这个就反了，所以就这样了。那么。这时候我在这个return force。

那如果值是正着的呢，那么我上一个值就变成了root value，这个永远是我最近一次遍历那个值。目前我变历完root value了，再变离柚子数就可以了，注意把last的传过去。

所以它的本质还是一个可以理解为一个中序变历，它本身就是一个中序变历，只不过我改变了一些状态，主要是处理存上一个遍利的值，主要是这个意思。所以这个也是一个不算太难的问题，例得课堂上98题。我们再继续。

这个是第三个例题，就是二叉树与链表之间的转换。这个是我比较喜欢的一个题。在讲链表的时候想把它加进来，但是由于时间关系就不得不把它删掉了，所以在这里面讲一下，因为它也是和数相关的。这个是二叉树转链表。

具体转的方式其实很简单，就是我把左子数。转成链表，转成一条单链，转成单链之后，把它接到右子树上，也就是最后所有的链都在右子树上，左子树是空，然后。右子数先跟的是左子数转成的链，再接上右子树自身转成的链。

所以它是这个一个很长的链，先是左子树转成的链，接到右子数，然后再是右子树本身转成链，再接到下面是这么一个链。那根据它的转的定义，其实具体要看一下lea code上114题。

它到底是怎么转成列表的这个要求可能不一样。这个问题本身它定义的，就是我刚才说的那种定义。那看一下空就不说了。同样我需要记录一下这个最后一个节点。因为我转完之后，那个右子数转完之后。

我要接到这个左子数转完的那条料的后面。所以我总要因为链表相接，总要考虑最后一个节点，所以我要记录一下最后一个节点，这里我叫my last，当然这个last是真正意义上最后一个节点。

这个my last的是个局部值。那么我看一下，如果不是不是空的话，就把last的更新一下，然后按照我说的方式接，注意把root的 right变成了root的 leftft。

因为这个时候我是先转的left，这时候left已经是一个链表了，所以left已经是一个朝右链的这么一个链了。那么我把它附到right上，附到right上之后呢。

那root原来的right在这个tample里面记录了，所以这是我之前也强调的，我要更新一个值，要注意把前面的那个值保存掉，不然你就找不到了。这个目前这个tample是真正意义上的柚子数。

而root这个右子数实际上是左子树转换出来那个链儿，左子数浮空了。那么实际上last right其实就是那个temple。因为我要把这个呃最后一个节点接到接上那个真正意义上柚子树。

那我们再转直接转这个tpo就可以了。下面无论last是不是空，我都可以直接转tamppo，转tle更新一下last，实际上它也是一个这个可以叫做。可以叫做中序便历的过程吧。因为这个是先先弄的左子数。

再访问的根节点，再便离一下右子数。这个tample实际上是变离右子数，所以不要严格的区分它是一个前中后哪个遍历。它我们就要考虑一下左子数怎么处理，根节点怎么处理，以及右子数怎么处理就好了。

所以这个又一次印证了这个刚才例二的那个基本框架，它就是一个递归的框架。你再看一下链表转二叉树。当然这里面要二叉树尽量平衡。那一个直接的思路就是我先求一下这个链表的长度。然后我每次的虽然我知道链表的长度。

但是我这个链表长度是在外面求的。虽然我知道链表的长度，但是我每次还是要走到那个位置，把那个根拉出来，分别把左右弄一下，知道左边多长，右边多长。那看一下这个算法的复杂度，其实是N logN的，为什么呢？

因为。我虽然知道我想要哪个节点，但是我从列表是从头走不到那个节点，我需要走到那个节点，把那个根拉出来，然后左右单独处理。那这有1个ON的这么一个循环，这个跟那个啊快排啊，mod sort都比较像，就是。

TN等于T2分之N加ON，因为它的递归，这个或者说分制合并的部分有一个ON的部分，所以它是ONlogN的。本质原因呢是因为列表不能随机访问。其实我知道我要哪个节点，但我拿不到，这是lea的上109题。

这个其实它和数组不一样的地方是还有一个问题是数组转成平方差数，那个用数组就能直接做到ON因为呃它不需要这个。就它不需要这个呃直直接循环访问，它可以直接通过下标访问到这个根节点。

那我们看一下它有没有ON的方式呢？其实是有的，我们可以优化来看一下。其实这个长度也是在外面算出来了，这个ON不影响，关键在里边我没有没有一个循环。那这个是什么意思呢？注意我这里面原来的那个是非引用。

现在是一个引用，就是说这个东西会变。我这个head是说我给定了一个这么一个列表，它的长度是Lance，我现在要把它变成二叉树，变成二叉树之后，我指向的是Lance之后的那个节点。

也就是我ha的随着变的时候，我自己也在变。我们看一下怎么变，先处理这个左子数。因为左子数就是我知道它总体长度，那么我知道左边要取name这么多个节点，那么我就取那么多个节点。根据这个hap的定义。

我取name节点之后，这个新的ha就变成了name个节点之后的那个头了。所以我这个函数执行完之后，这个ha已经往前走了那步。那么我这个root就是当前这个节点。因为我已经确定好根节点的位置了。

左子数有多少个已经确定好，那么右子数有多少个，右子数就是lesss减name减一个。因为那个在左子数一个在根节点。那我这个关键是这个ha等于ha next把这个节点跳过去，看起来这边只跳了一个节点。

实际上根据这个函数本身递归的定义，实际上这个left回来之后，这个head就变成了我想要的那个根节点的位置位置。所以它没有省掉了那个循环，这个代码看起来是差不太多的。

它的本质也是啊先算一下左子数处理一下根节点再算一下右子数，都是这个思路，它。😊，变那这样的时间复杂度就是ON，因为PN等于2倍的T2分之N加O1，现在没有那个循环了嘛，它就是ON了。那有一个思考题。

其实比这个简单，就是我刚才说的数组转平衡差数，它是立的 code上第108题，它其实就呃可以用第一个思路嘛，它直接就把那个关节点拉过来，就没有这么复杂了。我们看一下例四例四是说一个无像图的复制。

这个题是li code上133题，它是一个中等偏难的问题。当是li code上给它规定的是medium，就是中等题。那它无像图其实存的是一个连接表，就是每个节点存了它的邻居。

但是注意这个呃无像图它可能有圈儿，就是自身到自身可能有这样的边。如果我们不把它存好之后，它就会反复复制，这个有点像呃复制随机指向的列表，在列表那一张有一个random指针的那个东西。

其实这个思路跟那个思路差不太多。但是那个是通过一些技巧避免了使用map。我这里面简单的使用map。因为这个。无像图的节点，它自己有个label，就是说有个整数值。

我这个map就表示把key就把这个label映射成了具体的节点的地址。那我通过DFS复制就可以了，怎么复制呢？它的输入是一个节点，我从这个节点开始复制，那我就复制把这个have传过去。

这have就是那个map，注意也是引用会变的。所以时刻注意我这个传的东西到底是个什么东西。要是传引用的话，其实和传全局变量是一样的。那么我们看一下，先从这个。map里面找一下这个label。

就是说这个节点我复制过没有？如果复制过，我直接返回就可以了，这个可以理解为一个缓存或者一个呃什么东西吧，就是基本上可以理解为一个cash。如果没复制过，那我显然要复制。

那么我就复制一个label的这个东西。注意这里面虽然它还它的邻居还没有复制好，但是我已经复制一个这样的节点了，我一定要把这个节点先放进map里面，为什么？因为我后面在复制的时候，还有可能复制它本身。

复制它本身的时候，你递归的时候会发现它不在map里面，那那样就会出问题。所以这里面尽管我这个。😊，node还没有完全复制好，它的那个邻居还没有复制，但是我可以先把它放到map里面来。

注意这里面map的value是个地址，所以没有关系，尽管那个node本身的邻居那些列表都会变，但是这个 nodeode地址只要我有了这个node，它的地址就是一个死的东西。所以我把它放到map里来。

没有问题。后面就是简单DFS过程，把它邻居一个一个复制就好了。并且这个这个东西是个vector，这个neighbors是个vector把它邻居一个复制。还是我刚才说的这个new note的地址不会变。

它自己变没有关系，这map里面的valueue是不会变的。关键问题是图可能有圈儿。这个是第四题，你再看一下最后一个问题，这个题比较难。给定一个矩形棋盘呃，比方说这个例子再指定一些位置。

比方说画这个阴影或者说画黑的这些例子呃，ABCDEFGH我规定了这么8个点，我要一定要经过这么8个点，并且呢起点你可以自己定，你定哪都行。我规定一个，比方说从A，这个是你自由选取的。然后呢。

每一次走的方向要么水平走走多少格没有关系，要么竖值走。但是每一次只能和上一次走的不同方向，什么意思呢？我上一次水平走了，这一次就要竖直走。如果上一次是竖直走的，这一次就水平走，然后每个位置只能经过一次。

就是这这8个节点只能经过一次问是否是可能的那比方说这个例子，这个A，我走到D。这是水平走的，再走到E，这是竖直走的，再走到F，这又水平走的，再走到C，这又竖直走的，再走到B，又水平走的。

再走到G又竖直走的，再走到H又水平走的这是可能的。我每个界点只经过了一次。😊，那。如果按我们传统的定义，就是直接把它定义出来的话，这是一个哈米尔顿路的问题。什么是哈米尔顿路呢？就是给你一个图。

每个节点只经过一次，把这个图画出来。当然不不一定要求画出每条边，就是你能不能沿着图的边，每个点只走一次。把这个顺序走出来，看似是个很简单的问题，但是实际上它是NP hard的。所以。

如果转成哈密尔顿路基本上就不太可解了。我们看一下有没有更好的办法。其实呢我们把所有节点的X坐标放到一起，Y坐标放到一起。那么我每走一步就相当于从X跳到了Y，然后再从Y跳到了X。

因为它每一步要么就是水平的，要么就是数值的。所以就相当于在X和Y这个两个集合之间来回跳。那问题对应于能不能跳出这个能不能走边这个图的所有的边，这是一个欧拉回路的判断问题。哦，欧拉路的判断问题，不是回路。

我们来看一下。这个其实就是我们转化出来的。我们注意A是00，那么A在这儿，然后B呢，B是02。那这是B那个点C呢C是0406，所以看一下。然后E大家看一下0122。26吧。26，所以有1个2到6的边。

所以这个每一个节点的行放到这边，列放到这边，然后能不能走，就取决于我能不能一笔把这些把这些东西画出来，主要是指的边。所以这个就变成了一个欧拉路的问题。什么叫欧拉路？就是我画出一个图，每条边只能画一次。

但是节点可以反复画，就这样走，我可以反复走节点，其实就是著名的一笔画问题。我把这个问题转化成这样的话，就变成了一个一笔画问题。虽然它看起来跟哈密尔顿回路或者说哈密尔顿路问题很像哈密尔顿路问题。

再强调一遍，是说我画一个图的这个。啊，不是画一个图，我要经过一个图的所有节点，通过边经过一个图的所有节点，每个节点只经过一次，问是否可能啊，这个欧拉路是什么意思呢？是我要画一个图的所有的边。

就是这些边我必须都经过每条边只能经过一次，但是节点可以随便走。问是否可能欧拉路和哈密尔顿路看起来很像，但是欧拉路是个简单的问题，它有多样式时间的算法，通过DF就可以搞得定。

并且呢我们这个问题不用真的求一条欧拉路，而是判断它是否可行，也就是它有没有欧拉路就可以了。所以有没有欧拉路其实在数学里面一笔画问题有着著名的解法，我们统计一下每个点的度的奇偶性，判断一下就可以了。

所以这个是。从这个一个图论一个这个走格子的问题转化成一个欧拉路的图论问题了。那给大家留一个思考题，这个是密码密码锁问题，好像google面过这个问题，它是。给定一个密码锁，密码是是四位的数字。

那我们操作是什么意思呢？操作呃先不看这些文字叙叙述操作是如果现在是ABCD，我们可以把它变成BCDE怎么变的呢？它那个密码不是这个上下调的，它是左右换的，我把这个A扔掉，然后BCD往左移动一下。

然后这个低位出现了一个空格。那么我把这个空格上随便放一个数字放几都行。0到9都可以放了一个E。所以它的转换是把扔掉高位数字，就是把A扔了，把低位数字移动到高位，就是BCD整个移过来。A扔了之后。

这有一个空格，BCD移过来，然后再把低位上放上任意一个数字，所以这个是我们调整密码的过程。那么他就问了，我从任何一个状态开始，是不是可以经过000就是4个0到4个9，就是所有的组合经过一次且紧一次。

其实它原来问题问的是是是否可以这个就是最少多少次。可以经过所有状态，其实最少就是1万次。因为因为这个可以证明它是有欧拉路的那给大家一个提示怎么做？刚才说了，我们要定义一个图，就是定义它的节点和边。

那么节点是什么？我们这里面节点比较特殊，节点是三位数字，任何三位数字，也就是说有1000个节点从000到999。那边呢如果这个。节点的后两位和另外一个节点的前两位一样。

也就是ABC和BCD这个BC和这个BC是一样的，它们有一条边。那么这一条边实际上就相当于了ABCD。所以这个跟这个问题很像，这这一条边代表了一个状态，代表了1个ABCD那么我们再走一条边。

比方说BCDE就相当了就呃CDE就相当于从ABCD转化成BCDE的过程了。所以每个节点都走一次，相当于每条边都走一次。其实这种图叫line graph，就是线图可以证明它是有欧拉路的。

甚至可以证明它是有欧拉回路的。所以这个这个面试题其实还是比较经典比较难的。因为它要这么转换一下，然后转成了这个欧拉回路的问题。这个是我今天要讲的5个题，做一下总结。首先就是理解递归。

我个人觉得这个呃例二吧那个问题是好多个小问题的一个总结，是一个框架的东西。基本上和树相关的都是可以通过递归这个框架来理解来解决的。那么第二个呢就是树的便利。这个其实呃可以说今天讲到了，也可以说没讲到。

因为我没有真的取这个前序遍历一棵树，后续遍历一棵树这种问题。但是我所有的那些递归过程，它的本质就是一棵树的便利。当然我们还要掌握这个前前中后三个顺序的非递归便利。因为有时候面试需要考这种问题。

那种就是我们要自己写对栈，自己慢慢的去就是把这个便利的顺序调整好。那么还有一些其他问题，可能今天没有时间讲，比方说最近公共组先问题。我本来选了一个这样的问题，由于时间关系没有讲。

那么最近公共组先有很多这个。呃，相关的吧，可以说二叉数的最近公共组纤，当然也有一般数的最近公共组先，还有二叉搜索数的最近公共组签。我们可以利用一些这个序的顺序。还有一个是离线算法和在线算法。

什么是离线算法呢？就是这个我可以把所有的查询都告诉你，我告诉你要求A和B的B和C的C和D的这些这些查询，我都告诉你是一个死的东西，你可以提前算好了，最后一块给我什么叫在线的呢？就是呃我可以实时的输入。

我现在告诉你查A和B的最近公共线。一会儿我说你给我查一下C和D的最近公共组线，你事先不知道那些查询，这个是离线算法和在线算法的区别。对于最近公共组签，它是一个很大的问题。那还有一些就是隐视图的搜索。

这个我之前讲BFSDFS时候都已经提及了。它涉及到一个就是普通图的话，涉及到了联通分量，这个是对无项图来说的，也有叫联通分支的，还有强联通分量，这个都可以通过BFSDFS来算。

当然BFSDFS不仅限于算它还可以算很多别的东西。对于隐视图来讲，我们要自己建图。比方说今天最后一个例题，请大家仔细理。😊，解我们那个图是怎么建起来的，为什么它就是个欧拉路托扑排序？

这个其实在算法和数据结构的教材上都有所涉及。但是好像据我感觉面试考的不是很多，偶尔有这么一两个会出现。所以在这里面提一下这个本课也没有涉及到托扑排序的内容。因为它也比较简单。好，今天的课就到这里。

谢谢大家，欢迎大家给我提出批评指正，再见。😊。

![](img/679194881ab894eba409154b7fb6e955_1.png)

![](img/679194881ab894eba409154b7fb6e955_2.png)