# 人工智能—面试求职公开课（七月在线出品） - P3：O(N)时间解决的面试题(下) - 七月在线-julyedu - BV1Xf4y1r74s

🎼，欢迎收看7月算法公开课。我们这堂课的内容是ON时间内解决的面试题。下。😊，我将从如下两个方面讲述本课，先讲例题汇总。我把之前的讲过以及没讲过的问题，分成了10个类别。每个类别里面有很多题目。

最后解束本课直接看题，第一题是和最大子数组相关的。第一个就是最大子数组和，大家比较熟悉。我在动态规划实战A2里面讲过，也是例 code上第53题，方法不特别细的讲。第一个方法就是求记录最小的前缀和。

因为前缀和的差，其实就是一段连续子数组的和。什么叫前缀和就是从第一项开始连续加的若干项。比方说空就是没有数。

是一个前缀和A一是一个前缀和A1加A2也是A1加A2加A3也是显然我们可以线性时间把前缀和算出来。那么以AI结尾的最大子数组的和，其实就是从A一加到AI再减去前面的一个比较小的前缀和。

比方说A1加到A5减去A1加到A2，其实就等于A3加A4加A5。那么。😊，至于减哪个显然要减最小的。因为我们被减数一定的时候，减数肯定是越小，我们这个和就越大。所以我们就没举前缀最小的那个。

然后当前这一项减一下它就可以了，这是一个线性的第二个方法呢，其实是大家比较熟悉的所谓的动态规划，就是记录你每个位置结束的最大子数组合以AI结束的，要考虑它是不是以AI减一结束的。

然后加上AI或者我AI单独起一个就AI这一个数，这两种情况取最优。那么另外一个问题呢，就是let code上的第52题求乘积。这个和例一很像。😊，那我们也可以类似的考虑。首先如果是面试题的话。

我们需要问一下面试官有没有溢出。因为乘法很容易就得到绝对值很大的数。那我刚才提到了绝对值，因为乘积最大并不一定，前面也最大。因为它两个负数相乘，可以得到正数，所以我们需要考虑为了避免正负数的讨论。

我们需要考虑前面的最小乘积以及最大乘积。所以和和不一样的地方在于这里面我们要记录两个数，而和只记录一个数，但是方法是差不多的。看一下代码，注意乘积没有数，也就是零个数的时候，我默认是一和默认是零。

这个是习惯惯例。不过测试用力应该没有这种这种用例。😊，那现在这个东西是以DI项结尾的最大子数组乘积，这个是最大的，这个是最小的，这个是全局最小的这是全局最大的。注意全局最小的其实没什么用。

我之所以把它列在这儿，是说，如果求最小乘积，我们也可以用这个代码来做。最后return的是最小就可以了。那么对于DI项，我们同样考虑，它自己作为一个可能，要么就和之前的DI减一项的那个来。😊，乘上去。

这是三项曲最小，这是三项曲最大，这是两个式子，就是mini和max的区别。那我这里面用了一个tempo。为什么用tle呢？因为如果我这一项还用mini的话，那么下一行里面也用到mini。

这样就会有些影响。所以这个最好用tampo用tampo的话呢，最后再复过来。当然这max是没有必要用tle的。因为下面再也没有用到的。但是为了这个直观的清晰，我还是用了两个影视变量，那么把它复一下。

然后全局的就是原来的全局的和当前的最小或者最大比较简单。😊，我们看第二个问题，就是所谓的循环移位，循环一位是针对于一个数组或者一个字符串来说的。怎么叫循环一位呢？我把它比方说12345，我移动一位。

就是把一放过来移动两位，就是或者说从这个基础上再移动一位，我就把二放到末尾。每移动一次之前的那些数要往左移动一下，把后面的空位空出来，就像插入排序一样，那么我们目标就是给定一个长度为N的数组。

我们把它循环移动M位问最后结果是什么。显然我们可以一次一次做，每一次都是ON的。因为涉及到所有数都要移一下，那么总复杂度是N乘以M，那这个M特别大，其实是没有意义的。比方说这个我移动5次。

其实还是它本身，因为只有5个数，我转着圈移还是它本身，所以M对N取一数，M再大也没有关系，我们都可以把它化成小于N的一个数。那么。😊，简单的方法或者说一个经典的算法，就是利用。😊，这个翻转的过程。

我们先翻转前MV，再翻转后N减MV再总体翻转。所以我们翻转三次就可以做到。循环移动M尾，无论M等于多少，那怎么翻转呢？就可以这样做翻转。from two是双臂区间，就是一个开头，一个结尾。

不是普通的左B右开区间。如果I小于J，我们就交换，这样相当于从中间有一条对称轴，我们把它左边和右边左边和右边不断的交换，就相当于把这个串翻转了。比方说我们考虑个例子，比方说M等于2。😊。

我们先把前两位翻转就是变成了21345，后三位翻转，就变成了21543，在总体上5个数翻转一下，就变成了34512，就是21543的翻转。

所以翻转三次是很方便的那嗯时间复杂度呢就是第一次其实可以理解为ON。😊，实际上真正细致一点分析是O2N，因为第一次和第二次一共循环了N次，因为这里面一共循环的就是长度那么多次，这M和N减M一共才N次。

最后也是N次，所以是2N。那比方说这个具体怎么写呢？就是先翻转0M减1from和 two是0M减1，再翻转MN减1 from two再翻转0N减1，就是我写了这么一个函数，参数是from to。

我把这个掉三次就可以了。总体是O2N，也就是ON的。😊，那利用到这种翻转的这种方法呢，我在字符串高频面试题里面，例五讲到过一个单词翻转，其实也是利用了这个东西。那还有一个是回文判断，这个比较简单。

其实呢就是把这个变成把这个翻转变成。如果AI和AJ不相等，就return一个 first，这个就相当于从中间对称的那个地方开始，左边和右边相互比较。如果相等，全都相等，它就是回文的，不相等。

就不是回文的。所谓回文就是从左往右读，以及从右往左读，是同一个字符串，这个叫回文，这都是比较简单的，都可以利用类似于翻转的方法来解决。我们再看例3。😊，这个比较重要就是快排的partition过程。

第一个我在排序查找实战例三里面讲到过也是lea code上75题。荷兰国旗问题。为什么叫荷兰国旗呢？因为荷兰国旗只有三种颜色，我们对应于这个 code上那个问题就是对012进行交换上的排序。

因为02就三种的。它原来是把三种颜色的布条排好顺序，所以叫荷兰国旗问题不细讲，那由它引申出来的，稍微简单一点问题就是奇偶数分开正负数分开，注意这个是三种呃，小于等于大于荷兰国旗问题是三种。

那这个呢只有两种就是跟快排的经典partition是一样的。正数负数啊，奇数偶数啊，无论怎么做都是利用这种partition可以ON时间内做到。我在自符串高频面试题。

例一里面也讲到过这个问题叫零1交换排序，其实和这个上面说的这两个是同一个类型。但是呢它求的是最少的交换次数，有兴趣的可以直接去看那节课的内容，还有一个核星号做交换。这个相对于这种就比较简单。因为只。😊。

星号和非型号，我们可以提前数一下星号的个数，但是总体上也是跟partition差不多。ON时间内能解决。还有一个问题，我在数组高频面试题里面例二讲到过，也就是li上第41题，就是给你一个数组。

然后让你看从一开始123看看第一个不在这个数组里面整数是哪一个。我们也可以通过partition或者类似于交换的过程，把AI放到它应该在的位置上去。那么这里面有一大类问题。我也想提一下的。

就是中位数比K大的数或者DK小的数，以及最大的K个数和最大或者最小的K个数的问题。😊，那这是两个问题，其实可以统一解决。比方说DK大数或者DK小数的问题。啊。

首先我们要5个数取第三个数取那个东西作为这个分区元素，这个是递归的过程。啊，包括其中说到三数取中，其实这个算法时间复杂度会退化。算法导论里也有讲过。所以建议是5根数取这个中位数，然后作为分区元素。

然后把提升过程一定要分三段，因为分两段的时候有相同的数，时间复杂度会退化。这里面算法导论，其实它假设了没有相同的数，然后做了分析。我仔细分析过，如果有相同的数分成两段会有问题，还是分三段是比较正常的。

就是把小于等于大于分成三段，然后再继续递归下去，这个是找DK大的数或者DK小的数，那么找最小的K个数其实和这个很像，我们也可以利用partition过程来做。但是做完之后。

首先我要说要分成三段就是小于等于大于。那如果在等于那块可以直接返回。因为我们知道它是多少，那小于大于再继续递归。这个想说的是利用partition找到的这K个数，因为这个要返回K个数是一个数组。

那K个数是没有顺序的。我们只知道这个数都比某一个分区元素小，或者说都比某一个分区元素大。但是这个左边那些数都是没有顺序的，右边一样没有顺序。那如果要有序，我们只能用这种方法再排序。

所以它就是ON加上O logK的。那一个斜起来简单点，但是时间复杂度稍微高一点的方法，其实是用一个堆来做堆里面只维护K个数，用一个最大堆。然后如果超过K个数就把。😊，扔掉，因为根是根是最大的嘛。

所以这个时间复杂度就是N log K，因为堆里面只有K个元素，要循环N次。不过那面试的时候建议写这个，因为这个时间复杂度虽然高一点，但是实现起来会简单很多。😊，那么还有一类就是关于众数的问题。

什么叫众数呢？就是超过一半出现次数，超过一半的数。所以众数最多只有一个，有可能没有。但是要有的话，最多只有一个。这个我在数组那一章里面例五讲到过。那它有一个推广，我之前也提过。

就是找到出现次数大于K分之1的数，众数其实就是K等于2的特殊情况，这种题的一般方法就是用K减一个map或者哈西 table原则上就是如果有K个数互相之间都不相同，我就可以把这K个数都扔了。

不影响这个大于K分之1的数，这跟这个众数分析是一样的。那么这种时间复杂度，注意如果是map有一个log存在。但是如果是哈希的话，时间复杂度是K乘以N的，但是K通常我们认为是常数，所以还是ON的。

因为一般题目都是告诉你要找出现次数，比方说大于3分之14分之15分之16分之1的数，我们就可以用类似于众数的方法，因为K是一个常数。最后时间复杂度是ON的。😊，那还有一类就是单调对战。

这个我在站和队列里面也是例五讲到过注意某一块入站的时候，它的左边界确定什么叫左边界这一块往左能够延伸的最长的长度确定了，出站的时候，这一块往右能够延伸的最长的长度就确定了。那么我们有了左边有了右边。

我们就知道这一块本身它能走的长度是多少。那么它的高度也是已知的长乘以那个高，就是它的面积，那每一块我们都这么做，取个最大就可以了。这个时间复杂度是个ON的，因为每一块只出入站一次。尽管可能有两重循环。

但是时间复杂度还是ON的，所以再次强调算时间复杂度不要简单的直接看循环个数，还是要仔细分析循环变量的变化。😊，那滑动窗口的最值，这个其实我也是在站和队列里面。例六讲到过，它是一个这个呃单调队列的问题。

我们可以用堆来解决，但是用单调队列可以达到线性的复杂度，而且避免了写堆的复杂，它就是一个双端队列。那，这里面再举一个例子，它是口d上的一个问题。我觉得它把单调队列发挥到了极致。什么题呢？😊。

给定一个整数数组和一个K也是整数，问有多少对下标就是多少个peI和J满足这个I到J之间的最大值和I到J之间的最小值的差是小于等于K。😊，那我们可以想一下，如果I和J满足条件，假设我们有I和J满足条件了。

那么它的子窗口就是I加1J啊，I加2J啊，J不变，I不断增加，其实都是满足条件的。为什么呢？因为这个小一点的窗口里面的最大值肯定。😊，小于等于这个大窗口的最大值。最小值呢这个小一点，它候选的数候少。

它的最小值肯定大于等于这个IJ的最小值。所以这个最大值更小了一点，最小值更大了一点。那么这个差距就更小了。如果大窗口差距满足小于等于K，那么小窗口一定也满足小于等于K。

那言外之意就是我们对于一个给定的I来讲，假设我们求出一个尽可能大的J，或者说找到第一个不满足条件的J，因为满足条件都是连续的，找到第一个不满足条件的J，后面肯定也不满足条件了。😊，那么对I加一来讲。

我那个J没有必要再从头再找一遍了。J就从当前的位置继续往右划就行了。所以这里面大家可以看到I和J并没有向左滑的过程，就是这个窗口I到J，然后I加一的时候，J也还要从当前位置不断的加。所以这是一个线性的。

那线性的关键问题是我们如何求I到这里面的最大值最小值，还是刚才那个这个边界不断的在往右走。所以如果我们用一个队列保存这里面的数的话，只要出对的数再也不会入队了。因为窗口在不断的往右滑动。

所以这个是单调队列的一个极致。我们用两个单调队列，一个维护最大值，一个维护最小值。关键问题就是滑动出去的，再也不会进来。我们看一下。😊，这个代码贴的有点小，首先这个就保存最小值，这个保保存最佳最大值。

大家想象一下，我当时讲的那个滑动窗口什么意思呢？我们最小值如果有一个老的值比它大的话，那么老的值显然永远不会最小值。因为有它在这，并且它新滑动窗口无论怎么滑，这个新值在这，并且它小，所以旧值就没用了。

那同理如果。😊，有一个老的值，并且它比较小的话，那最大值就没有意义了。那么这样的话，我们用这个对头就是真正的最大值和最小值。那如果它小于等于K，我们就一直把右边界往右滑，注意I是没变了，这是内存循环。

那如果它不满足条件，我们就退出来，那不满足条件的时候，answer其实加上的就是J减I，就是有这么多对都满足条件，到这是不满足的。那么这个就是我之前讲到的所谓过期，因为对头是最小的，这里面对头是最大的。

但是我这个I要划过去了，I要加加了I划过去的时候，这个就是所谓的不得不出对，所以这里面两个well是那个单调关系决定的，它必须出对。而这个是相当于时间戳决定的，它必须出对，也就是所谓的不得不出对的问题。

所以这个就是把滑动窗口应用到极致。这里面是说原题有一个是怕超过in。如果它的结果大于等于一个很大的数，这好像是十的9次方，就return1的9次方。😊，这个是题目本身的一个设计。

所以跟这个算法本身没有关系，所以我直接把它列到这了。所以这句话没有什么意义，这个是滑动窗口相关的问题。啊，还有一大类是数相关的。我在数图那一章里面也讲到过，有这么多东西，数的高度，这个是普通数。

当然也有二叉树都可以立 code上也有类似的题目。二叉树的对称判断二叉数是否平衡，二叉数的最小深度，这个其实是最大深度，这个是最小深度，给定一个和求指定核的所有路径以及二叉数和双向链表转换。

包括二叉树的前序中序以及后续便历，这些都可以ON时间内做到。我之前也提到过，因为数比较特殊，它有N个节点，N减一条边，它节点和边是同一个量级的都是ON的，我们对于它做遍历，做什么都可以在ON时间内解决。

那我想提一个比较经典的比较巧妙的，并且不太难的算法，就是求一个无根数的直径，什么叫无根数呢？就是普通的数无向无核图，没有一个节点作为根。😊，那么给定一个无向无环图，就是N减N个节点，N减一条边。

确切的说应该叫无向无环连通图。那求距离最远的两个点，这个求的是两个点，这两个点之间的距离就叫做树的直径，也就是树里面最长的那条边。首先大家可以想象一下，最长的那条边一定是两片叶子。因为如果不是叶子。

还可以再往更长的地方走。叶子就是度为一的节点，相当于可以用它做端点。😊，那比较简单的算法，大家可以想一下它为什么是对的。😊，我以任何一个点为根，我找到距离它最远的节点X，再以X为根。

再找到距它最距X最远的节点Y，那么XY就是一条直径，相当于先找的一个端点，再找到另外一个端点，这两个端点之间就是一条直径。那么如何找到就是距离根最远的节点呢，其实这个就是7。1的内容，它就是数的高度。

因为高度本身就定义为最远的节点。我们现在是变成一个有根数。因为以任意节点为根嘛，然后这个是以X为根嘛，所以求高度经典方法就是DFS不断的做下去，找到最深的那个点就可以了。

所以这个算法巧妙简单就简单在它两次DFS就求出了我们想要的内容，那关键是如何证明大家仔细思考一下。😊，例八也是滑动窗口相关的，但是我把它单独提出来了，因为它和单调队列的关系不大。

刚才那个讲的主要还是单调队列。那这里面因为这个题比较新，是let code上209题，给定一个数组里面全是正整数我标红了，整数不重要。

关键是全是正数再给定一个正整数S求数组里面连续多少个数满足总和不小于S，就是窗口尽可能小的一段，让它总和大于等于S。因为我取的数越多，显然和越大嘛，就关键就是所有数都是正数。

这里面有一个核心问题就是如果一个大的窗口不满足条件，它的任意子窗口也不满足条件。因为显然所有数都是正数。那么我这么多数都不满足，它任意的小一段显然也都不满足，因为全是正的取的少和肯定更小。

那么我们就划这个窗口IJ。如果当前和太小的话，我们就试图增大它就加加J。如果当前和过大的话，我们就试图减小它就把I往右移，所以无。😊，这就是加加A加加J的问题，看一下代码。😊，但如果没解就返回0。

那么我们可以看一下，这里面和不够大，我们就不断的加不断的加J这边。那如果和足够大，我们就不断的把I缩了。那然后这就是一组可能的解更新一下窗口大小，所以也不难。那ON的这种就是复杂度分析可以不讲了。

因为I和J都在不断的增，这个I加加这个J加加从来没有减小过，然后一共也就循环了2N次，所以还是ON的。😊，那这里面我之前讲到过一个类似的问题，就是字符串里面的例四子串变位词，其实跟它意思一样。

也是滑动窗口。我维护窗口里面的字符串的就是字符的个数差。然后lead code上有两个题，一个第76题，一个第三题。其实6题是说找到一个最短的子串包含全部另外一个串里面的全部字母。

这个其实和例四是就和8。2是一个问题。然后无重复子串的最长子串，无重复字符的最长子串就是找到一个尽可能大的窗口里面每个字符只出现一次。同样这个其实也满足我刚才说的那个，如果这窗口太大了。

我们就把左边界往右移呃往右移。如果是右这个窗口太小了，就是里边字符都只出现一次，我们就把右边界往也往右移，就是扩大窗口和缩小窗口。并且也是如果一个这个。😊，小窗口不满足条件。

那么它的大窗口也肯定不满足条件，因为肯定已经有重复了。所以跟刚才讲那个是类似的。刚才那个是如果大窗口不满足，小窗口一定不满足，这个是反着的小窗口不满足大窗口一定也不满足。所以这个都是滑动窗口的问题。

基本上就是一个左边界一个右边界根据不同的条件都在共同的往右滑就可以做了。那还有一类是列表相关的。我之前其实大都提过，只是没有实现。比方说求列表长度翻转翻转有很多种，包括K一组翻转啊。

这是li code上92、25、206题啊，列表的插入删除，有随机指针的列表复制这let code上14720382、83、138题，两个有序列表求交。这个不光是列表。

这个数组什么的都可以做li code上160题找环有没有起点，141、142题倒数第K元素19题。其实还有一个是li code没有的，就是列表判断是否回文，其实我们可以。😊，用对战是一种方法。

还有一种是O一空间的，但是呢要把链表从中间断开，然后把后面翻转一下和前面比较一下。因为翻转我们可以线性时间能做到。啊，最后如果要求不改变这个列表的话，我们还需要翻回去。总之呢列表是一种线性的结构。

我们便利啊插入删除就是增删查改这些操作都可以在线性的时间内完成，这是也是一大类那最后呢是我想讲的就是之前没有提到的问题。啊，第一个就是to sum上最早的一个题。那之所以没有选，就是之前之所以没有讲它。

是因为它需要排序，我不太喜欢排序之后是ON的这个排序要Nlog n嘛。但是呢我们可以用哈西。😊，前提条件是哈希要设计的足够好，所以这种ON就感觉上不是一个绝对的ON。

当然我们一般面试的时候可以理解说哈希足够好，我们对于X查找S减X，那么扫一遍就可以搞定了。所以这个题就迟迟没有讲，只是在这里提一下，用哈希的话，可以在ON时间内做到，或者这个数组本身是排好序的。😊。

那么10。2是其实是之前google的一个面试题。给定一个1到N的排列，就是一串数。我们每次可以选一个数，把这个数啊放到末尾，当然或者也可以把它放到开头，放到哪儿都可以。😊。

那我们至少要操作几次才能把它排好序。看起来这个问题很难。我们可以仔细分析一下，我们一其实没有必要动，因为没有理由动一，我们把二到N都排好了，一自然就排好了。那如果我们要移动X，我们决定把X放到末尾。

因为我们操作只能放到末尾，要把X放到末尾，必须在它之后把X加1X加2以及N都放到末尾，因为没有办法，那些数它放到末尾，它就是最后一个了，那些数都在它前面，我们必须要把这些数都放到末尾。那么。😊。

言外之意就是一到X减一都是有序的。我们的目标其实是找到尽可能大的一个X，然后让前面那些数，当然中间可能加杂别的数。但是无论加载什么数，一到X减一那些数，从左到右都是按顺序出现的。然后呢。

我们把这个从X到N那些数都把它移动到末尾，总体移动了N减X次，那么其实我们这个就这么做。当然这里面X和w差了一个一，我们就看一下，现在想要找一w等于一嘛，看看能不能找到一找到一了。

我们看一后面能不能找到2，就是我们按顺序看，最长能找到多少个数。那么从这个w到Nw是第一个没找到的数嘛，因为w不断的再加，从到N就必须要一个一个的移动到末尾。所以这个看似复杂的问题，扫一遍。

看看有多少个数是按顺序出现的就可以了。😊，那这个题呢其实跟刚才那个题差不多，是摩根斯坦利的一个一个比赛题。但是我把它简化了，本质就是也是这样。它呢操作是既可以把它放到开头，也可以放到末尾，跟刚才类似。

刚才只能放到末尾，这个是可以放两头。那么我们的操作其实是我们要把一到Y放到开头。当然这个是按倒序，我们要把Y放到开头，Y减一放到开头，一直到一放到开头X那边也是类似的。我们把X到N一个一个的放到末尾。

那。😊，言外之意就是X加一呃，这个Y加一到X减一中间那段是有序的。如果这段是有序的，我们就可以把这这部分移动到开头，这部分移动到末尾就变成了一到N啊。😊，跟刚才类似。

我们但是我们需要统计一下哪些数是按顺序出现的。我们用一个动态规划的算法，用DPX表示从X开始，就是X这个位置开始往后。😊，有多少个数或者说有多长的数是按顺序出现的。

比方说DPX就表示XX加一一直到X加DPX减一是按顺序出现的。有这么长，从X开始有这么长的数是按顺序出现的，在元数组里面，那么倒着循环I其实这样有这么一个式子存在，要AI是连续出现的。

我们就要看一下AI加一有多长是出现的，那么加上去就可以了。那前提就是如果没出现的话，这个东西是0。比方说AI是目AI加一没有在AI的右边的话，我们认为这个数是零，所以我把初值负成零了。

那并且我们是倒着循环的。因为这个数是就是我们是用大值推的小值嘛，所以倒着循环I。那么这样弄完之后，我们就知道。😊，从AI开始最长连了多少段，我们的目标就是从中间找到尽可能长的一个段嘛。

然后我这里面就相当于用这个数组记录了最长的那个段，最后在M里面，那么就返回N减M，就中间这段是不用动的，剩下那N减M的时候必须要米一道开头要米一道末尾。所以看似很复杂的一个问题。

我们都可以ON时间内做到。😊，只不过这个还用了ON的空间。那上一个问题是O一的空间。啊，思路是类似的这是一个动态规划的思想。大家可以仔细的体会一下。那结束语其实还是老生常谈了，就是ON是一个很神奇的。

这个可以说是一大类问题，大家要多思考，勤练习，多写代码，多实践。好，今天的课就到这里，谢谢大家，欢迎大家给我提出批评指正。😊。



![](img/55b79462d01eeff308e09ca947e63eb7_1.png)

![](img/55b79462d01eeff308e09ca947e63eb7_2.png)