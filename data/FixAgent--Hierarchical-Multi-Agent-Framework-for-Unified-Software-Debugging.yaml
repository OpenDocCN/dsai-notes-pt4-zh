- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2025-01-11 12:41:14'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2025-01-11 12:41:14
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FixAgent：统一软件调试的分层多智能体框架
- en: 来源：[https://arxiv.org/html/2404.17153/](https://arxiv.org/html/2404.17153/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://arxiv.org/html/2404.17153/](https://arxiv.org/html/2404.17153/)
- en: Cheryl Lee¹, Chunqiu Steven Xia², Longji Yang¹, Jen-tse Huang¹,
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Cheryl Lee¹, Chunqiu Steven Xia², Longji Yang¹, Jen-tse Huang¹，
- en: Zhouruixing Zhu³, Lingming Zhang², Michael R. Lyu¹
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Zhouruixing Zhu³, Lingming Zhang², Michael R. Lyu¹
- en: ¹The Chinese University of Hong Kong, ²University of Illinois Urbana-Champaign,
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ¹香港中文大学，²伊利诺伊大学香槟分校，
- en: ³The Chinese University of Hong Kong, Shenzhen
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ³香港中文大学（深圳）
- en: '[cheryllee@link.cuhk.edu.hk](mailto:cheryllee@link.cuhk.edu.hk), chunqiu2@illinois.edu,
    1155191588@link.cuhk.edu.hk,'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[cheryllee@link.cuhk.edu.hk](mailto:cheryllee@link.cuhk.edu.hk), chunqiu2@illinois.edu,
    1155191588@link.cuhk.edu.hk，'
- en: jthuang@cse.cuhk.edu.hk, zhouruixingzhu@link.cuhk.edu.cn, lingming@illinois.edu,
    lyu@cse.cuhk.edu.hk
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: jthuang@cse.cuhk.edu.hk, zhouruixingzhu@link.cuhk.edu.cn, lingming@illinois.edu,
    lyu@cse.cuhk.edu.hk
- en: Abstract
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Software debugging is a time-consuming endeavor involving a series of steps,
    such as fault localization and patch generation, each requiring thorough analysis
    and a deep understanding of the underlying logic. While large language models
    (LLMs) demonstrate promising potential in coding tasks, their performance in debugging
    remains limited. Current LLM-based methods often focus on isolated steps and struggle
    with complex bugs. In this paper, we propose the first end-to-end framework, FixAgent,
    for unified debugging through multi-agent synergy. It mimics the entire cognitive
    processes of developers, with each agent specialized as a particular component
    of this process rather than mirroring the actions of an independent expert as
    in previous multi-agent systems. Agents are coordinated through a three-level
    design, following a cognitive model of debugging, allowing adaptive handling of
    bugs with varying complexities. Experiments on extensive benchmarks demonstrate
    that FixAgent significantly outperforms state-of-the-art repair methods, fixing
    1.25$\times$ to 2.56$\times$ bugs on the repo-level benchmark, Defects4J. This
    performance is achieved without requiring ground-truth root-cause code statements,
    unlike the baselines. Our source code is available on an anonymous link: [https://github.com/AcceptePapier/UniDebugger](https://github.com/AcceptePapier/UniDebugger).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 软件调试是一项耗时的工作，涉及一系列步骤，如故障定位和补丁生成，每个步骤都需要进行深入分析，并对底层逻辑有深刻理解。虽然大语言模型（LLMs）在编程任务中展现了有希望的潜力，但在调试方面的表现仍然有限。当前基于LLM的方法通常专注于孤立的步骤，并且在处理复杂的错误时效果不佳。本文提出了第一个端到端的框架——FixAgent，通过多智能体协同进行统一调试。该框架模拟了开发人员的整个认知过程，每个智能体专门负责该过程中的一个特定组件，而不是像以前的多智能体系统那样模仿独立专家的行动。智能体通过三层设计进行协调，遵循调试的认知模型，能够适应处理复杂程度各异的错误。在大量基准测试中的实验结果表明，FixAgent显著超越了最先进的修复方法，在代码库级基准测试Defects4J上修复了1.25$\times$到2.56$\times$的错误。与基准方法不同，这一性能不依赖于真实根本原因代码语句。我们的源代码可以通过匿名链接访问：[https://github.com/AcceptePapier/UniDebugger](https://github.com/AcceptePapier/UniDebugger)。
- en: 'FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: FixAgent：统一软件调试的分层多智能体框架
- en: Cheryl Lee¹, Chunqiu Steven Xia², Longji Yang¹, Jen-tse Huang¹, Zhouruixing
    Zhu³, Lingming Zhang², Michael R. Lyu¹ ¹The Chinese University of Hong Kong, ²University
    of Illinois Urbana-Champaign, ³The Chinese University of Hong Kong, Shenzhen [cheryllee@link.cuhk.edu.hk](mailto:cheryllee@link.cuhk.edu.hk),
    chunqiu2@illinois.edu, 1155191588@link.cuhk.edu.hk, jthuang@cse.cuhk.edu.hk, zhouruixingzhu@link.cuhk.edu.cn,
    lingming@illinois.edu, lyu@cse.cuhk.edu.hk
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Cheryl Lee¹, Chunqiu Steven Xia², Longji Yang¹, Jen-tse Huang¹, Zhouruixing
    Zhu³, Lingming Zhang², Michael R. Lyu¹ ¹香港中文大学，²伊利诺伊大学香槟分校，³香港中文大学（深圳） [cheryllee@link.cuhk.edu.hk](mailto:cheryllee@link.cuhk.edu.hk),
    chunqiu2@illinois.edu, 1155191588@link.cuhk.edu.hk, jthuang@cse.cuhk.edu.hk, zhouruixingzhu@link.cuhk.edu.cn,
    lingming@illinois.edu, lyu@cse.cuhk.edu.hk
- en: 1 Introduction
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1 引言
- en: 'Debugging is a crucial process of identifying, analyzing, and rectifying bugs
    or issues in software. Significant advancements (Yang et al., [2024](https://arxiv.org/html/2404.17153v2#bib.bib55);
    Xia and Zhang, [2022](https://arxiv.org/html/2404.17153v2#bib.bib52); Wei et al.,
    [2023](https://arxiv.org/html/2404.17153v2#bib.bib47); Xia and Zhang, [2024](https://arxiv.org/html/2404.17153v2#bib.bib53))
    have been achieved in addressing bugs with the boost of LLMs—they typically propose
    a prompting framework and query an LLM to automate an isolated phase in debugging,
    generally Fault Localization (FL) or Automated Program Repair (APR). FL attempts
    to identify suspicious code statements, while APR provides patches or fixed code
    snippets. A typical “diff” patch records the textual differences between two source
    code files, as shown in Figure [1](https://arxiv.org/html/2404.17153v2#S1.F1 "Figure
    1 ‣ 1 Introduction ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified
    Software Debugging"). The goal of debugging is to apply such a patch to fix the
    bug accurately.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '调试是识别、分析和修复软件中的错误或问题的关键过程。随着LLM的推动，已在解决错误方面取得了显著进展（Yang等人，[2024](https://arxiv.org/html/2404.17153v2#bib.bib55);
    Xia和Zhang，[2022](https://arxiv.org/html/2404.17153v2#bib.bib52); Wei等人，[2023](https://arxiv.org/html/2404.17153v2#bib.bib47);
    Xia和Zhang，[2024](https://arxiv.org/html/2404.17153v2#bib.bib53)）——它们通常提出一种提示框架，并查询LLM来自动化调试中的某个独立阶段，通常是故障定位（FL）或自动程序修复（APR）。FL试图识别可疑的代码语句，而APR则提供补丁或修复的代码片段。典型的“diff”补丁记录两个源代码文件之间的文本差异，如图[1](https://arxiv.org/html/2404.17153v2#S1.F1
    "Figure 1 ‣ 1 Introduction ‣ FixAgent: Hierarchical Multi-Agent Framework for
    Unified Software Debugging")所示。调试的目标是应用这种补丁来准确修复错误。'
- en: '![Refer to caption](img/8611462bef5c22b83b1f3c1011abc71e.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/8611462bef5c22b83b1f3c1011abc71e.png)'
- en: 'Figure 1: An example of the “diff” patch, where “@@ -142,5 +142 5 @@” indicates
    line 142 is modified.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图1： “diff”补丁的示例，其中“@@ -142,5 +142 5 @@”表示第142行被修改。
- en: '![Refer to caption](img/6b594568629f0a373823004123d778ce.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/6b594568629f0a373823004123d778ce.png)'
- en: 'Figure 2: Overview of FixAgent. It starts with the simple L1 repair. If no
    plausible patch is generated, the L2 repair is triggered, and so is L3. Agents
    on the same level can communicate with others.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：FixAgent概述。它从简单的L1修复开始。如果没有生成合理的补丁，则触发L2修复，L3也会被触发。处于同一层级的智能体可以相互通信。
- en: While LLMs demonstrate great potential in addressing individual debugging tasks
    for basic bugs, previous studies cannot offer a satisfying solution for the entire
    debugging task. To bridge this gap, we propose the first multi-agent framework,
    FixAgent, for end-to-end unified debugging. A key challenge lies in how to coordinate
    multiple agents. Previous studies that employ LLM-based multi-agent frameworks
    for complex problem-solving typically regard each agent as an expert and imitate
    the collaborative practice in humans (Hong et al., [2024](https://arxiv.org/html/2404.17153v2#bib.bib14);
    Islam et al., [2024](https://arxiv.org/html/2404.17153v2#bib.bib17); Qian et al.,
    [2024](https://arxiv.org/html/2404.17153v2#bib.bib37)). However, such a paradigm
    has limitations in debugging. It overly emphasizes mimicking human collaboration,
    thus not suitable for the logical, stepwise nature of debugging. Furthermore,
    it faces challenges in the fine-grained allocation and optimization of resources
    regarding problem difficulties. The communication links among agents are mesh-like
    and extensive, leading to unnecessary high communication redundancy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然LLMs在处理基本错误的单个调试任务中展现了巨大的潜力，但以往的研究未能为整个调试任务提供令人满意的解决方案。为了弥补这一空白，我们提出了首个多智能体框架FixAgent，用于端到端统一调试。一个关键的挑战在于如何协调多个智能体。以往采用基于LLM的多智能体框架进行复杂问题解决的研究，通常将每个智能体视为专家，并模仿人类的协作实践（Hong等人，[2024](https://arxiv.org/html/2404.17153v2#bib.bib14);
    Islam等人，[2024](https://arxiv.org/html/2404.17153v2#bib.bib17); Qian等人，[2024](https://arxiv.org/html/2404.17153v2#bib.bib37)）。然而，这种范式在调试中存在局限性。它过于强调模仿人类协作，因此不适用于调试的逻辑性和步骤性特征。此外，在问题难度的细粒度资源分配和优化方面也面临挑战。智能体之间的通信链接呈网状且广泛，导致不必要的高通信冗余。
- en: 'In response, we uniquely structure FixAgent as a hierarchical multi-agent coordination
    paradigm, as shown in Figure [2](https://arxiv.org/html/2404.17153v2#S1.F2 "Figure
    2 ‣ 1 Introduction ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified
    Software Debugging"). Our key insight is that an agent should act as a specific
    component of the cognitive process of debugging rather than mirroring the actions
    of an independent expert in teamwork. In teamwork, members bring diverse perspectives
    and backgrounds. They engage in bidirectional discussion and negotiation to share
    knowledge and solve tasks collaboratively. In contrast, the cognitive process
    is unidirectional and coherent, with each stage building on the last. It accumulates
    knowledge and employs tools toward a common objective, primarily relying on self-reflection
    to guide thought. Since the latter aligns seamlessly with debugging, we ground
    the multi-agent coordination in Hale and Haworth’s cognitive debugging model (Hale
    and Haworth, [1991](https://arxiv.org/html/2404.17153v2#bib.bib12)). It argues
    that developers employ a multi-level goal-orientated mechanism during debugging
    based on structural learning theory (Hale et al., [1999](https://arxiv.org/html/2404.17153v2#bib.bib13)).
    The initial level only provides quick and straightforward solutions, and if that
    fails, higher levels of repairs are triggered for complex bugs, entailing more
    cognitive activities that involve deeper analysis, tool invocation, and external
    information ingestion.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '作为回应，我们独特地将FixAgent构建为一个分层的多智能体协调范式，如图[2](https://arxiv.org/html/2404.17153v2#S1.F2
    "Figure 2 ‣ 1 Introduction ‣ FixAgent: Hierarchical Multi-Agent Framework for
    Unified Software Debugging")所示。我们的关键见解是，智能体应该作为调试认知过程的一个特定组件进行作用，而不是像团队合作中的独立专家那样反映行为。在团队合作中，成员们带来多样化的视角和背景，他们通过双向讨论和协商分享知识并共同解决任务。相比之下，认知过程是单向且连贯的，每个阶段都建立在上一个阶段的基础上，积累知识并利用工具朝着共同目标前进，主要依靠自我反思来引导思维。由于后者与调试过程无缝契合，我们将多智能体协调基础建立在Hale和Haworth的认知调试模型上（Hale和Haworth，[1991](https://arxiv.org/html/2404.17153v2#bib.bib12)）。该模型认为，开发者在调试过程中会基于结构化学习理论（Hale等，[1999](https://arxiv.org/html/2404.17153v2#bib.bib13)）采用多层次的目标导向机制。初始层级仅提供快速和简便的解决方案，如果失败，则触发更高层次的修复，处理复杂的错误，涉及更多的认知活动，包括更深层次的分析、工具调用和外部信息的获取。'
- en: 'Our framework encompasses seven agents, each specialized in a distinct cognitive
    state: 1) Helper: retrieves and synthesizes debugging solutions through online
    research; 2) RepoFocus: analyzes dependencies and identifies bug-related code
    files; 3) Summarizer: generates code summaries; 4) Slicer: isolates a code segment
    (typically tens to hundreds of lines) likely to cause an error; 5) Locator: marks
    the specific root-cause code lines; 6) Fixer: generates patches or fixed code
    snippets; 7) FixerPro: generates an optimized patch upon the testing results of
    the patch generated by Fixer along with a detailed analysis report.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的框架包括七个智能体，每个智能体专注于一个独特的认知状态：1) Helper：通过在线研究提取并合成调试解决方案；2) RepoFocus：分析依赖关系并识别与错误相关的代码文件；3)
    Summarizer：生成代码摘要；4) Slicer：隔离可能导致错误的代码段（通常是数十到数百行）；5) Locator：标记特定的根本原因代码行；6)
    Fixer：生成修复补丁或修复代码片段；7) FixerPro：基于Fixer生成的补丁测试结果，生成优化的补丁，并附带详细的分析报告。
- en: Particularly, FixAgent first isolates the code file most likely causing the
    error through unit testing. On level one (L1), only Locator and Fixer are initiated
    for simple bugs. If the generated patch is not plausible (i.e., pass all test
    cases), Summarizer and Slicer are triggered with the bug-located code file on
    level two (L2). Then Locator, Fixer, and FixerPro are called sequentially with
    access to the responses from Summarizer and Slicer. If it still fails, FixAgent
    undertakes a deeper inspection and thus activates all agents (i.e., level three,
    L3), where Helper searches for solutions online to guide all the other agents,
    and RepoFocus examines the entire program to provide a list of bug-related code
    files, followed by the other agents working in line. Slicer, Locator, and Fixer
    can invoke traditional code analysis tools on the last two levels to collect static
    and dynamic analysis information.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，FixAgent首先通过单元测试隔离出最有可能导致错误的代码文件。在一级（L1）中，仅初始化Locator和Fixer来处理简单的错误。如果生成的修补程序不可行（即未通过所有测试用例），则在二级（L2）中触发Summarizer和Slicer，处理带有错误定位代码文件的情况。接着，Locator、Fixer和FixerPro按顺序被调用，并访问Summarizer和Slicer的响应。如果仍然失败，FixAgent进行更深入的检查，并启动所有代理（即三级，L3），其中Helper在线搜索解决方案，指导其他所有代理，而RepoFocus检查整个程序，提供与错误相关的代码文件列表，随后其他代理按顺序工作。在最后两个级别上，Slicer、Locator和Fixer可以调用传统的代码分析工具，收集静态和动态分析信息。
- en: We evaluate FixAgent on four benchmarks with bug-fix pairs across three programming
    languages, including real-world software (Defects4J Just et al., [2014](https://arxiv.org/html/2404.17153v2#bib.bib19))
    and competition programs (QuixBugs Lin et al., [2017](https://arxiv.org/html/2404.17153v2#bib.bib26),
    Codeflaws Tan et al., [2017](https://arxiv.org/html/2404.17153v2#bib.bib42), ConDefects Wu
    et al., [2024](https://arxiv.org/html/2404.17153v2#bib.bib50)). On Defects4J,
    FixAgent achieves a new state-of-the-art (SoTA) by correctly fixing 197 bugs with
    286 plausible fixes. Our method does not require prior FL while still outperforming
    strong baselines like ChatRepair, which uses ground-truth root causes with 10x
    sampling times. Plus, FixAgent fixes all bugs in QuixBugs and generates 2.2$\times$
    more plausible fixes on Codeflaws. Our ablation study shows that FixAgent consistently
    makes significant improvements across various LLM backbones.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在四个基准上评估了FixAgent，这些基准包含跨三种编程语言的错误修复对，包括真实世界的软件（Defects4J Just等，[2014](https://arxiv.org/html/2404.17153v2#bib.bib19)）和竞赛程序（QuixBugs
    Lin等，[2017](https://arxiv.org/html/2404.17153v2#bib.bib26)，Codeflaws Tan等，[2017](https://arxiv.org/html/2404.17153v2#bib.bib42)，ConDefects
    Wu等，[2024](https://arxiv.org/html/2404.17153v2#bib.bib50)）。在Defects4J上，FixAgent通过正确修复197个错误和286个合理的修复方案，达到了新的最先进水平（SoTA）。我们的方法不需要事先进行FL，但仍然优于强基线，如ChatRepair，它使用真实根本原因并进行10倍的采样次数。此外，FixAgent修复了QuixBugs中的所有错误，并在Codeflaws上生成了2.2$\times$更多合理的修复方案。我们的消融研究表明，FixAgent在不同的LLM骨架上始终能够显著改进。
- en: 2 Related Work
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 相关工作
- en: 'Software Debugging: FL and APR are the two core steps in software debugging Benton
    et al. ([2020](https://arxiv.org/html/2404.17153v2#bib.bib6)). Many studies aim
    to automate either step. Traditional FL are typically spectrum-based (Abreu et al.,
    [2009](https://arxiv.org/html/2404.17153v2#bib.bib2), [2006](https://arxiv.org/html/2404.17153v2#bib.bib1);
    Zhang et al., [2011](https://arxiv.org/html/2404.17153v2#bib.bib58)) or mutation-based (Moon
    et al., [2014](https://arxiv.org/html/2404.17153v2#bib.bib33); Li and Zhang, [2017](https://arxiv.org/html/2404.17153v2#bib.bib23);
    Zhang et al., [2013](https://arxiv.org/html/2404.17153v2#bib.bib59)). Learning-based
    FL learns program behaviors from rich data sources (Li et al., [2021](https://arxiv.org/html/2404.17153v2#bib.bib24),
    [2022](https://arxiv.org/html/2404.17153v2#bib.bib25); Lou et al., [2021](https://arxiv.org/html/2404.17153v2#bib.bib30);
    Li et al., [2019](https://arxiv.org/html/2404.17153v2#bib.bib22)) via multiple
    types of neural networks. Recently, LLMAO (Yang et al., [2024](https://arxiv.org/html/2404.17153v2#bib.bib55))
    proposes to utilize LLMs for test-free FL. APR research either searches for suitable
    solutions from possible patches (Goues et al., [2012](https://arxiv.org/html/2404.17153v2#bib.bib9);
    Weimer et al., [2009a](https://arxiv.org/html/2404.17153v2#bib.bib48), [b](https://arxiv.org/html/2404.17153v2#bib.bib49))
    or directly generates patches by representing the generation as an explicit specification
    inference (Mechtaev et al., [2016](https://arxiv.org/html/2404.17153v2#bib.bib32);
    Nguyen et al., [2013](https://arxiv.org/html/2404.17153v2#bib.bib34); Liu et al.,
    [2019](https://arxiv.org/html/2404.17153v2#bib.bib27)). Learning-based studies
    ((Lutellier et al., [2020](https://arxiv.org/html/2404.17153v2#bib.bib31); Jiang
    et al., [2021](https://arxiv.org/html/2404.17153v2#bib.bib18); Ye et al., [2022](https://arxiv.org/html/2404.17153v2#bib.bib57)))
    translate faulty code to correct code using neural machine translation (NMT).
    On top of directly prompting LLMs (Xia et al., [2023](https://arxiv.org/html/2404.17153v2#bib.bib51)),
    recent studies have explored prompt engineering (Xia and Zhang, [2024](https://arxiv.org/html/2404.17153v2#bib.bib53),
    [2022](https://arxiv.org/html/2404.17153v2#bib.bib52)) or combining code synthesis (Wei
    et al., [2023](https://arxiv.org/html/2404.17153v2#bib.bib47)) to improve LLM
    for APR.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 软件调试：FL和APR是软件调试中的两个核心步骤Benton等人（[2020](https://arxiv.org/html/2404.17153v2#bib.bib6)）。许多研究旨在自动化这两个步骤中的任意一个。传统的FL通常基于频谱（Abreu等人，[2009](https://arxiv.org/html/2404.17153v2#bib.bib2)，[2006](https://arxiv.org/html/2404.17153v2#bib.bib1)；Zhang等人，[2011](https://arxiv.org/html/2404.17153v2#bib.bib58)）或基于变异（Moon等人，[2014](https://arxiv.org/html/2404.17153v2#bib.bib33)；Li和Zhang，[2017](https://arxiv.org/html/2404.17153v2#bib.bib23)；Zhang等人，[2013](https://arxiv.org/html/2404.17153v2#bib.bib59)）。基于学习的FL通过多种类型的神经网络从丰富的数据源中学习程序行为（Li等人，[2021](https://arxiv.org/html/2404.17153v2#bib.bib24)，[2022](https://arxiv.org/html/2404.17153v2#bib.bib25)；Lou等人，[2021](https://arxiv.org/html/2404.17153v2#bib.bib30)；Li等人，[2019](https://arxiv.org/html/2404.17153v2#bib.bib22)）。最近，LLMAO（Yang等人，[2024](https://arxiv.org/html/2404.17153v2#bib.bib55)）提出利用LLMs进行无测试FL。APR研究要么从可能的修补程序中寻找合适的解决方案（Goues等人，[2012](https://arxiv.org/html/2404.17153v2#bib.bib9)；Weimer等人，[2009a](https://arxiv.org/html/2404.17153v2#bib.bib48)，[b](https://arxiv.org/html/2404.17153v2#bib.bib49)），要么通过将生成表示为显式的规范推断来直接生成修补程序（Mechtaev等人，[2016](https://arxiv.org/html/2404.17153v2#bib.bib32)；Nguyen等人，[2013](https://arxiv.org/html/2404.17153v2#bib.bib34)；Liu等人，[2019](https://arxiv.org/html/2404.17153v2#bib.bib27)）。基于学习的研究（(Lutellier等人，[2020](https://arxiv.org/html/2404.17153v2#bib.bib31)；Jiang等人，[2021](https://arxiv.org/html/2404.17153v2#bib.bib18)；Ye等人，[2022](https://arxiv.org/html/2404.17153v2#bib.bib57)））通过神经机器翻译（NMT）将故障代码转换为正确代码。在直接提示LLMs的基础上（Xia等人，[2023](https://arxiv.org/html/2404.17153v2#bib.bib51)），最近的研究探讨了提示工程（Xia和Zhang，[2024](https://arxiv.org/html/2404.17153v2#bib.bib53)，[2022](https://arxiv.org/html/2404.17153v2#bib.bib52)）或结合代码合成（Wei等人，[2023](https://arxiv.org/html/2404.17153v2#bib.bib47)）以改善LLM在APR中的表现。
- en: 'Large Language Models: Various LLMs have been developed for code synthesis (Chen
    et al., [2021](https://arxiv.org/html/2404.17153v2#bib.bib7); Guo et al., [2024](https://arxiv.org/html/2404.17153v2#bib.bib10);
    Rozière et al., [2023](https://arxiv.org/html/2404.17153v2#bib.bib39)), in addition
    to general-purpose LLMs (OpenAI, [2023a](https://arxiv.org/html/2404.17153v2#bib.bib35),
    [b](https://arxiv.org/html/2404.17153v2#bib.bib36); Anil et al., [2023](https://arxiv.org/html/2404.17153v2#bib.bib4)).
    They have shown potential in solving coding-related tasks, including program repair,
    as investigated in empirical studies (Xia et al., [2023](https://arxiv.org/html/2404.17153v2#bib.bib51);
    Huang et al., [2023](https://arxiv.org/html/2404.17153v2#bib.bib16); Tian et al.,
    [2024](https://arxiv.org/html/2404.17153v2#bib.bib44)).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大型语言模型：为代码合成开发了多种LLM（Chen 等， [2021](https://arxiv.org/html/2404.17153v2#bib.bib7)；Guo
    等， [2024](https://arxiv.org/html/2404.17153v2#bib.bib10)；Rozière 等， [2023](https://arxiv.org/html/2404.17153v2#bib.bib39)），除了通用型LLM（OpenAI，
    [2023a](https://arxiv.org/html/2404.17153v2#bib.bib35)，[b](https://arxiv.org/html/2404.17153v2#bib.bib36)；Anil
    等， [2023](https://arxiv.org/html/2404.17153v2#bib.bib4)）。这些模型在解决与编程相关的任务中展现出潜力，包括程序修复，正如一些实证研究所探讨的（Xia
    等， [2023](https://arxiv.org/html/2404.17153v2#bib.bib51)；Huang 等， [2023](https://arxiv.org/html/2404.17153v2#bib.bib16)；Tian
    等， [2024](https://arxiv.org/html/2404.17153v2#bib.bib44)）。
- en: 'LLM-based Multi-Agent (LLM-MA): The inspiring capabilities of the single LLM-based
    agent boost the development of multi-agent frameworks. Recent research has demonstrated
    promising results in utilizing LLM-MA for complex problem-solving, including software
    engineering, science, and other society-simulating activities. For software engineering,
    LLM-MA studies (Qian et al., [2024](https://arxiv.org/html/2404.17153v2#bib.bib37);
    Hong et al., [2024](https://arxiv.org/html/2404.17153v2#bib.bib14); Dong et al.,
    [2023](https://arxiv.org/html/2404.17153v2#bib.bib8); Huang et al., [2024](https://arxiv.org/html/2404.17153v2#bib.bib15);
    Islam et al., [2024](https://arxiv.org/html/2404.17153v2#bib.bib17)) usually emulate
    real-world roles (e.g., product managers, programmers, and testers) and collaborate
    through communication. Hong et al. ([2024](https://arxiv.org/html/2404.17153v2#bib.bib14));
    Dong et al. ([2023](https://arxiv.org/html/2404.17153v2#bib.bib8)) adopt a shared
    information pool to reduce overhead.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基于LLM的多代理（LLM-MA）：单个基于LLM的代理所展现的启发性能力推动了多代理框架的发展。近期的研究已展示了LLM-MA在复杂问题解决中的潜力，包括软件工程、科学以及其他社会模拟活动。在软件工程领域，LLM-MA的研究（Qian
    等， [2024](https://arxiv.org/html/2404.17153v2#bib.bib37)；Hong 等， [2024](https://arxiv.org/html/2404.17153v2#bib.bib14)；Dong
    等， [2023](https://arxiv.org/html/2404.17153v2#bib.bib8)；Huang 等， [2024](https://arxiv.org/html/2404.17153v2#bib.bib15)；Islam
    等， [2024](https://arxiv.org/html/2404.17153v2#bib.bib17)）通常模拟现实世界的角色（例如，产品经理、程序员和测试人员）并通过沟通进行协作。Hong
    等（[2024](https://arxiv.org/html/2404.17153v2#bib.bib14)）；Dong 等（[2023](https://arxiv.org/html/2404.17153v2#bib.bib8)）采用共享信息池来减少开销。
- en: 3 FixAgent
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3 FixAgent
- en: 'FixAgent is an end-to-end framework for unified debugging through LLM-based
    multi-agent synergy. It comprises seven agents, each specialized as a state in
    Hale and Haworth’s cognitive debugging model with an explicit goal instead of
    being a task-oriented, individual entity. FixAgent operates on a three-level architecture,
    initializing different levels of repair involving different agents, and agents
    can adaptively invoke tools in a given toolbox. The communication among agents
    on the same level follows an assembly-line thought process rather than the mesh
    interactions typical of teams. This section introduces the profiles of agents,
    their interactions with external environments, and the hierarchical organization.
    Prompt details are displayed in [A.3](https://arxiv.org/html/2404.17153v2#A1.SS3
    "A.3 System Prompts ‣ Appendix A Appendix ‣ FixAgent: Hierarchical Multi-Agent
    Framework for Unified Software Debugging").'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 'FixAgent 是一个通过LLM基础的多代理协同工作实现统一调试的端到端框架。它包含七个代理，每个代理作为Hale 和 Haworth 的认知调试模型中的一个状态，具备明确的目标，而不是一个任务导向的个体实体。FixAgent在三层架构上运行，初始化不同层级的修复工作，涉及不同的代理，代理可以适应性地调用给定工具箱中的工具。代理之间在同一层级的沟通遵循流水线式的思维过程，而非团队中典型的网状交互。本节介绍了代理的简介、它们与外部环境的交互以及层次结构。详细的提示信息请参见
    [A.3](https://arxiv.org/html/2404.17153v2#A1.SS3 "A.3 System Prompts ‣ Appendix
    A Appendix ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified Software
    Debugging")。'
- en: 3.1 Profiles of Agents
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1 代理的简介
- en: 'All agents in FixAgent share a one-shot structure of the system prompt, which
    defines their roles, skills, actions, objectives, and constraints, followed by
    a manually crafted example to illustrate the desired response format, as shown
    in Figure [3](https://arxiv.org/html/2404.17153v2#S3.F3 "Figure 3 ‣ 3.1 Profiles
    of Agents ‣ 3 FixAgent ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified
    Software Debugging"). Moreover, all agents have access to certain meta-information
    known as bug metadata, including the bug-located code file, failing test cases,
    reported errors during compilation and testing, and program requirements described
    in natural language. The response of each agent comprises two elements: the answer
    fulfilling its goal and an explanation of its thinking. Inspired by a software
    engineering principle, rubber duck debugging (Andrew and David, [2000](https://arxiv.org/html/2404.17153v2#bib.bib3)),
    where developers articulate their expectations versus actual implementations to
    identify the gap, we request each agent to monitor key program variables and explain
    how it guides the answer.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'FixAgent 中的所有代理共享一个一次性结构的系统提示，该结构定义了它们的角色、技能、行为、目标和约束条件，随后是一个手工制作的示例，以说明期望的响应格式，如图[3](https://arxiv.org/html/2404.17153v2#S3.F3
    "Figure 3 ‣ 3.1 Profiles of Agents ‣ 3 FixAgent ‣ FixAgent: Hierarchical Multi-Agent
    Framework for Unified Software Debugging")所示。此外，所有代理都可以访问某些元信息，称为错误元数据，包括错误所在的代码文件、失败的测试用例、编译和测试时报告的错误以及用自然语言描述的程序需求。每个代理的响应包含两个元素：一个是实现其目标的答案，另一个是其思维过程的解释。受到软件工程原理——橡皮鸭调试（Andrew
    和 David，[2000](https://arxiv.org/html/2404.17153v2#bib.bib3)）的启发，开发者通过阐述他们的期望与实际实现之间的差距来识别问题，因此我们要求每个代理监控关键程序变量，并解释其如何指导答案的生成。'
- en: '![Refer to caption](img/ba55f034534b0e41528f36fcf2c558aa.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![参见说明文字](img/ba55f034534b0e41528f36fcf2c558aa.png)'
- en: 'Figure 3: A one-shot system prompt defines the role, skills, actions, objective,
    and constraints of the agent.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3：一次性系统提示定义了代理的角色、技能、行为、目标和约束条件。
- en: 'Helper. The goal of Helper is to provide references via retrieve-augmented
    generation (RAG), inspired by the fact that developers commonly utilize web search
    engines (e.g., Google) to enhance productivity (Xia et al., [2017](https://arxiv.org/html/2404.17153v2#bib.bib54)).
    By analyzing the bug metadata, Helper generates a short query and invokes an external
    search engine to retrieve the best-matching solutions. Then, it integrates the
    retrieval results and generates reference solutions that are customized for the
    context of the buggy code (e.g., variable naming and function structure). These
    are internal processes hidden from the other agents, and only the final response—a
    reference solution—can be read only on L3. Figure [4](https://arxiv.org/html/2404.17153v2#S3.F4
    "Figure 4 ‣ 3.1 Profiles of Agents ‣ 3 FixAgent ‣ FixAgent: Hierarchical Multi-Agent
    Framework for Unified Software Debugging") provides an example of the response
    from Helper.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 'Helper。Helper 的目标是通过检索增强生成（RAG）提供参考，这一方法的灵感来源于开发者通常利用网页搜索引擎（如 Google）来提高生产力的事实（Xia
    等，[2017](https://arxiv.org/html/2404.17153v2#bib.bib54)）。通过分析错误元数据，Helper 生成一个简短的查询，并调用外部搜索引擎来检索最匹配的解决方案。然后，它整合检索结果并生成根据有问题代码的上下文（如变量命名和函数结构）定制的参考解决方案。这些是隐藏在其他代理背后的内部过程，只有最终的响应——参考解决方案——才能在
    L3 级别阅读。图[4](https://arxiv.org/html/2404.17153v2#S3.F4 "Figure 4 ‣ 3.1 Profiles
    of Agents ‣ 3 FixAgent ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified
    Software Debugging")提供了 Helper 响应的示例。'
- en: '![Refer to caption](img/947a1b1faad724785b6170dc31775039.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![参见说明文字](img/947a1b1faad724785b6170dc31775039.png)'
- en: 'Figure 4: After retrieving similar solutions, Helper eventually responds with
    an executable debug guide.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4：在检索到类似的解决方案后，Helper 最终回应一个可执行的调试指南。
- en: RepoFocus. Comprehending cross-file dependencies is crucial to debugging large
    software, and real-world software is often large and complex (corresponding to
    L3 repair). However, inputting all of the code in a program may overwhelm an LLM,
    resulting in slow responses with significant resource consumption or incorrect
    results. Thus, RepoFocus provides a list of bug-related code files that need further
    examination by analyzing the bug metadata and the file structure of the program.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: RepoFocus。理解跨文件的依赖关系对于调试大型软件至关重要，而现实世界的软件往往庞大且复杂（对应于 L3 修复）。然而，将程序中的所有代码输入到一个
    LLM 中可能会使其超载，导致响应缓慢，资源消耗巨大或结果错误。因此，RepoFocus 通过分析错误元数据和程序的文件结构，提供了一份需要进一步检查的与错误相关的代码文件列表。
- en: Summarizer. Code summarization aims to generate concise, semantically meaningful
    summaries that accurately describe software functions. Unlike high-level code
    analysis, these natural language summaries better align with the training objectives
    of LLMs. Summarizer is triggered on L2 and L3. On L2, it summarizes the buggy
    code file. Though the window size of advanced LLMs can handle most single code
    files, a too-long prompt may exacerbate the illusion of LLMs. Thus, Summarizer
    handles overly long code here, in conjunction with Slicer, which narrows down
    a suspicious segment from the buggy code. On L3, Summarizer runs once on every
    bug-related file identified by RepoFocus. The other agents do not need to read
    every code line in the program while still knowing the core contents through these
    summaries.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总结器（Summarizer）。代码总结旨在生成简洁、语义明确的总结，准确描述软件功能。与高级代码分析不同，这些自然语言总结更符合大型语言模型（LLM）的训练目标。总结器在L2和L3触发。在L2时，它总结有缺陷的代码文件。尽管高级LLM的窗口大小可以处理大多数单一代码文件，但过长的提示可能加剧LLM的幻觉效应。因此，总结器在此处理过长的代码，同时与切片器（Slicer）配合，后者从有缺陷的代码中缩小可疑段落的范围。在L3时，总结器会在每个由RepoFocus识别的与错误相关的文件上运行。其他代理不需要读取程序中的每一行代码，而是通过这些总结了解核心内容。
- en: Slicer. Slicer narrows down the inspection scope by slicing out a small suspicious
    segment (typically tens of code lines) from the bug-located code file. We extract
    the beginning and end lines from the initial output to locate the segment, ensuring
    the final output is directly sliced from the original code to prevent code tampering
    caused by LLM hallucinations. Slicer is also launched for large software on the
    last two levels, where it can invoke static or dynamic analysis tools.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 切片器（Slicer）。切片器通过从错误定位的代码文件中切出一个小的可疑片段（通常是几十行代码）来缩小检查范围。我们从初步输出中提取开始和结束行以定位该片段，确保最终输出直接从原始代码中切割出来，以防止由LLM幻觉引起的代码篡改。切片器也会在最后两个级别中用于大型软件，在此它可以调用静态或动态分析工具。
- en: Locator. Locator is responsible for marking code lines with a comment “// buggy
    line” or “// missing line” to indicate faulty or missing statements. Similar to
    Slicer, we directly annotate the original code through contextual string matching.
    Locator only leverages the bug metadata on L1, where on L2, it can access the
    dynamic analysis reports. If the program is large enough so that Slicer and Summarizer
    are invoked, Locator receives the suspicious code segment (generated by Slicer)
    to replace the original complete code, along with the buggy code summary (generated
    by Summarizer).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 定位器（Locator）。定位器负责用注释“// buggy line”或“// missing line”标记代码行，以指示错误或缺失的语句。与切片器类似，我们通过上下文字符串匹配直接注释原始代码。定位器仅在L1上利用错误元数据，在L2时，它可以访问动态分析报告。如果程序足够大，以至于调用了切片器和总结器，定位器将接收由切片器生成的可疑代码段，替换原始完整代码，以及由总结器生成的错误代码总结。
- en: 'Fixer. Fixer is prompted to generate a ‘diff‘, as shown in Figure [1](https://arxiv.org/html/2404.17153v2#S1.F1
    "Figure 1 ‣ 1 Introduction ‣ FixAgent: Hierarchical Multi-Agent Framework for
    Unified Software Debugging") in Introduction. It receives code marked by Locator
    and other bug metadata. To maintain consistency between Locator and Fixer, Fixer
    first assesses whether the marked lines should be modified and then describes
    the modification. This also enables Fixer to correct possible errors made by Locator.
    On L2 and L3, Fixer also has access to static/dynamic analysis and auxiliary information
    generated by upstream agents.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '修复器（Fixer）。修复器的触发是生成一个“diff”，如引言中的图[1](https://arxiv.org/html/2404.17153v2#S1.F1
    "Figure 1 ‣ 1 Introduction ‣ FixAgent: Hierarchical Multi-Agent Framework for
    Unified Software Debugging")所示。它接收由定位器（Locator）标记的代码和其他错误元数据。为了保持定位器和修复器之间的一致性，修复器首先评估标记的代码行是否需要修改，然后描述修改内容。这还使得修复器能够纠正定位器可能犯的错误。在L2和L3时，修复器还可以访问由上游代理生成的静态/动态分析和辅助信息。'
- en: '![Refer to caption](img/6c34c5ed1c3dd4eb97eceb098e9bbf89.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![参考标题](img/6c34c5ed1c3dd4eb97eceb098e9bbf89.png)'
- en: 'Figure 5: L3 triggers all the seven agents to generate plausible patches.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：L3触发所有七个代理生成合理的补丁。
- en: FixerPro. FixerPro extends and complements Fixer by generating an optimized
    patch and repair analysis. Inspired by code review, in which one or more developers
    check a program to ensure software quality, we request FixerPro to evaluate the
    performance and potential vulnerability of the plausible fix generated by Fixer.
    Then, FixerPro provides suggestions for refactoring the patch to optimize simplicity
    and maintainability. If Fixer fails, FixerPro generates a new patch while analyzing
    the failing reasons.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: FixerPro。FixerPro 通过生成优化的修复和修复分析来扩展和补充 Fixer。它的灵感来源于代码审查，多个开发人员检查程序以确保软件质量，我们请求
    FixerPro 评估 Fixer 生成的可能修复的性能和潜在漏洞。然后，FixerPro 提供关于重构补丁的建议，以优化简单性和可维护性。如果 Fixer
    失败，FixerPro 会生成一个新的补丁，并分析失败的原因。
- en: 3.2 External Interactions
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2 外部交互
- en: Plausibility Feedback. We conduct repairs by modifying the buggy code rather
    than directly applying the generated patches because they usually make mistakes
    in indices of code lines, as LLMs often struggle with counting, and the patch
    may be generated based on a sliced segment rather than the original code, causing
    changes in the indices of code lines. Our modification is rule-based by matching
    the invariant context between the patch and the buggy code. Afterward, we compile
    and run tests on the fixed program. The patch will be sent to developers for manual
    correctness verification if passing all test cases. The results of plausibility
    testing are returned to FixAgent as feedback for further processing, such as initializing
    a higher level of repair or conducting self-reflection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可信度反馈。我们通过修改有缺陷的代码来进行修复，而不是直接应用生成的补丁，因为这些补丁通常会在代码行的索引上出错，因为 LLM 在计数时经常出现问题，并且补丁可能是基于切片的代码段而不是原始代码生成的，从而导致代码行索引发生变化。我们的修改是基于规则的，通过匹配补丁和有缺陷代码之间的不变上下文来进行。之后，我们会编译并运行修复后的程序的测试。如果所有测试用例都通过，补丁将发送给开发人员进行手动正确性验证。可信度测试的结果会作为反馈返回给
    FixAgent，供进一步处理，比如初始化更高层次的修复或进行自我反思。
- en: Tool Usage. The toolbox of FixAgent currently contains static analysis tools,
    dynamic analysis tools, and a search engine optimized for LLMs and RAG. Static
    analysis provides static errors and warnings, as well as Abstract Syntax Tree
    (AST), a tree representation of the abstract syntactic structure of source code.
    We mainly consider the coverage of failing test cases in dynamic analysis since
    it is commonly assumed that code statements not executed during testing are less
    likely to cause the failures Kochhar et al. ([2016](https://arxiv.org/html/2404.17153v2#bib.bib20)).
    Note that the results of tool invocations will be stored for the requests of downstream
    agents to avoid duplicated invocations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 工具使用。FixAgent 的工具箱目前包含静态分析工具、动态分析工具以及针对 LLMs 和 RAG 优化的搜索引擎。静态分析提供静态错误和警告，以及抽象语法树（AST），即源代码抽象语法结构的树形表示。在动态分析中，我们主要考虑失败测试用例的覆盖率，因为通常认为在测试过程中未执行的代码语句更不可能导致失败，Kochhar
    等人（[2016](https://arxiv.org/html/2404.17153v2#bib.bib20)）也有相关假设。请注意，工具调用的结果将存储，以便下游代理请求时避免重复调用。
- en: 3.3 Hierarchical Coordination
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3 层次协调
- en: Our main principle of coordination is that problems of different complexities
    warrant cognitive activities of different intensities. That is, upon the failure
    of a straightforward solution, a higher-level goal will be triggered with more
    information and thinking. Following Hale and Haworth’s cognitive debugging model,
    we define three workflows for the three levels of repair, respectively.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们协调的主要原则是，不同复杂度的问题需要不同强度的认知活动。也就是说，当简单的解决方案失败时，系统会触发一个更高层次的目标，并提供更多的信息和思考。根据
    Hale 和 Haworth 的认知调试模型，我们分别为三个层次的修复定义了三种工作流程。
- en: 'The first level identifies and fixes obvious logic errors in code, so we assume
    that agents can easily fix the bug. Thus, L1 only contains Locator and Fixer with
    a simple communication flow, where Fixer generates a patch based on the fault
    localization done by Locator. If the fix is not plausible, then L2 is triggered,
    assuming that the fix can be achieved by only inspecting a single file, which
    is often applied in previous FL and APR studies (Soremekun et al., [2023](https://arxiv.org/html/2404.17153v2#bib.bib41)).
    L2 involves five agents: Slicer, Summarizer, Locator, Fixer, and FixerPro. Slicer
    isolates a suspicious segment, and Summarizer generates a code summary simultaneously,
    both from the bug-located file. Afterward, Locator, Fixer, and FixerPro work in
    sequence based on the suspicious segment, and all have access to the code summary.
    If it still fails, we turn to L3, which believes that the bug is very complex,
    so repairing it requires understanding cross-file dependencies and external information.
    L3 activates all the seven agents. First, Helper and RepoFocus are initialized
    at the same time, and Helper provides references for all other agents. Then, Summarizer
    runs multiple times following the file list identified by RepoFocus. These code
    summaries are shared by the remaining four agents, which work one after another
    subsequently with the same workflow as L2. Figure [5](https://arxiv.org/html/2404.17153v2#S3.F5
    "Figure 5 ‣ 3.1 Profiles of Agents ‣ 3 FixAgent ‣ FixAgent: Hierarchical Multi-Agent
    Framework for Unified Software Debugging") presents an example conversation among
    agents on L3.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '第一级识别并修复代码中的明显逻辑错误，因此我们假设代理可以轻松修复该漏洞。因此，L1 仅包含定位器（Locator）和修复器（Fixer），其通信流程简单，其中修复器根据定位器完成的故障定位生成修复补丁。如果修复不可行，则触发
    L2，假设修复仅通过检查单个文件即可完成，这在以往的故障定位（FL）和自动修复（APR）研究中经常应用（Soremekun 等人，[2023](https://arxiv.org/html/2404.17153v2#bib.bib41)）。L2
    涉及五个代理：切片器（Slicer）、总结器（Summarizer）、定位器（Locator）、修复器（Fixer）和修复器专业版（FixerPro）。切片器从故障定位的文件中隔离出可疑的代码段，总结器同时生成代码摘要。然后，定位器、修复器和修复器专业版依次基于可疑代码段工作，且都可以访问代码摘要。如果修复仍然失败，则转向
    L3，L3 假设该漏洞非常复杂，因此修复它需要理解跨文件的依赖关系和外部信息。L3 启动所有七个代理。首先，助手（Helper）和仓库聚焦（RepoFocus）同时初始化，助手为其他所有代理提供参考。接下来，总结器根据仓库聚焦识别的文件列表多次运行。这些代码摘要由剩余的四个代理共享，随后这些代理按照
    L2 的相同工作流程依次工作。图[5](https://arxiv.org/html/2404.17153v2#S3.F5 "Figure 5 ‣ 3.1
    Profiles of Agents ‣ 3 FixAgent ‣ FixAgent: Hierarchical Multi-Agent Framework
    for Unified Software Debugging")展示了 L3 中代理之间的一个对话示例。'
- en: Upon no plausible patch, FixAgent gradually requests agents on L3 to reflect
    and refine its answer based on the plausibility feedback in a reversed order,
    as downstream agents are more error-prone as errors may accumulate during the
    debugging process. Specifically, we first ask FixerPro to refine its response.
    If the fix fails again, we then request Fixer, leading to input changes of FixerPro,
    so it is re-sampled the second time. Eventually, plausible patches are returned
    to developers for manual verification. If no plausible patch is produced, FixAgent
    will display the analysis report written by FixerPro and take another run until
    reaching a resource threshold.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有合理修复的情况下，FixAgent 会逐步请求 L3 中的代理根据合理性反馈以反向顺序反思并完善其答案，因为下游代理更容易出错，因为错误可能在调试过程中积累。具体来说，我们首先请求修复器专业版（FixerPro）来完善其响应。如果修复仍然失败，我们接着请求修复器（Fixer），这会导致修复器专业版的输入发生变化，因此它会被重新采样。最终，合理的修复补丁会返回给开发人员进行人工验证。如果未生成合理的修复补丁，FixAgent
    将展示由修复器专业版撰写的分析报告，并再次运行，直到达到资源阈值为止。
- en: 'Table 1: Comparison with baselines. #Corr and #Plau represent the number of
    bugs correctly and plausibly patched, respectively. The green cells indicate the
    best results. The blue cells indicate the results are obtained from sampled data,
    while other results are obtained on the whole dataset.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '表 1：与基准的比较。#Corr 和 #Plau 分别表示正确修复和合理修复的漏洞数量。绿色单元格表示最佳结果。蓝色单元格表示这些结果来自采样数据，而其他结果则基于整个数据集获得。'
- en: 'Tools Sampling Times Defects4J-Java Codeflaws-C QuixBugs-Java QuixBugs-Python
    Note #Corr #Plau #Corr #Plau #Corr #Plau #Corr #Plau Angelix 1,000 - - 318 591
    - - - - Realistic FL Prophet 1,000 - - 310 839 - - - - SPR 1,000 - - 283 783 -
    - - - CVC4 - - - 15^† 91^† - - - - Semfix 1,000 25 68 38^† 56^† - - - - Recoder
    100 72 140 - - 17 17 - - GenProg 1000 5 20 255-369 1423 1 4 - - Perfect FL CoCoNuT
    20,000 44^⋆ 85^⋆ 423 716 13 20 19 21 CURE - 57^⋆ 104^⋆ - - 26 35 - - RewardRepair
    200 90 75 - - 20 - - - Tbar 500 77 121 - - - - - - AlphaRepair 5,000 110 159 -
    - 28 30 27 32 Repilot 5,000 116 - - - - - - - ChatRepair 100-200 157 - - - 40
    40 40 40 CodeLlama-34b 20 24 41 91(%)^‡ 1,488 25 28 33 33 Perfect FL LLaMA2-70b
    39 78 91(%)^‡ 1,576 25 28 33 33 DeepSeekCoder 57 82 93(%)^‡ 1,937 30 34 25 38
    gemini-1.5-flash 19 36 86(%)^‡ 1,291 29 32 29 35 gpt-3.5-turbo-ca 45 71 94(%)^‡
    2,343 33 34 34 36 claude-3.5-sonnet 70 116 95(%)^‡ 2,624 36 37 40 40 gpt-4o 72
    119 93(%)^‡ 2,549 35 36 39 39 FixAgent-Lite 5 - - 95(%)^‡ 3,130 40 40 40 40 FixAgent
    20 197 286 - - - - - -'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: "工具\t抽样次数\tDefects4J-Java\tCodeflaws-C\tQuixBugs-Java\tQuixBugs-Python\t备注\t\
    #Corr\t#Plau\t#Corr\t#Plau\t#Corr\t#Plau\t#Corr\t#Plau"
- en: $\star$
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: $\star$
- en: Only the result on Defects4J 1.2 is available.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅提供Defects4J 1.2的结果。
- en: $\dagger$
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: $\dagger$
- en: The result is obtained from 665 sampled bugs.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果来自665个抽样缺陷。
- en: $\ddagger$
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: $\ddagger$
- en: We randomly select 100 plausible patches to check their correctness because
    of the huge number of plausible patches.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们随机选择100个可能的修复补丁来检查其正确性，因为可能的修复补丁数量庞大。
- en: 4 Experiments
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4 实验
- en: 4.1 Experimental Setup
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1 实验设置
- en: 'Benchmarks. We evaluate FixAgent on four benchmarks featuring bug-fix pairs,
    including competition programs (Codeflaws Tan et al., [2017](https://arxiv.org/html/2404.17153v2#bib.bib42),
    QuixBugs Lin et al., [2017](https://arxiv.org/html/2404.17153v2#bib.bib26), ConDefects Wu
    et al., [2024](https://arxiv.org/html/2404.17153v2#bib.bib50)) and real-world
    projects (Defects4J Just et al., [2014](https://arxiv.org/html/2404.17153v2#bib.bib19)).
    Codeflaws contains 3902 faulty C programs. QuixBugs includes 40 faulty programs
    available in both Java and Python. ConDefects recently collected to address data
    leakage concerns in LLMs, consists of 1,254 Java and 1,625 Python faulty programs.
    Defects4J, a widely used benchmark from 15 real-world Java projects, features
    bugs across two versions: version 1.2 with 391 active bugs and version 2.0 adding
    an additional 415 active bugs, totaling 806\. We will report the total number
    of fixes across these versions.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试。我们在四个基准上评估FixAgent，这些基准包含修复对，包括竞争程序（Codeflaws Tan等人，[2017](https://arxiv.org/html/2404.17153v2#bib.bib42)，QuixBugs
    Lin等人，[2017](https://arxiv.org/html/2404.17153v2#bib.bib26)，ConDefects Wu等人，[2024](https://arxiv.org/html/2404.17153v2#bib.bib50)）和真实世界项目（Defects4J
    Just等人，[2014](https://arxiv.org/html/2404.17153v2#bib.bib19)）。Codeflaws包含3902个有缺陷的C程序。QuixBugs包括40个有缺陷的程序，分别以Java和Python提供。ConDefects最近收集，旨在解决LLMs中的数据泄露问题，包含1254个Java程序和1625个Python程序。Defects4J是一个广泛使用的基准，来自15个真实世界Java项目，涵盖两个版本的缺陷：版本1.2有391个活跃缺陷，版本2.0增加了415个活跃缺陷，总共806个缺陷。我们将报告这些版本的修复总数。
- en: 'Baselines. We compare FixAgent against 14 APR baselines, including:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 基准。我们将FixAgent与14个APR基准进行比较，包括：
- en: •
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: 'Traditional: Angelix (Mechtaev et al., [2016](https://arxiv.org/html/2404.17153v2#bib.bib32)),
    Prophet (Long, [2018](https://arxiv.org/html/2404.17153v2#bib.bib28)), SPR (Long
    and Rinard, [2015](https://arxiv.org/html/2404.17153v2#bib.bib29)), and CVC4 (Reynolds
    et al., [2015](https://arxiv.org/html/2404.17153v2#bib.bib38)).'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 传统方法：Angelix (Mechtaev等人，[2016](https://arxiv.org/html/2404.17153v2#bib.bib32))，Prophet (Long，[2018](https://arxiv.org/html/2404.17153v2#bib.bib28))，SPR (Long和Rinard，[2015](https://arxiv.org/html/2404.17153v2#bib.bib29))，以及CVC4 (Reynolds等人，[2015](https://arxiv.org/html/2404.17153v2#bib.bib38))。
- en: •
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: 'Genetic programming-based: Semfix (Nguyen et al., [2013](https://arxiv.org/html/2404.17153v2#bib.bib34))
    and GenProg (Goues et al., [2012](https://arxiv.org/html/2404.17153v2#bib.bib9);
    Weimer et al., [2009a](https://arxiv.org/html/2404.17153v2#bib.bib48)).'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基于遗传编程的方法：Semfix (Nguyen等人，[2013](https://arxiv.org/html/2404.17153v2#bib.bib34))和GenProg (Goues等人，[2012](https://arxiv.org/html/2404.17153v2#bib.bib9);
    Weimer等人，[2009a](https://arxiv.org/html/2404.17153v2#bib.bib48))。
- en: •
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: 'NMT-based: CoCoNuT (Lutellier et al., [2020](https://arxiv.org/html/2404.17153v2#bib.bib31)),
    CURE (Jiang et al., [2021](https://arxiv.org/html/2404.17153v2#bib.bib18)), and
    RewardRepair (Ye et al., [2022](https://arxiv.org/html/2404.17153v2#bib.bib57)).'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基于NMT的：CoCoNuT (Lutellier等，[2020](https://arxiv.org/html/2404.17153v2#bib.bib31))，CURE (Jiang等，[2021](https://arxiv.org/html/2404.17153v2#bib.bib18))，和RewardRepair (Ye等，[2022](https://arxiv.org/html/2404.17153v2#bib.bib57))。
- en: •
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: 'Domain knowledge-driven: Tbar (Liu et al., [2019](https://arxiv.org/html/2404.17153v2#bib.bib27))
    and Recoder (Zhu et al., [2021](https://arxiv.org/html/2404.17153v2#bib.bib60)).'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基于领域知识驱动的：Tbar (Liu等，[2019](https://arxiv.org/html/2404.17153v2#bib.bib27))
    和Recoder (Zhu等，[2021](https://arxiv.org/html/2404.17153v2#bib.bib60))。
- en: •
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: 'LLM-based (SoTA): AlphaRepair (Xia and Zhang, [2022](https://arxiv.org/html/2404.17153v2#bib.bib52)),
    Repilot (Wei et al., [2023](https://arxiv.org/html/2404.17153v2#bib.bib47)), and
    ChatRepair (Xia and Zhang, [2024](https://arxiv.org/html/2404.17153v2#bib.bib53)).'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基于LLM的（SoTA）：AlphaRepair (Xia和Zhang，[2022](https://arxiv.org/html/2404.17153v2#bib.bib52))，Repilot (Wei等，[2023](https://arxiv.org/html/2404.17153v2#bib.bib47))，和ChatRepair (Xia和Zhang，[2024](https://arxiv.org/html/2404.17153v2#bib.bib53))。
- en: Note that different APR baselines adopted diverse prior fault locations. We
    use realistic to represent traditional FL and perfect to denote ground-truth FL.
    We report the results provided in their original papers and follow-up survey Le
    et al. ([2018](https://arxiv.org/html/2404.17153v2#bib.bib21)); Ye et al. ([2021](https://arxiv.org/html/2404.17153v2#bib.bib56));
    Xia et al. ([2023](https://arxiv.org/html/2404.17153v2#bib.bib51)), following
    previous studies Xia et al. ([2023](https://arxiv.org/html/2404.17153v2#bib.bib51));
    Xia and Zhang ([2024](https://arxiv.org/html/2404.17153v2#bib.bib53)); Lutellier
    et al. ([2020](https://arxiv.org/html/2404.17153v2#bib.bib31)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不同的APR基准采用了不同的先前故障位置。我们使用realistic表示传统的FL，使用perfect表示真实情况的FL。我们报告了它们原始论文中的结果和后续调查 Le等（[2018](https://arxiv.org/html/2404.17153v2#bib.bib21)）；Ye等（[2021](https://arxiv.org/html/2404.17153v2#bib.bib56)）；Xia等（[2023](https://arxiv.org/html/2404.17153v2#bib.bib51)），并遵循了之前的研究 Xia等（[2023](https://arxiv.org/html/2404.17153v2#bib.bib51)）；Xia和Zhang（[2024](https://arxiv.org/html/2404.17153v2#bib.bib53)）；Lutellier等（[2020](https://arxiv.org/html/2404.17153v2#bib.bib31)）。
- en: LLM Backbones. We apply FixAgent to seven LLMs, including four general-purpose
    models (gemini-1.5-flash Anil et al., [2023](https://arxiv.org/html/2404.17153v2#bib.bib4),
    gpt-3.5-turbo-ca OpenAI, [2023a](https://arxiv.org/html/2404.17153v2#bib.bib35),
    gpt-4o OpenAI, [2023b](https://arxiv.org/html/2404.17153v2#bib.bib36), and claude-3.5-sonnet Anthropic,
    [2024](https://arxiv.org/html/2404.17153v2#bib.bib5)) and three open-source code
    LLMs (DeepSeekCoder Guo et al., [2024](https://arxiv.org/html/2404.17153v2#bib.bib10),
    CodeLlama-34b Rozière et al., [2023](https://arxiv.org/html/2404.17153v2#bib.bib39),
    LLaMA2-70b Touvron et al., [2023](https://arxiv.org/html/2404.17153v2#bib.bib45)).
    Naturally, these LLMs also serve as baselines for comparison, where we apply the
    original chain-of-thought (CoT) prompting method Wei et al. ([2022](https://arxiv.org/html/2404.17153v2#bib.bib46)).
    The default backbone of FixAgent is gpt-4o.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: LLM骨干网。我们将FixAgent应用于七个LLM，包括四个通用模型（gemini-1.5-flash Anil等，[2023](https://arxiv.org/html/2404.17153v2#bib.bib4)，gpt-3.5-turbo-ca OpenAI，[2023a](https://arxiv.org/html/2404.17153v2#bib.bib35)，gpt-4o OpenAI，[2023b](https://arxiv.org/html/2404.17153v2#bib.bib36)，以及claude-3.5-sonnet Anthropic，[2024](https://arxiv.org/html/2404.17153v2#bib.bib5)）和三个开源代码LLM（DeepSeekCoder Guo等，[2024](https://arxiv.org/html/2404.17153v2#bib.bib10)，CodeLlama-34b Rozière等，[2023](https://arxiv.org/html/2404.17153v2#bib.bib39)，LLaMA2-70b Touvron等，[2023](https://arxiv.org/html/2404.17153v2#bib.bib45)）。这些LLM自然也作为基准进行比较，我们在其中应用了原始的思维链（CoT）提示方法 Wei等（[2022](https://arxiv.org/html/2404.17153v2#bib.bib46)）。FixAgent的默认骨干网是gpt-4o。
- en: Metrics. We utilize the APR metrics, specifically focusing on the number of
    bugs that are plausibly or correctly fixed. Given the extensive size of ConDefects,
    we randomize samples from plausible fixes to verify their correctness. Thus, we
    also employ the metric known as correctness rate—defined as the ratio of correct
    fixes to plausibly fixed bugs—to assess the effectiveness of FixAgent.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 评估指标。我们使用APR指标，特别关注那些能够合理或正确修复的bug数量。考虑到ConDefects的庞大规模，我们从合理修复中随机抽取样本以验证其正确性。因此，我们还采用了正确率这一指标——它定义为正确修复与合理修复bug的比率——来评估FixAgent的有效性。
- en: Implementation. For single-file competition programs, only Locator, Fixer, and
    FixerPro on L2 and L1 need to be initialized, named as FixAgent-Lite. The maximum
    number of attempts is set to 5 per bug for Lite and 20 for the full version. Previous
    studies, however, typically sample hundreds to thousands of times. For instance,
    CoCoNuT samples up to 50,000 patches per bug Lutellier et al. ([2020](https://arxiv.org/html/2404.17153v2#bib.bib31)),
    while ChatRepair samples 100-200 times Xia and Zhang ([2024](https://arxiv.org/html/2404.17153v2#bib.bib53)).
    Our approach is significantly more cost-effective than baselines. Furthermore,
    we alter the default web search engine (Tavily [Tavily,](https://arxiv.org/html/2404.17153v2#bib.bib43)
    ) to a local one during evaluation to prevent retrieving ground-truth solutions
    online. The local database consists of the training dataset of CoCoNut (Lutellier
    et al., [2020](https://arxiv.org/html/2404.17153v2#bib.bib31)) with JavaScript
    programs removed. Since CoCoNuT was also evaluated on Defects4J and ConDefects,
    the risk of data leakage is minimal. The static and dynamic analysis is supported
    by our written scripts and open-source plugins ([SonarQube,](https://arxiv.org/html/2404.17153v2#bib.bib40)
    and [GZoltar,](https://arxiv.org/html/2404.17153v2#bib.bib11) ).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实现。对于单文件竞赛程序，只需初始化 L2 和 L1 上的 Locator、Fixer 和 FixerPro，命名为 FixAgent-Lite。Lite
    版本每个 bug 的最大尝试次数设为 5 次，完整版设为 20 次。然而，先前的研究通常会进行数百到数千次的采样。例如，CoCoNuT 每个 bug 最多采样
    50,000 次（Lutellier 等人，[2020](https://arxiv.org/html/2404.17153v2#bib.bib31)），而
    ChatRepair 每次采样 100-200 次（Xia 和 Zhang，[2024](https://arxiv.org/html/2404.17153v2#bib.bib53)）。与基准相比，我们的方法显著更具成本效益。此外，为了防止在线获取真实解答，我们在评估过程中将默认的网络搜索引擎（Tavily
    [Tavily,](https://arxiv.org/html/2404.17153v2#bib.bib43)）更换为本地搜索引擎。本地数据库包含 CoCoNuT
    的训练数据集（Lutellier 等人，[2020](https://arxiv.org/html/2404.17153v2#bib.bib31)），其中去除了
    JavaScript 程序。由于 CoCoNuT 也在 Defects4J 和 ConDefects 上进行了评估，因此数据泄漏的风险较小。静态和动态分析由我们的编写脚本和开源插件支持（[SonarQube,](https://arxiv.org/html/2404.17153v2#bib.bib40)
    和 [GZoltar,](https://arxiv.org/html/2404.17153v2#bib.bib11)）。
- en: 4.2 Comparison with baselines
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2 与基准的比较
- en: 'This section evaluates the debugging capabilities of our framework, FixAgent.
    The results are shown in Table [1](https://arxiv.org/html/2404.17153v2#S3.T1 "Table
    1 ‣ 3.3 Hierarchical Coordination ‣ 3 FixAgent ‣ FixAgent: Hierarchical Multi-Agent
    Framework for Unified Software Debugging"). We do not use ConDefects herein because
    it is a recently released dataset, and few approaches have been evaluated on it.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '本节评估了我们框架 FixAgent 的调试能力。结果显示在表格 [1](https://arxiv.org/html/2404.17153v2#S3.T1
    "Table 1 ‣ 3.3 Hierarchical Coordination ‣ 3 FixAgent ‣ FixAgent: Hierarchical
    Multi-Agent Framework for Unified Software Debugging") 中。我们在此不使用 ConDefects 数据集，因为它是一个最近发布的数据集，且很少有方法在其上进行评估。'
- en: Competition Programs. FixAgent plausibly fixes 3130 out of 3982 bugs on Codeflaws,
    producing 2.2x plausible fixes as the best APR method, GenProg. It has a correctness
    rate of 95%, i.e., FixAgent correctly repairs 95 bugs out of 100 sampled plausible
    patches, improving the correctness rate by 60.81% compared to that of CoCoNuT,
    which correctly fixes the most bugs among APR approaches. FixAgent surpasses the
    best-performing LLM baseline, claude-3.5-sonnet, by $\sim$19.28% with the same
    correctness rate. Moreover, FixAgent successfully fixes all bugs in QuixBugs across
    two programming languages, achieving the same SoTA as ChatRepair.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 竞赛程序。FixAgent 在 Codeflaws 上合理地修复了 3982 个 bug 中的 3130 个，生成了比最好的 APR 方法 GenProg
    多 2.2 倍的合理修复。其正确率为 95%，即 FixAgent 正确修复了 100 个样本中 95 个合理修复，相比 CoCoNuT 提高了 60.81%，CoCoNuT
    是 APR 方法中修复 bug 最多的。FixAgent 以相同的正确率超过了表现最好的 LLM 基准模型 claude-3.5-sonnet，超出约 19.28%。此外，FixAgent
    成功修复了 QuixBugs 中所有 bug，涵盖两种编程语言，达到了与 ChatRepair 相同的 SoTA。
- en: 'Real-World Software. On Defects4J, FixAgent correctly fixes 197 bugs while
    plausibly solving 286 bugs, outperforming the SoTA, ChatRepair, by $\sim$25.48%.
    Moreover, FixAgent correctly fixes 42 unique bugs that the top four baselines
    have never fixed. Figure [6](https://arxiv.org/html/2404.17153v2#S4.F6 "Figure
    6 ‣ 4.2 Comparison with baselines ‣ 4 Experiments ‣ FixAgent: Hierarchical Multi-Agent
    Framework for Unified Software Debugging") shows the Venn diagram of the bugs
    fixed by the top four baselines and FixAgent on Defects4J. We see that FixAgent
    correctly fixes 42 unique bugs that these strong baselines have not addressed.
    We show an example of the unique fixes in [A.1](https://arxiv.org/html/2404.17153v2#A1.SS1
    "A.1 Unique Fix Example ‣ Appendix A Appendix ‣ FixAgent: Hierarchical Multi-Agent
    Framework for Unified Software Debugging").'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '现实世界软件。在Defects4J上，FixAgent成功修复了197个Bug，同时合理地解决了286个Bug，超越了当前最先进的技术ChatRepair，提升了约$\sim$25.48%。此外，FixAgent成功修复了42个独特的Bug，这些Bug是前四个基准模型未曾修复的。图[6](https://arxiv.org/html/2404.17153v2#S4.F6
    "Figure 6 ‣ 4.2 Comparison with baselines ‣ 4 Experiments ‣ FixAgent: Hierarchical
    Multi-Agent Framework for Unified Software Debugging")展示了FixAgent和前四个基准模型在Defects4J上修复的Bug的韦恩图。我们看到FixAgent成功修复了42个这些强基准模型未能解决的独特Bug。我们在[A.1](https://arxiv.org/html/2404.17153v2#A1.SS1
    "A.1 Unique Fix Example ‣ Appendix A Appendix ‣ FixAgent: Hierarchical Multi-Agent
    Framework for Unified Software Debugging")中展示了这些独特修复的示例。'
- en: '![Refer to caption](img/8d2b864484133d490ab6ace2b0536370.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![请参见标题](img/8d2b864484133d490ab6ace2b0536370.png)'
- en: 'Figure 6: Bug fix Venn diagram on Defects4J.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：Defects4J上的Bug修复韦恩图。
- en: Overall, LLM-involved baselines perform reasonably well. On top, FixAgent significantly
    enhances base LLMs on all benchmarks, especially on Defects4J. This is because
    direct prompting LLMs struggles with too long contexts and complex reasoning.
    We split debugging into several cognitive steps and introduce external tools and
    knowledge, thus boosting the capabilities of LLMs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，涉及LLM的基准模型表现相当不错。特别是FixAgent在所有基准测试中显著增强了基础LLM的性能，尤其是在Defects4J上。这是因为直接提示LLM在处理过长的上下文和复杂推理时表现不佳。我们将调试过程分解为几个认知步骤，并引入外部工具和知识，从而提升了LLM的能力。
- en: '<svg class="ltx_picture" height="73.07" id="S4.SS2.p5.pic1" overflow="visible"
    version="1.1" width="600"><g fill="#000000" stroke="#000000" stroke-width="0.4pt"
    transform="translate(0,73.07) matrix(1 0 0 -1 0 0)"><g fill-opacity="1.0" transform="matrix(1.0
    0.0 0.0 1.0 21.65 13.78)"><foreignobject color="#000000" height="45.51" overflow="visible"
    transform="matrix(1 0 0 -1 0 16.6)" width="556.69">Takeaway: FixAgent fixes 197
    bugs on Defects4J, a 25.48% improvement over the leading baseline. Its lite version
    fixes all bugs on QuixBugs and achieves 19.28% more plausible fixes on ConDefects
    with the highest correctness rate.</foreignobject></g></g></svg>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '<svg class="ltx_picture" height="73.07" id="S4.SS2.p5.pic1" overflow="visible"
    version="1.1" width="600"><g fill="#000000" stroke="#000000" stroke-width="0.4pt"
    transform="translate(0,73.07) matrix(1 0 0 -1 0 0)"><g fill-opacity="1.0" transform="matrix(1.0
    0.0 0.0 1.0 21.65 13.78)"><foreignobject color="#000000" height="45.51" overflow="visible"
    transform="matrix(1 0 0 -1 0 16.6)" width="556.69">Takeaway: FixAgent fixes 197
    bugs on Defects4J, a 25.48% improvement over the leading baseline. Its lite version
    fixes all bugs on QuixBugs and achieves 19.28% more plausible fixes on ConDefects
    with the highest correctness rate.</foreignobject></g></g></svg>'
- en: 'Table 2: Ablation study on agents. #Plau represent the number of plausibly
    fixed bugs. The ✓ indicates the addition of a specific agent, and ✗ denotes its
    absence. Expense denotes the average expense running once for a bug.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表2：关于代理的消融研究。#Plau表示合理修复的Bug数量。✓表示添加了特定的代理，✗表示缺少该代理。Expense表示每次运行Bug修复的平均费用。
- en: '| Helper | RepoFocus | Summarizer | Slicer | Locator | Fixer | FixerPro | #Plau
    | Expense ($) | Level |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| Helper | RepoFocus | Summarizer | Slicer | Locator | Fixer | FixerPro | #Plau
    | Expense ($) | Level |'
- en: '| ✗ | ✗ | ✗ | ✗ | ✗ | ✓ | ✗ | 72 | 0.030 | L1 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| ✗ | ✗ | ✗ | ✗ | ✗ | ✓ | ✗ | 72 | 0.030 | L1 |'
- en: '| ✗ | ✗ | ✗ | ✗ | ✓ | ✓ | ✗ | 140 | 0.048 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| ✗ | ✗ | ✗ | ✗ | ✓ | ✓ | ✗ | 140 | 0.048 |'
- en: '| ✗ | ✗ | ✗ | ✗ | ✓ | ✓ | ✓ | 192 | 0.116 | L2 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| ✗ | ✗ | ✗ | ✗ | ✓ | ✓ | ✓ | 192 | 0.116 | L2 |'
- en: '| ✗ | ✗ | ✗ | ✓ | ✓ | ✓ | ✓ | 224 | 0.225 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| ✗ | ✗ | ✗ | ✓ | ✓ | ✓ | ✓ | 224 | 0.225 |'
- en: '| ✗ | ✗ | ✓ | ✓ | ✓ | ✓ | ✓ | 238 | 0.317 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| ✗ | ✗ | ✓ | ✓ | ✓ | ✓ | ✓ | 238 | 0.317 |'
- en: '| ✗ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | 245 | 0.364 | L3 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| ✗ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | 245 | 0.364 | L3 |'
- en: '| ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | 291 | 0.410 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | 291 | 0.410 |'
- en: 4.3 Performance on Different LLMs
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3 在不同LLM上的性能
- en: 'To verify the robustness of FixAgent across various LLMs, we compare FixAgent-Lite
    with its seven LLM backbones, evaluated on 600 randomly sampled bugs from ConDefects
    (300 for each programming language). Since manually checking the patches is time-consuming,
    we only present the number of plausible fixes. Table [3](https://arxiv.org/html/2404.17153v2#S4.T3
    "Table 3 ‣ 4.3 Performance on Different LLMs ‣ 4 Experiments ‣ FixAgent: Hierarchical
    Multi-Agent Framework for Unified Software Debugging") displays the performance
    gains of FixAgent-Lite (UD-L) over its backbone with CoT prompting. For simplicity,
    we only report the number of plausible fixes.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '为了验证FixAgent在不同大型语言模型（LLM）上的稳健性，我们将FixAgent-Lite与其七个LLM骨干模型进行比较，评估了来自ConDefects的600个随机抽取的错误（每种编程语言300个）。由于手动检查补丁耗时较长，我们只展示了可行修复的数量。表[3](https://arxiv.org/html/2404.17153v2#S4.T3
    "Table 3 ‣ 4.3 Performance on Different LLMs ‣ 4 Experiments ‣ FixAgent: Hierarchical
    Multi-Agent Framework for Unified Software Debugging")展示了FixAgent-Lite（UD-L）在使用CoT提示时，相较于其骨干模型的性能提升。为了简化起见，我们只报告了可行修复的数量。'
- en: 'Table 3: Performance gains of FixAgent-Lite over different LLMs on 600 samples
    from ConDefects.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表3：FixAgent-Lite在来自ConDefects的600个样本上，相较于不同LLM的性能提升。
- en: LLMs ConDefects-Java ConDefects-Python CoT UD-L Gain $\uparrow$ CoT UD-L Gain
    $\uparrow$ CodeLlama-34b 87 113 29.89% 69 86 24.64% LLaMA2-70b 108 147 36.11%
    91 133 46.15% DeepSeekCoder 130 198 52.31% 125 178 42.40% gemini-1.5-flash 62
    89 43.55% 63 82 30.16% gpt-3.5-turbo-ca 155 191 23.23% 127 174 37.01% claude-3.5-sonnet
    213 259 21.60% 186 227 22.04% gpt-4o 211 262 24.17% 179 225 25.70%
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: LLMs ConDefects-Java ConDefects-Python CoT UD-L 增益 $\uparrow$ CoT UD-L 增益 $\uparrow$
    CodeLlama-34b 87 113 29.89% 69 86 24.64% LLaMA2-70b 108 147 36.11% 91 133 46.15%
    DeepSeekCoder 130 198 52.31% 125 178 42.40% gemini-1.5-flash 62 89 43.55% 63 82
    30.16% gpt-3.5-turbo-ca 155 191 23.23% 127 174 37.01% claude-3.5-sonnet 213 259
    21.60% 186 227 22.04% gpt-4o 211 262 24.17% 179 225 25.70%
- en: The results indicate that FixAgent can consistently enhance its backbone LLM
    by 21.60%-52.31%. Notably, UD-L with LLaMA2 achieves 280 plausible fixes, closely
    rivaling the performance of gpt-3.5-turbo-ca (282). Plus, UD-L with DeepSeekCoder
    plausibly fixes similar bugs (376) as gpt-4o does (390). The results indicate
    that FixAgent brings the gap between open-source code LLMs and proprietary systems
    like gpt-4o in debugging. Furthermore, though FixAgent can make improvements across
    varying LLMs, its overall performance is strongly related to the coding ability
    of its backbone LLM.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，FixAgent 可以始终将其主干 LLM 提升 21.60%-52.31%。特别地，LLaMA2 的 UD-L 实现了 280 个可行修复，几乎与
    gpt-3.5-turbo-ca（282 个）持平。此外，DeepSeekCoder 的 UD-L 修复了与 gpt-4o 类似的错误（376 个与 390
    个）。这些结果表明，FixAgent 缩小了开源代码 LLM 和专有系统（如 gpt-4o）在调试方面的差距。此外，尽管 FixAgent 可以在不同的 LLM
    上带来改进，但其整体性能与其主干 LLM 的编码能力密切相关。
- en: 4.4 Ablation Study
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4 消融研究
- en: 4.4.1 Impact of Different Agents
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1 不同代理的影响
- en: 'To understand the impact of different agents on the effectiveness of FixAgent,
    we exclude certain agents across Defects4J, as we trigger all agents on it. We
    also report the number of plausible fixes herein. As indicated by Table [2](https://arxiv.org/html/2404.17153v2#S4.T2
    "Table 2 ‣ 4.2 Comparison with baselines ‣ 4 Experiments ‣ FixAgent: Hierarchical
    Multi-Agent Framework for Unified Software Debugging"), the addition of agents
    different from just Fixer consistently improves the number of plausible fixes.
    While more agents slightly increase the expenses, the overall performance improves
    noticeably, demonstrating the effectiveness of the various agents and the importance
    of the divide-and-conquer idea. Since the higher level is only triggered when
    the lower level fails, higher levels naturally improve performance.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '为了理解不同代理对 FixAgent 效能的影响，我们在 Defects4J 中排除了一些代理，因为我们在其上触发了所有代理。我们还报告了这里的可行修复数量。如表[2](https://arxiv.org/html/2404.17153v2#S4.T2
    "Table 2 ‣ 4.2 Comparison with baselines ‣ 4 Experiments ‣ FixAgent: Hierarchical
    Multi-Agent Framework for Unified Software Debugging")所示，除了仅有 Fixer 的情况下，添加其他代理始终能提高可行修复的数量。尽管更多的代理会略微增加开销，但整体性能显著提升，证明了各类代理的有效性以及分而治之思想的重要性。由于较高层次的代理仅在较低层次的代理失败时触发，因此更高层次的代理自然会提升性能。'
- en: Plus, the performance gains of L2 to L1 are more pronounced than that of L3
    to L2 as expected, since L2 adds more agents to L1 with tool usage, while L3 only
    adds reference solutions and auxiliary cross-file information. We notice that
    Helper only increases 46 plausible fixes, indicating that the internet cannot
    always provide solutions, so domain-specific tools for debugging are highly desired.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，L2 相较于 L1 的性能提升比 L3 相较于 L2 的提升更为显著，这是因为 L2 在 L1 的基础上增加了更多使用工具的代理，而 L3 仅仅增加了参考解决方案和辅助的跨文件信息。我们注意到，Helper
    只增加了 46 个可行的修复，表明互联网并不总能提供解决方案，因此，针对调试的领域特定工具是非常需要的。
- en: 4.4.2 Impact of External Interactions
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2 外部交互的影响
- en: 'We also evaluate the impact of external interactions on Defects4J, including
    the feedback of testing results to FixerPro and toolbox usage. As shown in Table [4](https://arxiv.org/html/2404.17153v2#S4.T4
    "Table 4 ‣ 4.4.2 Impact of External Interactions ‣ 4.4 Ablation Study ‣ 4 Experiments
    ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging"),
    introducing external interactions leads to a significant improvement ranging from
    23 to 121 in the number of plausible fixes. This illustrates how our designed
    mechanism of environment interactions can contribute to high-quality debugging.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还评估了外部交互对 Defects4J 的影响，包括将测试结果反馈到 FixerPro 和工具箱的使用。如表[4](https://arxiv.org/html/2404.17153v2#S4.T4
    "Table 4 ‣ 4.4.2 Impact of External Interactions ‣ 4.4 Ablation Study ‣ 4 Experiments
    ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging")所示，引入外部交互显著提高了可行修复的数量，范围从
    23 到 121。这说明我们设计的环境交互机制有助于高质量的调试。'
- en: 'Table 4: Ablation study on external interactions.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4：外部交互的消融研究。
- en: 'Online Search Static Dynamic Testing #Plau ✗ ✓ ✓ ✓ 245 ✓ ✗ ✓ ✓ 268 ✓ ✓ ✗ ✓
    170 ✓ ✓ ✓ ✗ 244 ✓ ✓ ✓ ✓ 291'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '在线搜索 静态 动态 测试 #Plau ✗ ✓ ✓ ✓ 245 ✓ ✗ ✓ ✓ 268 ✓ ✓ ✗ ✓ 170 ✓ ✓ ✓ ✗ 244 ✓ ✓ ✓ ✓
    291'
- en: 5 Conclusion
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5 结论
- en: This paper presents FixAgent, the first end-to-end framework leveraging LLM-based
    multi-agent synergy to tackle unified software debugging. Our method employs a
    novel hierarchical coordination paradigm, inspired by a cognitive debugging model,
    to efficiently manage cognitive steps with minimal communication and dynamically
    adjust to bug complexity through its three-level architecture. Extensive experiments
    on four benchmarks demonstrate the superiority of our method over SoTA repair
    approaches and base LLMs. FixAgent fixes 1.25–2.56$\times$ bugs on a repo-level
    benchmark and fixes all bugs on QuixBugs. Its lite version achieves the most plausible
    fixes on the other two competition program benchmarks. Lastly, the effective implementation
    of Hale and Haworth’s cognitive model for debugging paves new pathways for research
    in advancing LLM-based multi-agent frameworks for tackling complex coding tasks.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本文介绍了FixAgent，这是第一个利用基于LLM的多代理协同的端到端框架，用于解决统一的软件调试问题。我们的方法采用了一种新颖的层次协调范式，灵感来源于认知调试模型，通过其三层架构高效地管理认知步骤，减少通信并动态调整以应对bug的复杂性。对四个基准的广泛实验表明，我们的方法在修复bug的效果上优于现有的修复方法和基础LLM。FixAgent在代码库级别的基准上修复了1.25-2.56$\times$的bug，并且在QuixBugs上修复了所有bug。其轻量版在另外两个竞赛程序基准上实现了最合理的修复。最后，Hale和Haworth的认知调试模型的有效实现为基于LLM的多代理框架在解决复杂编码任务方面的研究开辟了新的路径。
- en: 6 Limitation
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6 限制
- en: While our study introduces the end-to-end framework FixAgent with a hierarchical
    multi-agent approach for debugging, it does come with certain limitations. First,
    the complexity of coordinating multiple agents increases computation overhead
    and can slow down the debugging process, particularly in resource-constrained
    environments. Second, our framework relies heavily on predefined agent roles and
    assumptions, which may not fully generalize to novel or edge-case bugs in diverse
    programming languages. Third, the integration of external program analysis tools,
    while useful, can introduce delays and inconsistencies in data retrieval, affecting
    the overall efficiency. Future work should explore optimizing token consumption,
    improving adaptability to diverse bug types, and ensuring smoother integration
    with external tools for faster and more reliable debugging.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的研究提出了一个端到端框架FixAgent，并采用层次化多代理方法进行调试，但它确实存在一些局限性。首先，协调多个代理的复杂性增加了计算开销，可能会减慢调试过程，特别是在资源有限的环境中。其次，我们的框架严重依赖预定义的代理角色和假设，这可能无法完全适应不同编程语言中的新型或边缘情况的bug。第三，外部程序分析工具的集成虽然有用，但可能会引入延迟和数据检索的不一致性，影响整体效率。未来的工作应探讨优化令牌消耗、提高对不同bug类型的适应性，并确保与外部工具的更顺畅集成，以实现更快速和更可靠的调试。
- en: 7 Ethics Consideration
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7 伦理考虑
- en: We do not foresee any immediate ethical or societal risks arising from our work.
    However, given that FixAgent relies heavily on LLM-generated code patches, there
    is a potential risk of introducing unintended vulnerabilities or errors in software.
    We encourage researchers and practitioners to apply FixAgent cautiously, particularly
    when using it in production environments. Ensuring thorough validation and testing
    of LLM-generated patches is crucial to mitigate any negative consequences. Additionally,
    We adhere to the License Agreement of the LLM models and mentioned open-sourced
    tools.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计我们的工作不会引发任何直接的伦理或社会风险。然而，由于FixAgent高度依赖LLM生成的代码补丁，存在引入意外漏洞或错误的潜在风险。我们鼓励研究人员和实践者在使用FixAgent时保持谨慎，尤其是在生产环境中使用时。确保对LLM生成的补丁进行充分的验证和测试，以降低任何负面后果的发生风险。此外，我们遵守LLM模型及相关开源工具的许可协议。
- en: References
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: Abreu et al. (2006) Rui Abreu, Peter Zoeteweij, and Arjan J. C. van Gemund.
    2006. An evaluation of similarity coefficients for software fault localization.
    In *12th IEEE Pacific Rim International Symposium on Dependable Computing (PRDC
    2006), 18-20 December, 2006, University of California, Riverside, USA*, pages
    39–46\. IEEE Computer Society.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Abreu 等人（2006） Rui Abreu、Peter Zoeteweij 和 Arjan J. C. van Gemund。2006年。软件故障定位相似度系数的评估。在
    *第12届IEEE太平洋地区国际可依赖计算研讨会（PRDC 2006），2006年12月18-20日，美国加利福尼亚大学河滨分校*，第39-46页。IEEE计算机学会。
- en: Abreu et al. (2009) Rui Abreu, Peter Zoeteweij, and Arjan J. C. van Gemund.
    2009. Spectrum-based multiple fault localization. In *ASE 2009, 24th IEEE/ACM
    International Conference on Automated Software Engineering, Auckland, New Zealand,
    November 16-20, 2009*, pages 88–99\. IEEE Computer Society.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Abreu 等人（2009）Rui Abreu, Peter Zoeteweij 和 Arjan J. C. van Gemund. 2009. 基于频谱的多重故障定位。在*ASE
    2009，第24届IEEE/ACM自动化软件工程国际会议，新西兰奥克兰，2009年11月16-20日*，第88-99页。IEEE计算机学会。
- en: 'Andrew and David (2000) Hunt Andrew and Thomas David. 2000. The pragmatic programmer:
    From journeyman to master.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Andrew 和 David（2000）Hunt Andrew 和 Thomas David. 2000. 实用程序员：从学徒到大师。
- en: 'Anil et al. (2023) Rohan Anil, Sebastian Borgeaud, Yonghui Wu, Jean-Baptiste
    Alayrac, Jiahui Yu, Radu Soricut, Johan Schalkwyk, Andrew M. Dai, Anja Hauth,
    Katie Millican, David Silver, Slav Petrov, Melvin Johnson, Ioannis Antonoglou,
    Julian Schrittwieser, Amelia Glaese, Jilin Chen, Emily Pitler, Timothy P. Lillicrap,
    Angeliki Lazaridou, Orhan Firat, James Molloy, Michael Isard, Paul Ronald Barham,
    Tom Hennigan, Benjamin Lee, Fabio Viola, Malcolm Reynolds, Yuanzhong Xu, Ryan
    Doherty, Eli Collins, Clemens Meyer, Eliza Rutherford, Erica Moreira, Kareem Ayoub,
    Megha Goel, George Tucker, Enrique Piqueras, Maxim Krikun, Iain Barr, Nikolay
    Savinov, Ivo Danihelka, Becca Roelofs, Anaïs White, Anders Andreassen, Tamara
    von Glehn, Lakshman Yagati, Mehran Kazemi, Lucas Gonzalez, Misha Khalman, Jakub
    Sygnowski, and et al. 2023. Gemini: A family of highly capable multimodal models.
    *CoRR*, abs/2312.11805.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anil 等人（2023）Rohan Anil, Sebastian Borgeaud, Yonghui Wu, Jean-Baptiste Alayrac,
    Jiahui Yu, Radu Soricut, Johan Schalkwyk, Andrew M. Dai, Anja Hauth, Katie Millican,
    David Silver, Slav Petrov, Melvin Johnson, Ioannis Antonoglou, Julian Schrittwieser,
    Amelia Glaese, Jilin Chen, Emily Pitler, Timothy P. Lillicrap, Angeliki Lazaridou,
    Orhan Firat, James Molloy, Michael Isard, Paul Ronald Barham, Tom Hennigan, Benjamin
    Lee, Fabio Viola, Malcolm Reynolds, Yuanzhong Xu, Ryan Doherty, Eli Collins, Clemens
    Meyer, Eliza Rutherford, Erica Moreira, Kareem Ayoub, Megha Goel, George Tucker,
    Enrique Piqueras, Maxim Krikun, Iain Barr, Nikolay Savinov, Ivo Danihelka, Becca
    Roelofs, Anaïs White, Anders Andreassen, Tamara von Glehn, Lakshman Yagati, Mehran
    Kazemi, Lucas Gonzalez, Misha Khalman, Jakub Sygnowski 等人. 2023. Gemini：一系列高度强大的多模态模型。*CoRR*，abs/2312.11805。
- en: Anthropic (2024) Anthropic. 2024. [Introducing the next generation of claude](https://www.anthropic.com/news/claude-3-family).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anthropic（2024）Anthropic. 2024. [介绍下一代 Claude](https://www.anthropic.com/news/claude-3-family)。
- en: 'Benton et al. (2020) Samuel Benton, Xia Li, Yiling Lou, and Lingming Zhang.
    2020. On the effectiveness of unified debugging: An extensive study on 16 program
    repair systems. In *35th IEEE/ACM International Conference on Automated Software
    Engineering, ASE 2020, Melbourne, Australia, September 21-25, 2020*, pages 907–918\.
    IEEE.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Benton 等人（2020）Samuel Benton, Xia Li, Yiling Lou 和 Lingming Zhang. 2020. 关于统一调试的有效性：16个程序修复系统的广泛研究。在*第35届IEEE/ACM自动化软件工程国际会议，ASE
    2020，澳大利亚墨尔本，2020年9月21-25日*，第907-918页。IEEE。
- en: Chen et al. (2021) Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Pondé
    de Oliveira Pinto, Jared Kaplan, Harrison Edwards, Yuri Burda, Nicholas Joseph,
    Greg Brockman, Alex Ray, Raul Puri, Gretchen Krueger, Michael Petrov, Heidy Khlaaf,
    Girish Sastry, Pamela Mishkin, Brooke Chan, Scott Gray, Nick Ryder, Mikhail Pavlov,
    Alethea Power, Lukasz Kaiser, Mohammad Bavarian, Clemens Winter, Philippe Tillet,
    Felipe Petroski Such, Dave Cummings, Matthias Plappert, Fotios Chantzis, Elizabeth
    Barnes, Ariel Herbert-Voss, William Hebgen Guss, Alex Nichol, Alex Paino, Nikolas
    Tezak, Jie Tang, Igor Babuschkin, Suchir Balaji, Shantanu Jain, William Saunders,
    Christopher Hesse, Andrew N. Carr, Jan Leike, Joshua Achiam, Vedant Misra, Evan
    Morikawa, Alec Radford, Matthew Knight, Miles Brundage, Mira Murati, Katie Mayer,
    Peter Welinder, Bob McGrew, Dario Amodei, Sam McCandlish, Ilya Sutskever, and
    Wojciech Zaremba. 2021. Evaluating large language models trained on code. *CoRR*,
    abs/2107.03374.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chen 等人（2021）Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Pondé
    de Oliveira Pinto, Jared Kaplan, Harrison Edwards, Yuri Burda, Nicholas Joseph,
    Greg Brockman, Alex Ray, Raul Puri, Gretchen Krueger, Michael Petrov, Heidy Khlaaf,
    Girish Sastry, Pamela Mishkin, Brooke Chan, Scott Gray, Nick Ryder, Mikhail Pavlov,
    Alethea Power, Lukasz Kaiser, Mohammad Bavarian, Clemens Winter, Philippe Tillet,
    Felipe Petroski Such, Dave Cummings, Matthias Plappert, Fotios Chantzis, Elizabeth
    Barnes, Ariel Herbert-Voss, William Hebgen Guss, Alex Nichol, Alex Paino, Nikolas
    Tezak, Jie Tang, Igor Babuschkin, Suchir Balaji, Shantanu Jain, William Saunders,
    Christopher Hesse, Andrew N. Carr, Jan Leike, Joshua Achiam, Vedant Misra, Evan
    Morikawa, Alec Radford, Matthew Knight, Miles Brundage, Mira Murati, Katie Mayer,
    Peter Welinder, Bob McGrew, Dario Amodei, Sam McCandlish, Ilya Sutskever 和 Wojciech
    Zaremba. 2021. 评估在代码上训练的大型语言模型。*CoRR*，abs/2107.03374。
- en: Dong et al. (2023) Yihong Dong, Xue Jiang, Zhi Jin, and Ge Li. 2023. [Self-collaboration
    code generation via chatgpt](https://doi.org/10.48550/arXiv.2304.07590). *CoRR*,
    abs/2304.07590.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dong 等人（2023）Yihong Dong, Xue Jiang, Zhi Jin 和 Ge Li. 2023. [通过 chatgpt 进行自协作代码生成](https://doi.org/10.48550/arXiv.2304.07590)。*CoRR*，abs/2304.07590。
- en: 'Goues et al. (2012) Claire Le Goues, Michael Dewey-Vogt, Stephanie Forrest,
    and Westley Weimer. 2012. A systematic study of automated program repair: Fixing
    55 out of 105 bugs for $8 each. In *34th International Conference on Software
    Engineering, ICSE 2012, June 2-9, 2012, Zurich, Switzerland*, pages 3–13\. IEEE
    Computer Society.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goues等人（2012）Claire Le Goues、Michael Dewey-Vogt、Stephanie Forrest和Westley Weimer。2012年。《自动程序修复的系统研究：修复105个错误中的55个，每个错误修复费用为8美元》。发表于*2012年国际软件工程大会（ICSE
    2012），2012年6月2日至9日，瑞士苏黎世*，第3-13页。IEEE计算机学会。
- en: 'Guo et al. (2024) Daya Guo, Qihao Zhu, Dejian Yang, Zhenda Xie, Kai Dong, Wentao
    Zhang, Guanting Chen, Xiao Bi, Y. Wu, Y. K. Li, Fuli Luo, Yingfei Xiong, and Wenfeng
    Liang. 2024. Deepseek-coder: When the large language model meets programming -
    the rise of code intelligence. *CoRR*, abs/2401.14196.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Guo等人（2024）Daya Guo、Qihao Zhu、Dejian Yang、Zhenda Xie、Kai Dong、Wentao Zhang、Guanting
    Chen、Xiao Bi、Y. Wu、Y. K. Li、Fuli Luo、Yingfei Xiong和Wenfeng Liang。2024年。Deepseek-coder：当大规模语言模型遇到编程——代码智能的崛起。*CoRR*，abs/2401.14196。
- en: (11) GZoltar. [[link]](https://gzoltar.com/).
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (11) GZoltar. [[链接]](https://gzoltar.com/)。
- en: 'Hale and Haworth (1991) David P. Hale and Dwight A. Haworth. 1991. [Towards
    a model of programmers’ cognitive processes in software maintenance: A structural
    learning theory approach for debugging](https://doi.org/10.1002/smr.4360030204).
    *J. Softw. Maintenance Res. Pract.*, 3(2):85–106.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hale和Haworth（1991）David P. Hale和Dwight A. Haworth。1991年。[面向软件维护中程序员认知过程的模型：一种结构化学习理论方法用于调试](https://doi.org/10.1002/smr.4360030204)。*J.
    Softw. Maintenance Res. Pract.*, 3(2):85–106。
- en: Hale et al. (1999) Joanne E. Hale, Shane Sharpe, and David P. Hale. 1999. [An
    evaluation of the cognitive processes of programmers engaged in software debugging](https://doi.org/10.1002/(SICI)1096-908X(199903/04)11:2).
    *J. Softw. Maintenance Res. Pract.*, 11(2):73–91.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hale等人（1999）Joanne E. Hale、Shane Sharpe和David P. Hale。1999年。[评估程序员在软件调试过程中涉及的认知过程](https://doi.org/10.1002/(SICI)1096-908X(199903/04)11:2)。*J.
    Softw. Maintenance Res. Pract.*, 11(2):73–91。
- en: 'Hong et al. (2024) Sirui Hong, Mingchen Zhuge, Jonathan Chen, Xiawu Zheng,
    Yuheng Cheng, Jinlin Wang, Ceyao Zhang, Zili Wang, Steven Ka Shing Yau, Zijuan
    Lin, Liyang Zhou, Chenyu Ran, Lingfeng Xiao, Chenglin Wu, and Jürgen Schmidhuber.
    2024. [Metagpt: Meta programming for A multi-agent collaborative framework](https://openreview.net/forum?id=VtmBAGCN7o).
    In *The Twelfth International Conference on Learning Representations, ICLR 2024,
    Vienna, Austria, May 7-11, 2024*. OpenReview.net.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hong等人（2024）Sirui Hong、Mingchen Zhuge、Jonathan Chen、Xiawu Zheng、Yuheng Cheng、Jinlin
    Wang、Ceyao Zhang、Zili Wang、Steven Ka Shing Yau、Zijuan Lin、Liyang Zhou、Chenyu Ran、Lingfeng
    Xiao、Chenglin Wu和Jürgen Schmidhuber。2024年。[Metagpt：多代理协作框架的元编程](https://openreview.net/forum?id=VtmBAGCN7o)。发表于*第十二届国际学习表征会议（ICLR
    2024），2024年5月7日至11日，奥地利维也纳*。OpenReview.net。
- en: 'Huang et al. (2024) Dong Huang, Jie M. Zhang, Michael Luck, Qingwen Bu, Yuhao
    Qing, and Heming Cui. 2024. [Agentcoder: Multi-agent-based code generation with
    iterative testing and optimisation](https://arxiv.org/abs/2312.13010). *Preprint*,
    arXiv:2312.13010.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Huang等人（2024）Dong Huang、Jie M. Zhang、Michael Luck、Qingwen Bu、Yuhao Qing和Heming
    Cui。2024年。[Agentcoder：基于多代理的代码生成与迭代测试和优化](https://arxiv.org/abs/2312.13010)。*预印本*，arXiv:2312.13010。
- en: Huang et al. (2023) Kai Huang, Xiangxin Meng, Jian Zhang, Yang Liu, Wenjie Wang,
    Shuhao Li, and Yuqing Zhang. 2023. An empirical study on fine-tuning large language
    models of code for automated program repair. In *38th IEEE/ACM International Conference
    on Automated Software Engineering, ASE 2023, Luxembourg, September 11-15, 2023*,
    pages 1162–1174\. IEEE.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Huang等人（2023）Kai Huang、Xiangxin Meng、Jian Zhang、Yang Liu、Wenjie Wang、Shuhao
    Li和Yuqing Zhang。2023年。《大规模语言模型在自动程序修复中的微调实证研究》。发表于*第38届IEEE/ACM国际自动化软件工程大会（ASE
    2023），2023年9月11日至15日，卢森堡*，第1162-1174页。IEEE。
- en: 'Islam et al. (2024) Md. Ashraful Islam, Mohammed Eunus Ali, and Md. Rizwan
    Parvez. 2024. [Mapcoder: Multi-agent code generation for competitive problem solving](https://doi.org/10.18653/v1/2024.acl-long.269).
    In *Proceedings of the 62nd Annual Meeting of the Association for Computational
    Linguistics (Volume 1: Long Papers), ACL 2024, Bangkok, Thailand, August 11-16,
    2024*, pages 4912–4944\. Association for Computational Linguistics.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Islam等人（2024）Md. Ashraful Islam、Mohammed Eunus Ali和Md. Rizwan Parvez。2024年。[Mapcoder：面向竞争性问题求解的多代理代码生成](https://doi.org/10.18653/v1/2024.acl-long.269)。发表于*第62届计算语言学协会年会论文集（第一卷：长篇论文），ACL
    2024，2024年8月11日至16日，泰国曼谷*，第4912-4944页。计算语言学协会。
- en: 'Jiang et al. (2021) Nan Jiang, Thibaud Lutellier, and Lin Tan. 2021. CURE:
    code-aware neural machine translation for automatic program repair. In *43rd IEEE/ACM
    International Conference on Software Engineering, ICSE 2021, Madrid, Spain, 22-30
    May 2021*, pages 1161–1173\. IEEE.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jiang 等人（2021）Nan Jiang、Thibaud Lutellier 和 Lin Tan。2021年。CURE：面向自动程序修复的代码感知神经机器翻译。发表于
    *第43届IEEE/ACM国际软件工程会议，ICSE 2021，马德里，西班牙，2021年5月22日-30日*，第1161–1173页。IEEE。
- en: 'Just et al. (2014) René Just, Darioush Jalali, and Michael D. Ernst. 2014.
    Defects4j: a database of existing faults to enable controlled testing studies
    for java programs. In *International Symposium on Software Testing and Analysis,
    ISSTA ’14, San Jose, CA, USA - July 21 - 26, 2014*, pages 437–440\. ACM.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Just 等人（2014）René Just、Darioush Jalali 和 Michael D. Ernst。2014年。Defects4j：一个现有故障数据库，用于支持
    Java 程序的受控测试研究。发表于 *2014年国际软件测试与分析研讨会，ISSTA ’14，圣何塞，加利福尼亚州，美国 - 2014年7月21日-26日*，第437–440页。ACM。
- en: Kochhar et al. (2016) Pavneet Singh Kochhar, Xin Xia, David Lo, and Shanping
    Li. 2016. Practitioners’ expectations on automated fault localization. In *Proceedings
    of the 25th International Symposium on Software Testing and Analysis, ISSTA 2016,
    Saarbrücken, Germany, July 18-20, 2016*, pages 165–176\. ACM.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kochhar 等人（2016）Pavneet Singh Kochhar、Xin Xia、David Lo 和 Shanping Li。2016年。从业人员对自动化故障定位的期望。发表于
    *第25届国际软件测试与分析研讨会，ISSTA 2016，萨尔布吕肯，德国，2016年7月18日-20日*，第165–176页。ACM。
- en: Le et al. (2018) Xuan-Bach Dinh Le, Ferdian Thung, David Lo, and Claire Le Goues.
    2018. Overfitting in semantics-based automated program repair. In *Proceedings
    of the 40th International Conference on Software Engineering, ICSE 2018, Gothenburg,
    Sweden, May 27 - June 03, 2018*, page 163\. ACM.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Le 等人（2018）Xuan-Bach Dinh Le、Ferdian Thung、David Lo 和 Claire Le Goues。2018年。基于语义的自动化程序修复中的过拟合问题。发表于
    *第40届国际软件工程会议，ICSE 2018，哥德堡，瑞典，2018年5月27日-6月3日*，第163页。ACM。
- en: 'Li et al. (2019) Xia Li, Wei Li, Yuqun Zhang, and Lingming Zhang. 2019. Deepfl:
    integrating multiple fault diagnosis dimensions for deep fault localization. In
    *Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing
    and Analysis, ISSTA 2019, Beijing, China, July 15-19, 2019*, pages 169–180\. ACM.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Li 等人（2019）Xia Li、Wei Li、Yuqun Zhang 和 Lingming Zhang。2019年。Deepfl：集成多维故障诊断进行深度故障定位。发表于
    *第28届ACM SIGSOFT国际软件测试与分析研讨会，ISSTA 2019，北京，中国，2019年7月15日-19日*，第169–180页。ACM。
- en: Li and Zhang (2017) Xia Li and Lingming Zhang. 2017. Transforming programs and
    tests in tandem for fault localization. *Proc. ACM Program. Lang.*, 1(OOPSLA):92:1–92:30.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Li 和 Zhang（2017）Xia Li 和 Lingming Zhang。2017年。同步转换程序和测试进行故障定位。*Proc. ACM Program.
    Lang.*，1（OOPSLA）：92:1–92:30。
- en: Li et al. (2021) Yi Li, Shaohua Wang, and Tien N. Nguyen. 2021. Fault localization
    with code coverage representation learning. In *43rd IEEE/ACM International Conference
    on Software Engineering, ICSE 2021, Madrid, Spain, 22-30 May 2021*, pages 661–673\.
    IEEE.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Li 等人（2021）Yi Li、Shaohua Wang 和 Tien N. Nguyen。2021年。通过代码覆盖表示学习进行故障定位。发表于 *第43届IEEE/ACM国际软件工程会议，ICSE
    2021，马德里，西班牙，2021年5月22日-30日*，第661–673页。IEEE。
- en: Li et al. (2022) Yi Li, Shaohua Wang, and Tien N. Nguyen. 2022. Fault localization
    to detect co-change fixing locations. In *Proceedings of the 30th ACM Joint European
    Software Engineering Conference and Symposium on the Foundations of Software Engineering,
    ESEC/FSE 2022, Singapore, Singapore, November 14-18, 2022*, pages 659–671\. ACM.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Li 等人（2022）Yi Li、Shaohua Wang 和 Tien N. Nguyen。2022年。故障定位以检测共同修复位置。发表于 *第30届ACM欧洲软件工程联合会议暨软件工程基础研讨会，ESEC/FSE
    2022，新加坡，新加坡，2022年11月14日-18日*，第659–671页。ACM。
- en: 'Lin et al. (2017) Derrick Lin, James Koppel, Angela Chen, and Armando Solar-Lezama.
    2017. Quixbugs: a multi-lingual program repair benchmark set based on the quixey
    challenge. In *Proceedings Companion of the 2017 ACM SIGPLAN International Conference
    on Systems, Programming, Languages, and Applications: Software for Humanity, SPLASH
    2017, Vancouver, BC, Canada, October 23 - 27, 2017*, pages 55–56\. ACM.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lin 等人（2017）Derrick Lin、James Koppel、Angela Chen 和 Armando Solar-Lezama。2017年。Quixbugs：基于
    Quixey 挑战的多语言程序修复基准集。发表于 *2017年ACM SIGPLAN国际系统、编程语言与应用：为人类的软件会议，SPLASH 2017，温哥华，不列颠哥伦比亚省，加拿大，2017年10月23日-27日*，第55–56页。ACM。
- en: 'Liu et al. (2019) Kui Liu, Anil Koyuncu, Dongsun Kim, and Tegawendé F. Bissyandé.
    2019. [Tbar: revisiting template-based automated program repair](https://doi.org/10.1145/3293882.3330577).
    In *Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing
    and Analysis, ISSTA 2019, Beijing, China, July 15-19, 2019*, pages 31–42\. ACM.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Liu et al. (2019) Kui Liu, Anil Koyuncu, Dongsun Kim, 和 Tegawendé F. Bissyandé.
    2019. [Tbar: 重新审视基于模板的自动化程序修复](https://doi.org/10.1145/3293882.3330577)。发表于 *2019年第28届ACM
    SIGSOFT国际软件测试与分析研讨会（ISSTA 2019），中国北京，2019年7月15-19日*，第31-42页。ACM。'
- en: Long (2018) Fan Long. 2018. *Automatic patch generation via learning from successful
    human patches*. Ph.D. thesis, Massachusetts Institute of Technology, Cambridge,
    USA.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Long (2018) Fan Long. 2018. *通过学习成功的人类补丁进行自动补丁生成*。博士论文，麻省理工学院，美国剑桥。
- en: Long and Rinard (2015) Fan Long and Martin C. Rinard. 2015. Staged program repair
    with condition synthesis. In *Proceedings of the 2015 10th Joint Meeting on Foundations
    of Software Engineering, ESEC/FSE 2015, Bergamo, Italy, August 30 - September
    4, 2015*, pages 166–178\. ACM.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Long and Rinard (2015) Fan Long 和 Martin C. Rinard. 2015. 通过条件合成进行阶段性程序修复。发表于
    *2015年第10届联合软件工程基础会议（ESEC/FSE 2015），意大利贝尔加莫，2015年8月30日至9月4日*，第166-178页。ACM。
- en: 'Lou et al. (2021) Yiling Lou, Qihao Zhu, Jinhao Dong, Xia Li, Zeyu Sun, Dan
    Hao, Lu Zhang, and Lingming Zhang. 2021. Boosting coverage-based fault localization
    via graph-based representation learning. In *ESEC/FSE ’21: 29th ACM Joint European
    Software Engineering Conference and Symposium on the Foundations of Software Engineering,
    Athens, Greece, August 23-28, 2021*, pages 664–676\. ACM.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lou et al. (2021) Yiling Lou, Qihao Zhu, Jinhao Dong, Xia Li, Zeyu Sun, Dan
    Hao, Lu Zhang, 和 Lingming Zhang. 2021. 通过基于图的表示学习提升基于覆盖的故障定位。发表于 *ESEC/FSE ’21：第29届ACM联合欧洲软件工程会议及软件工程基础研讨会，希腊雅典，2021年8月23-28日*，第664-676页。ACM。
- en: 'Lutellier et al. (2020) Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong
    Li, Moshi Wei, and Lin Tan. 2020. Coconut: combining context-aware neural translation
    models using ensemble for program repair. In *ISSTA ’20: 29th ACM SIGSOFT International
    Symposium on Software Testing and Analysis, Virtual Event, USA, July 18-22, 2020*,
    pages 101–114\. ACM.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lutellier et al. (2020) Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong
    Li, Moshi Wei, 和 Lin Tan. 2020. Coconut：结合上下文感知神经翻译模型和集成方法进行程序修复。发表于 *ISSTA ’20：第29届ACM
    SIGSOFT国际软件测试与分析研讨会，虚拟会议，美国，2020年7月18-22日*，第101-114页。ACM。
- en: 'Mechtaev et al. (2016) Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury.
    2016. Angelix: scalable multiline program patch synthesis via symbolic analysis.
    In *Proceedings of the 38th International Conference on Software Engineering,
    ICSE 2016, Austin, TX, USA, May 14-22, 2016*, pages 691–701\. ACM.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mechtaev et al. (2016) Sergey Mechtaev, Jooyong Yi, 和 Abhik Roychoudhury. 2016.
    Angelix：通过符号分析进行可扩展的多行程序补丁合成。发表于 *2016年第38届国际软件工程会议（ICSE 2016），美国德克萨斯州奥斯汀，2016年5月14-22日*，第691-701页。ACM。
- en: 'Moon et al. (2014) Seokhyeon Moon, Yunho Kim, Moonzoo Kim, and Shin Yoo. 2014.
    Ask the mutants: Mutating faulty programs for fault localization. In *Seventh
    IEEE International Conference on Software Testing, Verification and Validation,
    ICST 2014, March 31 2014-April 4, 2014, Cleveland, Ohio, USA*, pages 153–162\.
    IEEE Computer Society.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moon et al. (2014) Seokhyeon Moon, Yunho Kim, Moonzoo Kim, 和 Shin Yoo. 2014.
    向变异体提问：通过变异故障程序进行故障定位。发表于 *第七届IEEE国际软件测试、验证与验证会议（ICST 2014），2014年3月31日-4月4日，美国俄亥俄州克利夫兰*，第153-162页。IEEE计算机学会。
- en: 'Nguyen et al. (2013) Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury,
    and Satish Chandra. 2013. Semfix: program repair via semantic analysis. In *35th
    International Conference on Software Engineering, ICSE ’13, San Francisco, CA,
    USA, May 18-26, 2013*, pages 772–781\. IEEE Computer Society.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nguyen et al. (2013) Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury,
    和 Satish Chandra. 2013. Semfix：通过语义分析进行程序修复。发表于 *第35届国际软件工程会议（ICSE ’13），2013年5月18-26日，美国加利福尼亚州旧金山*，第772-781页。IEEE计算机学会。
- en: OpenAI (2023a) OpenAI. 2023a. [Gpt-3.5 turbo](https://platform.openai.com/docs/models/gpt-3-5-turbo).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAI (2023a) OpenAI. 2023a. [Gpt-3.5 turbo](https://platform.openai.com/docs/models/gpt-3-5-turbo)。
- en: 'OpenAI (2023b) OpenAI. 2023b. [Gpt-4: a technical report](https://doi.org/10.48550/arXiv.2303.08774).
    *CoRR*, abs/2303.08774.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAI (2023b) OpenAI. 2023b. [Gpt-4：技术报告](https://doi.org/10.48550/arXiv.2303.08774)。*CoRR*，abs/2303.08774。
- en: 'Qian et al. (2024) Chen Qian, Wei Liu, Hongzhang Liu, Nuo Chen, Yufan Dang,
    Jiahao Li, Cheng Yang, Weize Chen, Yusheng Su, Xin Cong, Juyuan Xu, Dahai Li,
    Zhiyuan Liu, and Maosong Sun. 2024. [Chatdev: Communicative agents for software
    development](https://doi.org/10.18653/v1/2024.acl-long.810). In *Proceedings of
    the 62nd Annual Meeting of the Association for Computational Linguistics (Volume
    1: Long Papers), ACL 2024, Bangkok, Thailand, August 11-16, 2024*, pages 15174–15186\.
    Association for Computational Linguistics.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Qian 等人（2024）Chen Qian, Wei Liu, Hongzhang Liu, Nuo Chen, Yufan Dang, Jiahao
    Li, Cheng Yang, Weize Chen, Yusheng Su, Xin Cong, Juyuan Xu, Dahai Li, Zhiyuan
    Liu 和 Maosong Sun. 2024. [Chatdev: 用于软件开发的交流代理](https://doi.org/10.18653/v1/2024.acl-long.810)。收录于
    *第62届计算语言学协会年会（第一卷：长篇论文），ACL 2024，泰国曼谷，2024年8月11-16日*，第15174-15186页。计算语言学协会。'
- en: 'Reynolds et al. (2015) Andrew Reynolds, Morgan Deters, Viktor Kuncak, Cesare
    Tinelli, and Clark Barrett. 2015. Counterexample-guided quantifier instantiation
    for synthesis in smt. In *Computer Aided Verification: 27th International Conference,
    CAV 2015, San Francisco, CA, USA, July 18-24, 2015, Proceedings, Part II 27*,
    pages 198–216\. Springer.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reynolds 等人（2015）Andrew Reynolds, Morgan Deters, Viktor Kuncak, Cesare Tinelli
    和 Clark Barrett. 2015. 针对 SMT 合成的反例引导量化符号实例化。收录于 *计算机辅助验证：第27届国际会议，CAV 2015，美国加利福尼亚州旧金山，2015年7月18-24日，会议录，第II部分
    27*，第198-216页。Springer。
- en: 'Rozière et al. (2023) Baptiste Rozière, Jonas Gehring, Fabian Gloeckle, Sten
    Sootla, Itai Gat, Xiaoqing Ellen Tan, Yossi Adi, Jingyu Liu, Tal Remez, Jérémy
    Rapin, Artyom Kozhevnikov, Ivan Evtimov, Joanna Bitton, Manish Bhatt, Cristian
    Canton-Ferrer, Aaron Grattafiori, Wenhan Xiong, Alexandre Défossez, Jade Copet,
    Faisal Azhar, Hugo Touvron, Louis Martin, Nicolas Usunier, Thomas Scialom, and
    Gabriel Synnaeve. 2023. Code llama: Open foundation models for code. *CoRR*, abs/2308.12950.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rozière 等人（2023）Baptiste Rozière, Jonas Gehring, Fabian Gloeckle, Sten Sootla,
    Itai Gat, Xiaoqing Ellen Tan, Yossi Adi, Jingyu Liu, Tal Remez, Jérémy Rapin,
    Artyom Kozhevnikov, Ivan Evtimov, Joanna Bitton, Manish Bhatt, Cristian Canton-Ferrer,
    Aaron Grattafiori, Wenhan Xiong, Alexandre Défossez, Jade Copet, Faisal Azhar,
    Hugo Touvron, Louis Martin, Nicolas Usunier, Thomas Scialom 和 Gabriel Synnaeve.
    2023. Code llama：用于代码的开放基础模型。*CoRR*, abs/2308.12950。
- en: (40) SonarQube. [[link]](https://www.sonarsource.com/).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (40) SonarQube. [[link]](https://www.sonarsource.com/)。
- en: Soremekun et al. (2023) Ezekiel O. Soremekun, Lukas Kirschner, Marcel Böhme,
    and Mike Papadakis. 2023. [Evaluating the impact of experimental assumptions in
    automated fault localization](https://doi.org/10.1109/ICSE48619.2023.00025). In
    *45th IEEE/ACM International Conference on Software Engineering, ICSE 2023, Melbourne,
    Australia, May 14-20, 2023*, pages 159–171\. IEEE.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Soremekun 等人（2023）Ezekiel O. Soremekun, Lukas Kirschner, Marcel Böhme 和 Mike
    Papadakis. 2023. [评估实验假设在自动故障定位中的影响](https://doi.org/10.1109/ICSE48619.2023.00025)。收录于
    *第45届IEEE/ACM国际软件工程会议，ICSE 2023，澳大利亚墨尔本，2023年5月14-20日*，第159-171页。IEEE。
- en: 'Tan et al. (2017) Shin Hwei Tan, Jooyong Yi, Yulis, Sergey Mechtaev, and Abhik
    Roychoudhury. 2017. Codeflaws: a programming competition benchmark for evaluating
    automated program repair tools. In *Proceedings of the 39th International Conference
    on Software Engineering, ICSE 2017, Buenos Aires, Argentina, May 20-28, 2017 -
    Companion Volume*, pages 180–182\. IEEE Computer Society.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tan 等人（2017）Shin Hwei Tan, Jooyong Yi, Yulis, Sergey Mechtaev 和 Abhik Roychoudhury.
    2017. Codeflaws：用于评估自动程序修复工具的编程竞赛基准。收录于 *第39届国际软件工程会议，ICSE 2017，阿根廷布宜诺斯艾利斯，2017年5月20-28日
    - 附录卷*，第180-182页。IEEE计算机学会。
- en: (43) Tavily. [[link]](https://tavily.com/).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (43) Tavily. [[link]](https://tavily.com/)。
- en: 'Tian et al. (2024) Runchu Tian, Yining Ye, Yujia Qin, Xin Cong, Yankai Lin,
    Yinxu Pan, Yesai Wu, Zhiyuan Liu, and Maosong Sun. 2024. Debugbench: Evaluating
    debugging capability of large language models. *CoRR*, abs/2401.04621.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tian 等人（2024）Runchu Tian, Yining Ye, Yujia Qin, Xin Cong, Yankai Lin, Yinxu
    Pan, Yesai Wu, Zhiyuan Liu 和 Maosong Sun. 2024. Debugbench：评估大型语言模型的调试能力。*CoRR*,
    abs/2401.04621。
- en: 'Touvron et al. (2023) Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert,
    Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava,
    Shruti Bhosale, Dan Bikel, Lukas Blecher, Cristian Canton-Ferrer, Moya Chen, Guillem
    Cucurull, David Esiobu, Jude Fernandes, Jeremy Fu, Wenyin Fu, Brian Fuller, Cynthia
    Gao, Vedanuj Goswami, Naman Goyal, Anthony Hartshorn, Saghar Hosseini, Rui Hou,
    Hakan Inan, Marcin Kardas, Viktor Kerkez, Madian Khabsa, Isabel Kloumann, Artem
    Korenev, Punit Singh Koura, Marie-Anne Lachaux, Thibaut Lavril, Jenya Lee, Diana
    Liskovich, Yinghai Lu, Yuning Mao, Xavier Martinet, Todor Mihaylov, Pushkar Mishra,
    Igor Molybog, Yixin Nie, Andrew Poulton, Jeremy Reizenstein, Rashi Rungta, Kalyan
    Saladi, Alan Schelten, Ruan Silva, Eric Michael Smith, Ranjan Subramanian, Xiaoqing Ellen
    Tan, Binh Tang, Ross Taylor, Adina Williams, Jian Xiang Kuan, Puxin Xu, Zheng
    Yan, Iliyan Zarov, Yuchen Zhang, Angela Fan, Melanie Kambadur, Sharan Narang,
    Aurélien Rodriguez, Robert Stojnic, Sergey Edunov, and Thomas Scialom. 2023. [Llama
    2: Open foundation and fine-tuned chat models](https://doi.org/10.48550/arXiv.2307.09288).
    *CoRR*, abs/2307.09288.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Touvron 等人（2023）Hugo Touvron、Louis Martin、Kevin Stone、Peter Albert、Amjad Almahairi、Yasmine
    Babaei、Nikolay Bashlykov、Soumya Batra、Prajjwal Bhargava、Shruti Bhosale、Dan Bikel、Lukas
    Blecher、Cristian Canton-Ferrer、Moya Chen、Guillem Cucurull、David Esiobu、Jude Fernandes、Jeremy
    Fu、Wenyin Fu、Brian Fuller、Cynthia Gao、Vedanuj Goswami、Naman Goyal、Anthony Hartshorn、Saghar
    Hosseini、Rui Hou、Hakan Inan、Marcin Kardas、Viktor Kerkez、Madian Khabsa、Isabel Kloumann、Artem
    Korenev、Punit Singh Koura、Marie-Anne Lachaux、Thibaut Lavril、Jenya Lee、Diana Liskovich、Yinghai
    Lu、Yuning Mao、Xavier Martinet、Todor Mihaylov、Pushkar Mishra、Igor Molybog、Yixin
    Nie、Andrew Poulton、Jeremy Reizenstein、Rashi Rungta、Kalyan Saladi、Alan Schelten、Ruan
    Silva、Eric Michael Smith、Ranjan Subramanian、Xiaoqing Ellen Tan、Binh Tang、Ross
    Taylor、Adina Williams、Jian Xiang Kuan、Puxin Xu、Zheng Yan、Iliyan Zarov、Yuchen Zhang、Angela
    Fan、Melanie Kambadur、Sharan Narang、Aurélien Rodriguez、Robert Stojnic、Sergey Edunov
    和 Thomas Scialom。2023年。[Llama 2: 开放基础与微调聊天模型](https://doi.org/10.48550/arXiv.2307.09288)。*CoRR*,
    abs/2307.09288。'
- en: Wei et al. (2022) Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Brian
    Ichter, Fei Xia, Ed H. Chi, Quoc V. Le, and Denny Zhou. 2022. Chain-of-thought
    prompting elicits reasoning in large language models. In *NeurIPS*.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wei 等人（2022）Jason Wei、Xuezhi Wang、Dale Schuurmans、Maarten Bosma、Brian Ichter、Fei
    Xia、Ed H. Chi、Quoc V. Le 和 Denny Zhou。2022年。链式思维提示法引发大语言模型中的推理。收录于 *NeurIPS*。
- en: 'Wei et al. (2023) Yuxiang Wei, Chunqiu Steven Xia, and Lingming Zhang. 2023.
    Copiloting the copilots: Fusing large language models with completion engines
    for automated program repair. In *Proceedings of the 31st ACM Joint European Software
    Engineering Conference and Symposium on the Foundations of Software Engineering,
    ESEC/FSE 2023, San Francisco, CA, USA, December 3-9, 2023*, pages 172–184\. ACM.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wei 等人（2023）Yuxiang Wei、Chunqiu Steven Xia 和 Lingming Zhang。2023年。与副驾驶共同飞行：将大语言模型与补全引擎融合用于自动化程序修复。收录于
    *第31届ACM欧洲软件工程会议暨软件工程基础会议论文集, ESEC/FSE 2023, 美国加利福尼亚州旧金山, 2023年12月3日至9日*，第172-184页。ACM。
- en: Weimer et al. (2009a) Westley Weimer, ThanhVu Nguyen, Claire Le Goues, and Stephanie
    Forrest. 2009a. Automatically finding patches using genetic programming. In *31st
    International Conference on Software Engineering, ICSE 2009, May 16-24, 2009,
    Vancouver, Canada, Proceedings*, pages 364–374\. IEEE.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Weimer 等人（2009a）Westley Weimer、ThanhVu Nguyen、Claire Le Goues 和 Stephanie Forrest。2009年。自动通过遗传编程寻找补丁。收录于
    *第31届国际软件工程会议, ICSE 2009, 2009年5月16日至24日, 加拿大温哥华, 会议论文集*，第364-374页。IEEE。
- en: Weimer et al. (2009b) Westley Weimer, ThanhVu Nguyen, Claire Le Goues, and Stephanie
    Forrest. 2009b. Automatically finding patches using genetic programming. In *31st
    International Conference on Software Engineering, ICSE 2009, May 16-24, 2009,
    Vancouver, Canada, Proceedings*, pages 364–374\. IEEE.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Weimer 等人（2009b）Westley Weimer、ThanhVu Nguyen、Claire Le Goues 和 Stephanie Forrest。2009年。自动通过遗传编程寻找补丁。收录于
    *第31届国际软件工程会议, ICSE 2009, 2009年5月16日至24日, 加拿大温哥华, 会议论文集*，第364-374页。IEEE。
- en: 'Wu et al. (2024) Yonghao Wu, Zheng Li, Jie M. Zhang, and Yong Liu. 2024. [Condefects:
    A complementary dataset to address the data leakage concern for llm-based fault
    localization and program repair](https://doi.org/10.1145/3663529.3663815). In
    *Companion Proceedings of the 32nd ACM International Conference on the Foundations
    of Software Engineering, FSE 2024, Porto de Galinhas, Brazil, July 15-19, 2024*,
    pages 642–646\. ACM.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Wu 等人（2024）Yonghao Wu、Zheng Li、Jie M. Zhang 和 Yong Liu。2024年。[Condefects: 一个补充数据集，用于解决基于
    LLM 的故障定位和程序修复中的数据泄露问题](https://doi.org/10.1145/3663529.3663815)。收录于 *32届ACM国际软件工程基础会议的附录论文集,
    FSE 2024, 巴西波尔图德吉林哈, 2024年7月15日至19日*，第642-646页。ACM。'
- en: Xia et al. (2023) Chunqiu Steven Xia, Yuxiang Wei, and Lingming Zhang. 2023.
    Automated program repair in the era of large pre-trained language models. In *45th
    IEEE/ACM International Conference on Software Engineering, ICSE 2023, Melbourne,
    Australia, May 14-20, 2023*, pages 1482–1494\. IEEE.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xia 等人（2023）Chunqiu Steven Xia, Yuxiang Wei 和 Lingming Zhang. 2023. 大规模预训练语言模型时代的自动化程序修复。收录于
    *第45届IEEE/ACM国际软件工程会议，ICSE 2023，澳大利亚墨尔本，2023年5月14日至20日*，第1482–1494页。IEEE。
- en: 'Xia and Zhang (2022) Chunqiu Steven Xia and Lingming Zhang. 2022. Less training,
    more repairing please: revisiting automated program repair via zero-shot learning.
    In *Proceedings of the 30th ACM Joint European Software Engineering Conference
    and Symposium on the Foundations of Software Engineering, ESEC/FSE 2022, Singapore,
    Singapore, November 14-18, 2022*, pages 959–971\. ACM.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xia 和 Zhang（2022）Chunqiu Steven Xia 和 Lingming Zhang. 2022. 少训练，多修复：重新审视通过零样本学习进行自动化程序修复。收录于
    *第30届ACM联合欧洲软件工程会议与软件工程基础研讨会，ESEC/FSE 2022，新加坡，新加坡，2022年11月14日至18日*，第959–971页。ACM。
- en: 'Xia and Zhang (2024) Chunqiu Steven Xia and Lingming Zhang. 2024. [Automated
    program repair via conversation: Fixing 162 out of 337 bugs for $0.42 each using
    chatgpt](https://doi.org/10.1145/3650212.3680323). In *Proceedings of the 33rd
    ACM SIGSOFT International Symposium on Software Testing and Analysis*, ISSTA 2024,
    page 819–831, New York, NY, USA. Association for Computing Machinery.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xia 和 Zhang（2024）Chunqiu Steven Xia 和 Lingming Zhang. 2024. [通过对话进行自动化程序修复：使用chatgpt修复337个漏洞中的162个，每个费用$0.42](https://doi.org/10.1145/3650212.3680323)。收录于
    *第33届ACM SIGSOFT国际软件测试与分析研讨会，ISSTA 2024，第819–831页，美国纽约*。计算机协会。
- en: Xia et al. (2017) Xin Xia, Lingfeng Bao, David Lo, Pavneet Singh Kochhar, Ahmed E.
    Hassan, and Zhenchang Xing. 2017. [What do developers search for on the web?](https://doi.org/10.1007/s10664-017-9514-4)
    *Empir. Softw. Eng.*, 22(6):3149–3185.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xia 等人（2017）Xin Xia, Lingfeng Bao, David Lo, Pavneet Singh Kochhar, Ahmed E.
    Hassan 和 Zhenchang Xing. 2017. [开发者在网络上搜索什么？](https://doi.org/10.1007/s10664-017-9514-4)
    *Empir. Softw. Eng.*, 22(6):3149–3185.
- en: Yang et al. (2024) Aidan Z. H. Yang, Claire Le Goues, Ruben Martins, and Vincent J.
    Hellendoorn. 2024. Large language models for test-free fault localization. In
    *Proceedings of the 46th IEEE/ACM International Conference on Software Engineering,
    ICSE 2024, Lisbon, Portugal, April 14-20, 2024*, pages 17:1–17:12\. ACM.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yang 等人（2024）Aidan Z. H. Yang, Claire Le Goues, Ruben Martins 和 Vincent J. Hellendoorn.
    2024. 大型语言模型用于无测试故障定位。收录于 *第46届IEEE/ACM国际软件工程会议，ICSE 2024，葡萄牙里斯本，2024年4月14日至20日*，第17:1–17:12页。ACM。
- en: Ye et al. (2021) He Ye, Matias Martinez, Thomas Durieux, and Martin Monperrus.
    2021. [A comprehensive study of automatic program repair on the quixbugs benchmark](https://doi.org/10.1016/j.jss.2020.110825).
    *J. Syst. Softw.*, 171:110825.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ye 等人（2021）He Ye, Matias Martinez, Thomas Durieux 和 Martin Monperrus. 2021.
    [关于quixbugs基准的自动程序修复的全面研究](https://doi.org/10.1016/j.jss.2020.110825)。 *J. Syst.
    Softw.*, 171:110825。
- en: Ye et al. (2022) He Ye, Matias Martinez, and Martin Monperrus. 2022. Neural
    program repair with execution-based backpropagation. In *44th IEEE/ACM 44th International
    Conference on Software Engineering, ICSE 2022, Pittsburgh, PA, USA, May 25-27,
    2022*, pages 1506–1518\. ACM.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ye 等人（2022）He Ye, Matias Martinez 和 Martin Monperrus. 2022. 基于执行反向传播的神经程序修复。收录于
    *第44届IEEE/ACM国际软件工程会议，ICSE 2022，美国宾夕法尼亚州 Pittsburgh，2022年5月25日至27日*，第1506–1518页。ACM。
- en: Zhang et al. (2011) Lingming Zhang, Miryung Kim, and Sarfraz Khurshid. 2011.
    Localizing failure-inducing program edits based on spectrum information. In *IEEE
    27th International Conference on Software Maintenance, ICSM 2011, Williamsburg,
    VA, USA, September 25-30, 2011*, pages 23–32\. IEEE Computer Society.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zhang 等人（2011）Lingming Zhang, Miryung Kim 和 Sarfraz Khurshid. 2011. 基于谱信息定位引起故障的程序编辑。收录于
    *IEEE第27届国际软件维护会议，ICSM 2011，美国弗吉尼亚州威廉斯堡，2011年9月25日至30日*，第23–32页。IEEE计算机学会。
- en: Zhang et al. (2013) Lingming Zhang, Lu Zhang, and Sarfraz Khurshid. 2013. Injecting
    mechanical faults to localize developer faults for evolving software. In *Proceedings
    of the 2013 ACM SIGPLAN International Conference on Object Oriented Programming
    Systems Languages & Applications, OOPSLA 2013, part of SPLASH 2013, Indianapolis,
    IN, USA, October 26-31, 2013*, pages 765–784\. ACM.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zhang 等人（2013）Lingming Zhang, Lu Zhang 和 Sarfraz Khurshid. 2013. 注入机械故障以定位开发者故障，针对不断发展的软件。收录于
    *2013年ACM SIGPLAN国际会议：面向对象编程系统语言与应用，OOPSLA 2013，SPLASH 2013的一部分，印度波士顿，2013年10月26日至31日*，第765–784页。ACM。
- en: 'Zhu et al. (2021) Qihao Zhu, Zeyu Sun, Yuan-an Xiao, Wenjie Zhang, Kang Yuan,
    Yingfei Xiong, and Lu Zhang. 2021. [A syntax-guided edit decoder for neural program
    repair](https://doi.org/10.1145/3468264.3468544). In *ESEC/FSE ’21: 29th ACM Joint
    European Software Engineering Conference and Symposium on the Foundations of Software
    Engineering, Athens, Greece, August 23-28, 2021*, pages 341–353\. ACM.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zhu 等人（2021）Qihao Zhu、Zeyu Sun、Yuan-an Xiao、Wenjie Zhang、Kang Yuan、Yingfei Xiong
    和 Lu Zhang。2021年。 [A syntax-guided edit decoder for neural program repair](https://doi.org/10.1145/3468264.3468544)。在
    *ESEC/FSE ’21：第29届 ACM 欧洲软件工程会议与软件工程基础学科研讨会，希腊雅典，2021年8月23-28日*，第341-353页。ACM。
- en: Appendix A Appendix
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 A 附录
- en: A.1 Unique Fix Example
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1 独特的修复示例
- en: 'We illustrate the power of FixAgent by showing an example bug that is only
    fixed by FixAgent in Figure [7](https://arxiv.org/html/2404.17153v2#A1.F7 "Figure
    7 ‣ A.1 Unique Fix Example ‣ Appendix A Appendix ‣ FixAgent: Hierarchical Multi-Agent
    Framework for Unified Software Debugging").'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '我们通过展示一个仅由 FixAgent 修复的示例 bug 来说明 FixAgent 的强大功能，如图 [7](https://arxiv.org/html/2404.17153v2#A1.F7
    "Figure 7 ‣ A.1 Unique Fix Example ‣ Appendix A Appendix ‣ FixAgent: Hierarchical
    Multi-Agent Framework for Unified Software Debugging") 所示。'
- en: '![Refer to caption](img/72ddc0b302158b2488da59bc588cad48.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![参考说明文字](img/72ddc0b302158b2488da59bc588cad48.png)'
- en: 'Figure 7: Unique bug fixed by FixAgent in Defects4J.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7：FixAgent 在 Defects4J 中修复的独特 bug。
- en: On the one hand, the fix requires filling in the missing code statements. Traditional
    FL based on failing test coverage cannot directly identify such an error of lacking
    the necessary processing of a branching condition. Plus, many template-based or
    NMT-based APR tools are good at repairing common errors such as syntax errors
    or simple logic errors, but not at generating new business logic. On the other
    hand, this fix requires a deep understanding of the specific Jackson deserialization
    features defined in the package “databind.DeserializationFeature”. Previous LLM-based
    APR often relies on local context in the prompt and statistical correlation so
    as to lack the ability to comprehend other code files within the project repo.
    The three levels of repair enable FixAgent to access extra related information
    (including templates and repo-level documents) and testing feedback, as well as
    enhance its reasoning ability under the idea of divide-and-conquer. Combining
    all these conditions together, FixAgent is able to correctly fix this complex
    bug.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，修复需要填补缺失的代码语句。基于失败测试覆盖的传统 FL 方法无法直接识别缺少对分支条件的必要处理的错误。此外，许多基于模板或基于神经机器翻译（NMT）的自动程序修复（APR）工具擅长修复常见错误，如语法错误或简单的逻辑错误，但不擅长生成新的业务逻辑。另一方面，这个修复需要深入理解在“databind.DeserializationFeature”包中定义的特定
    Jackson 反序列化特性。之前基于大型语言模型（LLM）的 APR 通常依赖于提示中的局部上下文和统计相关性，因此缺乏理解项目仓库内其他代码文件的能力。三层修复机制使
    FixAgent 能够访问额外的相关信息（包括模板和仓库级文档）和测试反馈，并在分而治之的思路下增强其推理能力。综合所有这些条件，FixAgent 能够正确修复这个复杂的
    bug。
- en: A.2 Alogrithm of FixAgent
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2 FixAgent 的算法
- en: 'Algorithm [1](https://arxiv.org/html/2404.17153v2#alg1 "In A.2 Alogrithm of
    FixAgent ‣ Appendix A Appendix ‣ FixAgent: Hierarchical Multi-Agent Framework
    for Unified Software Debugging") shows the pseudo-code of our proposed framework.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '算法 [1](https://arxiv.org/html/2404.17153v2#alg1 "In A.2 Alogrithm of FixAgent
    ‣ Appendix A Appendix ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified
    Software Debugging") 展示了我们提出的框架的伪代码。'
- en: 'Input: $k$: number of maximum debugging attempts; $m$: number of maximum re-sampling
    attempts of a single agent; $bug\_meta$: metadata of the bug, a directory including
    code from the bug-located file, failing test case(s), errors, and program requirements.Output:
    patch, analysis123Function *L1Repair(*$m$, bug_meta, extra_info*)*:4       for *$j\leftarrow
    1$ to $m$* do5             marked_code $\leftarrow$ Locator(bug_meta, extra_info)6            
    if *ValidMarks(marked_code)* then7                   bug_meta[code] $\leftarrow$
    marked_code8                   break9             end if10            11      
    end for12      patch $\leftarrow$ Fixer(bug_meta, extra_info)13       return *patch*14
    End1516Function *L2Repair(*$m$, bug_meta, extra_info*)*:17       if *summary NOT
    IN extra_info* then18             summary $\leftarrow$ Summarizer(bug_meta[code])19            
    extra_info $\leftarrow$ concat[extra_info; summary]20       end if21      22      for *$j\leftarrow
    1$ to $m$* do23             snippet $\leftarrow$ Slicer(bug_meta)24            
    if *ValidSnippet(snippet)* then25                   bug_meta[code] $\leftarrow$
    snippet26                   break27                  28             end if29            30      
    end for31      patch $\leftarrow$ L1Repair(*$m$, bug_meta, extra_info*)32      
    patch, analysis $\leftarrow$ FixerPro(patch, Testing(patch), bug_meta, extra_info)33      
    return *patch, analysis*34 End3536Function *L3Repair(*$m$, bug_meta, extra_info*)*:37      
    references $\leftarrow$ Helper(bug_meta)38       FileList $\leftarrow$ RepoFocus(bug_meta)39      
    summary $\leftarrow$ ArrayList()40       for *file in FileList* do41            
    summary.append(Summarizer(ReadFile(file)))42            43       end for44      extra_info
    $\leftarrow$ concat[extra_info; references; summary]45       return *L2Repair(*$m$,
    bug_meta, extra_info*)*46 End4748Function *Debugging(*$k$, $m$, bug_meta*)*:49      
    for *$i\leftarrow 1$ to $k$* do50             extra_info $\leftarrow$ EmptyList()51            patch
    $\leftarrow$ L1Repair(*$m$, bug_meta, extra_info*)52             if *Testing(patch)* then53                  return
    *patch, EmptyString()*54             end if55            56            patch,
    analysis $\leftarrow$ L2Repair(*$m$, bug_meta, extra_info*)57             if *Testing(patch)* then58                  return
    *patch, analysis*59             end if60            61            patch, analysis
    $\leftarrow$ L3Repair(*$m$, bug_meta, extra_info*)62             if *Testing(patch)* then63                  return
    *patch, analysis*64             end if65            66            patch, analysis
    $\leftarrow$ RefineAgents($m$, bug_meta, extra_info, patch)67             return
    *patch, analysis*68       end for69      70 End71'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '输入：$k$: 最大调试尝试次数；$m$: 单个代理的最大重新采样尝试次数；$bug\_meta$: 错误的元数据，一个目录，包含错误所在文件的代码、失败的测试用例、错误信息和程序需求。输出：补丁，分析123函数
    *L1Repair(*$m$, bug_meta, extra_info*)*:4       对于 *$j\leftarrow 1$ 到 $m$* 进行5             marked_code
    $\leftarrow$ Locator(bug_meta, extra_info)6             如果 *ValidMarks(marked_code)*
    则7                 bug_meta[code] $\leftarrow$ marked_code8                 跳出循环9             结束如果10            11       结束循环12      补丁
    $\leftarrow$ Fixer(bug_meta, extra_info)13       返回 *补丁*14 结束15'
- en: Algorithm 1 FixAgent
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 算法 1 FixAgent
- en: A.3 System Prompts
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3 系统提示
- en: This section shows the specific system prompts of the designed seven agents.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了设计的七个代理的具体系统提示。
- en: '![Refer to caption](img/a5523adf70ac060a95492c2f6e6da39d.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/a5523adf70ac060a95492c2f6e6da39d.png)'
- en: 'Figure 8: System Prompt of Helper.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8：Helper的系统提示。
- en: '![Refer to caption](img/7d354efa1f80be6516b6207a84c2840c.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/7d354efa1f80be6516b6207a84c2840c.png)'
- en: 'Figure 9: System Prompt of RepoFocus.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：RepoFocus的系统提示。
- en: '![Refer to caption](img/0c33af6bcdf3ea9c24b25548a6f145a8.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/0c33af6bcdf3ea9c24b25548a6f145a8.png)'
- en: 'Figure 10: System Prompt of Summarizer.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：Summarizer的系统提示。
- en: '![Refer to caption](img/3fb773e0231801f82a8368ead038ddb2.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/3fb773e0231801f82a8368ead038ddb2.png)'
- en: 'Figure 11: System Prompt of Slicer.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：Slicer的系统提示。
- en: '![Refer to caption](img/9ae27d2681cce036cdd2ca14a329109a.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/9ae27d2681cce036cdd2ca14a329109a.png)'
- en: 'Figure 12: System Prompt of Locator.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：Locator的系统提示。
- en: '![Refer to caption](img/f7cde58ab6426353ed80424cbe6e431f.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/f7cde58ab6426353ed80424cbe6e431f.png)'
- en: 'Figure 13: System Prompt of Fixer.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：Fixer的系统提示。
- en: '![Refer to caption](img/bb21e17e6f355c6757240954e88adf1f.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/bb21e17e6f355c6757240954e88adf1f.png)'
- en: 'Figure 14: System Prompt of FixerPro.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图14：FixerPro的系统提示。
- en: A.4 A Demo of the Execution
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4 执行演示
- en: In this section, we present an example of how FixAgent solves a real-world bug
    on level-3 repair.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了FixAgent如何解决三级修复中的一个真实世界的bug。
- en: A.4.1 Bug Metadata
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.4.1 错误元数据
- en: Upon receiving the necessary information about a bug, FixAgent initializes agents
    for problem-solving. Here is an example bug named Lang-1, a real-world bug in
    Defects4J.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到有关bug的必要信息后，FixAgent初始化用于问题解决的代理。这里是一个名为Lang-1的bug示例，它是Defects4J中的一个真实世界的bug。
- en: 'Using the JUnit framework, we can get detailed information upon failing test
    cases, as displayed in Figure [15](https://arxiv.org/html/2404.17153v2#A1.F15
    "Figure 15 ‣ A.4.1 Bug Metadata ‣ A.4 A Demo of the Execution ‣ Appendix A Appendix
    ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging").'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '使用JUnit框架，我们可以获得关于失败测试用例的详细信息，如图[15](https://arxiv.org/html/2404.17153v2#A1.F15
    "图15 ‣ A.4.1 错误元数据 ‣ A.4 执行演示 ‣ 附录A 附录 ‣ FixAgent: 用于统一软件调试的分层多代理框架")所示。'
- en: '![Refer to caption](img/2f011da08263d8cec6fe7cfc851a1cb1.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/2f011da08263d8cec6fe7cfc851a1cb1.png)'
- en: 'Figure 15: Failing test cases reported by JUnit.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图15：JUnit报告的失败测试用例。
- en: 'Then, we can roughly locate the buggy code file “NumberUtils.java”, whose code
    contents are show in Figure [16](https://arxiv.org/html/2404.17153v2#A1.F16 "Figure
    16 ‣ A.4.1 Bug Metadata ‣ A.4 A Demo of the Execution ‣ Appendix A Appendix ‣
    FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging"),
    as well as the failing oracles in testing code [17](https://arxiv.org/html/2404.17153v2#A1.F17
    "Figure 17 ‣ A.4.1 Bug Metadata ‣ A.4 A Demo of the Execution ‣ Appendix A Appendix
    ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging").'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们可以大致定位到有问题的代码文件“NumberUtils.java”，其代码内容如图[16](https://arxiv.org/html/2404.17153v2#A1.F16
    "图16 ‣ A.4.1 错误元数据 ‣ A.4 执行演示 ‣ 附录A 附录 ‣ FixAgent: 用于统一软件调试的分层多代理框架")所示，以及在测试代码中失败的oracle，[17](https://arxiv.org/html/2404.17153v2#A1.F17
    "图17 ‣ A.4.1 错误元数据 ‣ A.4 执行演示 ‣ 附录A 附录 ‣ FixAgent: 用于统一软件调试的分层多代理框架")中报告的失败oracle。'
- en: '![Refer to caption](img/32311e4a5ba9590ef2dfc5f13b350da1.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/32311e4a5ba9590ef2dfc5f13b350da1.png)'
- en: 'Figure 16: Bug-located code snippet.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图16：错误定位代码片段。
- en: '![Refer to caption](img/677f2f045ee55b1d29b104ae7994f88d.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![参见标题](img/677f2f045ee55b1d29b104ae7994f88d.png)'
- en: 'Figure 17: Testing code triggering errors.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图17：触发错误的测试代码。
- en: From the above information, we can see that the original code merely determines
    whether a value exceeds the ranges of Long and int based on the length of hexadecimal
    numbers. However, when the length of a hexadecimal number is 16, and the first
    significant digit is greater than 7, it actually goes beyond the range of Long.
    The original code fails to take this situation into account, and similar issues
    exist in the int range.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从以上信息可以看出，原始代码仅根据十六进制数字的长度来判断一个值是否超出Long和int的范围。然而，当十六进制数字的长度为16且首个有效数字大于7时，它实际上超出了Long的范围。原始代码没有考虑到这种情况，并且在int范围内也存在类似问题。
- en: A.4.2 L3 Repair
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.4.2 L3 修复
- en: 'For simplicity, we only show the responses from agents on level three of repair.
    Helper generates a short query summarizing the problem of this bug based on the
    testing information and buggy code, as shown in Figure [18](https://arxiv.org/html/2404.17153v2#A1.F18
    "Figure 18 ‣ A.4.2 L3 Repair ‣ A.4 A Demo of the Execution ‣ Appendix A Appendix
    ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging").
    All the other agents can benefit from its generated debugging guide. Afterward,
    RepoFocus lists a list of bug-related files ([19](https://arxiv.org/html/2404.17153v2#A1.F19
    "Figure 19 ‣ A.4.2 L3 Repair ‣ A.4 A Demo of the Execution ‣ Appendix A Appendix
    ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging")).
    Besides the bug-located file, it also identifies two other files. However, they
    would not influence the behavior of the number-creation logic unless you are encountering
    specific exception handling or Unicode string issues when parsing numeric strings.
    Subsequently, Summarizer generates a code summary for each identified file [20](https://arxiv.org/html/2404.17153v2#A1.F20
    "Figure 20 ‣ A.4.2 L3 Repair ‣ A.4 A Demo of the Execution ‣ Appendix A Appendix
    ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging").
    Thus, we got all the information provided by upstream agents.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '为简化起见，我们仅展示了来自第三层修复代理的响应。Helper 根据测试信息和有缺陷的代码生成了一个简短的查询，概括了此 Bug 的问题，如图[18](https://arxiv.org/html/2404.17153v2#A1.F18
    "图 18 ‣ A.4.2 L3 修复 ‣ A.4 执行示例 ‣ 附录 A 附录 ‣ FixAgent: 层次化多代理框架用于统一软件调试")所示。所有其他代理都可以受益于它生成的调试指南。之后，RepoFocus
    列出了与 Bug 相关的文件清单（[19](https://arxiv.org/html/2404.17153v2#A1.F19 "图 19 ‣ A.4.2
    L3 修复 ‣ A.4 执行示例 ‣ 附录 A 附录 ‣ FixAgent: 层次化多代理框架用于统一软件调试")）。除了定位到 Bug 的文件外，它还识别出了其他两个文件。然而，除非在解析数字字符串时遇到特定的异常处理或
    Unicode 字符串问题，否则这些文件不会影响数字创建逻辑的行为。随后，Summarizer 为每个识别的文件生成了代码摘要 [20](https://arxiv.org/html/2404.17153v2#A1.F20
    "图 20 ‣ A.4.2 L3 修复 ‣ A.4 执行示例 ‣ 附录 A 附录 ‣ FixAgent: 层次化多代理框架用于统一软件调试")。因此，我们获得了所有来自上游代理提供的信息。'
- en: '![Refer to caption](img/e560af273aef115100ac7a69ed56503e.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![参见说明文字](img/e560af273aef115100ac7a69ed56503e.png)'
- en: 'Figure 18: Response and tool usage of Helper.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18：Helper 的响应与工具使用。
- en: '![Refer to caption](img/36797227799aa95e248d0018158f2871.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![参见说明文字](img/36797227799aa95e248d0018158f2871.png)'
- en: 'Figure 19: Response of RepoFocus.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19：RepoFocus 的响应。
- en: '![Refer to caption](img/35e6a13ef27d77c6e60ed21bffa4d77f.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![参见说明文字](img/35e6a13ef27d77c6e60ed21bffa4d77f.png)'
- en: 'Figure 20: Response of Summarizer.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20：Summarizer 的响应。
- en: 'Slicer extracts 168 suspicious code lines from 1427 lines in the original buggy
    code, largely narrowing down the examination scope, as shown in Figure [21](https://arxiv.org/html/2404.17153v2#A1.F21
    "Figure 21 ‣ A.4.2 L3 Repair ‣ A.4 A Demo of the Execution ‣ Appendix A Appendix
    ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging").
    Locator successfully pinpoints the root causes of this bug from the code lines
    sliced out [22](https://arxiv.org/html/2404.17153v2#A1.F22 "Figure 22 ‣ A.4.2
    L3 Repair ‣ A.4 A Demo of the Execution ‣ Appendix A Appendix ‣ FixAgent: Hierarchical
    Multi-Agent Framework for Unified Software Debugging"). The following agents can
    focus on the single logic conditions.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'Slicer 从原始有缺陷的 1427 行代码中提取了 168 行可疑代码，极大地缩小了检查范围，如图[21](https://arxiv.org/html/2404.17153v2#A1.F21
    "图 21 ‣ A.4.2 L3 修复 ‣ A.4 执行示例 ‣ 附录 A 附录 ‣ FixAgent: 层次化多代理框架用于统一软件调试")所示。Locator
    成功地从被切割的代码行中找出了此 Bug 的根本原因 [22](https://arxiv.org/html/2404.17153v2#A1.F22 "图
    22 ‣ A.4.2 L3 修复 ‣ A.4 执行示例 ‣ 附录 A 附录 ‣ FixAgent: 层次化多代理框架用于统一软件调试")。接下来的代理可以集中于单一的逻辑条件。'
- en: '![Refer to caption](img/abd467b4ce7c487978eab31169a160fa.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![参见说明文字](img/abd467b4ce7c487978eab31169a160fa.png)'
- en: 'Figure 21: Response of Slicer.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21：Slicer 的响应。
- en: '![Refer to caption](img/b5b38940cd7bd1818f9301a79eab08fb.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![参见说明文字](img/b5b38940cd7bd1818f9301a79eab08fb.png)'
- en: 'Figure 22: Response of Locator.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22：Locator 的响应。
- en: 'However, Fixer failed to generate a plausible patch, as displayed in Figure [23](https://arxiv.org/html/2404.17153v2#A1.F23
    "Figure 23 ‣ A.4.2 L3 Repair ‣ A.4 A Demo of the Execution ‣ Appendix A Appendix
    ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging").
    It attempts to fulfill the missing code block by counting the valid digits of
    the hexadecimal number but causes incorrect type determination when a large number
    of leading zeros are present in a hexadecimal string. The patched code also assumes
    the hex digits should be directly compared based on raw string length without
    adjusting for those leading zeros. FixerPro identified the causes of errors made
    by Fixer, and provides an optimized patch. The fixed version, presented in Figure [24](https://arxiv.org/html/2404.17153v2#A1.F24
    "Figure 24 ‣ A.4.2 L3 Repair ‣ A.4 A Demo of the Execution ‣ Appendix A Appendix
    ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging"),
    properly calculates the significant digits by counting the non-zero characters
    after the prefix and leading zeros. It also adjusts the comparisons for handling
    16-digit and 8-digit boundary checks, ensuring that only significant digits are
    considered when deciding if the value is too large for “Integer” or “Long”.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，Fixer未能生成一个可信的修复补丁，如图[23](https://arxiv.org/html/2404.17153v2#A1.F23 "Figure
    23 ‣ A.4.2 L3 Repair ‣ A.4 A Demo of the Execution ‣ Appendix A Appendix ‣ FixAgent:
    Hierarchical Multi-Agent Framework for Unified Software Debugging")所示。它试图通过计算十六进制数字的有效位数来填补缺失的代码块，但当十六进制字符串中有大量前导零时，导致类型判断错误。修复后的代码还假设十六进制数字应基于原始字符串长度直接进行比较，而没有调整前导零。FixerPro识别出了Fixer所犯错误的原因，并提供了一个优化的修复补丁。修复版本如图[24](https://arxiv.org/html/2404.17153v2#A1.F24
    "Figure 24 ‣ A.4.2 L3 Repair ‣ A.4 A Demo of the Execution ‣ Appendix A Appendix
    ‣ FixAgent: Hierarchical Multi-Agent Framework for Unified Software Debugging")所示，正确地通过计算前缀和前导零后的非零字符来计算有效位数。它还调整了比较，以处理16位和8位边界检查，确保在判断值是否过大以至于无法用于“Integer”或“Long”时，只有有效位数被考虑。'
- en: '![Refer to caption](img/7c41c42f66c7576f1f340c443326a45a.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![参考标题](img/7c41c42f66c7576f1f340c443326a45a.png)'
- en: 'Figure 23: Response of Fixer.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图23：Fixer的响应。
- en: '![Refer to caption](img/7f34fd9fa8f7733865fa02550ed5ec4a.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![参考标题](img/7f34fd9fa8f7733865fa02550ed5ec4a.png)'
- en: 'Figure 24: Response of FixerPro.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图24：FixerPro的响应。
